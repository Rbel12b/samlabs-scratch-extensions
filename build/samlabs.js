/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../scratch-vm/node_modules/atob/node-atob.js":
/*!****************************************************!*\
  !*** ../scratch-vm/node_modules/atob/node-atob.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nfunction atob(str) {\n  return Buffer.from(str, 'base64').toString('binary');\n}\n\nmodule.exports = atob.atob = atob;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/atob/node-atob.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/btoa/index.js":
/*!************************************************!*\
  !*** ../scratch-vm/node_modules/btoa/index.js ***!
  \************************************************/
/***/ ((module) => {

eval("(function () {\n  \"use strict\";\n\n  function btoa(str) {\n    var buffer;\n\n    if (str instanceof Buffer) {\n      buffer = str;\n    } else {\n      buffer = Buffer.from(str.toString(), 'binary');\n    }\n\n    return buffer.toString('base64');\n  }\n\n  module.exports = btoa;\n}());\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/btoa/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/decode-html/index.js":
/*!*******************************************************!*\
  !*** ../scratch-vm/node_modules/decode-html/index.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("// Store markers outside of the function scope,\n// not to recreate them on every call\nvar entities = {\n  'amp': '&',\n  'apos': '\\'',\n  'lt': '<',\n  'gt': '>',\n  'quot': '\"',\n  'nbsp': '\\xa0'\n};\nvar entityPattern = /&([a-z]+);/ig;\n\nmodule.exports = function decodeHTMLEntities(text) {\n  // A single replace pass with a static RegExp is faster than a loop\n  return text.replace(entityPattern, function(match, entity) {\n    entity = entity.toLowerCase();\n    if (entities.hasOwnProperty(entity)) {\n      return entities[entity];\n    }\n    // return original string if there is no matching entity (no replace)\n    return match;\n  });\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/decode-html/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/foreignNames.json":
/*!*******************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/foreignNames.json ***!
  \*******************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"elementNames\":{\"altglyph\":\"altGlyph\",\"altglyphdef\":\"altGlyphDef\",\"altglyphitem\":\"altGlyphItem\",\"animatecolor\":\"animateColor\",\"animatemotion\":\"animateMotion\",\"animatetransform\":\"animateTransform\",\"clippath\":\"clipPath\",\"feblend\":\"feBlend\",\"fecolormatrix\":\"feColorMatrix\",\"fecomponenttransfer\":\"feComponentTransfer\",\"fecomposite\":\"feComposite\",\"feconvolvematrix\":\"feConvolveMatrix\",\"fediffuselighting\":\"feDiffuseLighting\",\"fedisplacementmap\":\"feDisplacementMap\",\"fedistantlight\":\"feDistantLight\",\"fedropshadow\":\"feDropShadow\",\"feflood\":\"feFlood\",\"fefunca\":\"feFuncA\",\"fefuncb\":\"feFuncB\",\"fefuncg\":\"feFuncG\",\"fefuncr\":\"feFuncR\",\"fegaussianblur\":\"feGaussianBlur\",\"feimage\":\"feImage\",\"femerge\":\"feMerge\",\"femergenode\":\"feMergeNode\",\"femorphology\":\"feMorphology\",\"feoffset\":\"feOffset\",\"fepointlight\":\"fePointLight\",\"fespecularlighting\":\"feSpecularLighting\",\"fespotlight\":\"feSpotLight\",\"fetile\":\"feTile\",\"feturbulence\":\"feTurbulence\",\"foreignobject\":\"foreignObject\",\"glyphref\":\"glyphRef\",\"lineargradient\":\"linearGradient\",\"radialgradient\":\"radialGradient\",\"textpath\":\"textPath\"},\"attributeNames\":{\"definitionurl\":\"definitionURL\",\"attributename\":\"attributeName\",\"attributetype\":\"attributeType\",\"basefrequency\":\"baseFrequency\",\"baseprofile\":\"baseProfile\",\"calcmode\":\"calcMode\",\"clippathunits\":\"clipPathUnits\",\"diffuseconstant\":\"diffuseConstant\",\"edgemode\":\"edgeMode\",\"filterunits\":\"filterUnits\",\"glyphref\":\"glyphRef\",\"gradienttransform\":\"gradientTransform\",\"gradientunits\":\"gradientUnits\",\"kernelmatrix\":\"kernelMatrix\",\"kernelunitlength\":\"kernelUnitLength\",\"keypoints\":\"keyPoints\",\"keysplines\":\"keySplines\",\"keytimes\":\"keyTimes\",\"lengthadjust\":\"lengthAdjust\",\"limitingconeangle\":\"limitingConeAngle\",\"markerheight\":\"markerHeight\",\"markerunits\":\"markerUnits\",\"markerwidth\":\"markerWidth\",\"maskcontentunits\":\"maskContentUnits\",\"maskunits\":\"maskUnits\",\"numoctaves\":\"numOctaves\",\"pathlength\":\"pathLength\",\"patterncontentunits\":\"patternContentUnits\",\"patterntransform\":\"patternTransform\",\"patternunits\":\"patternUnits\",\"pointsatx\":\"pointsAtX\",\"pointsaty\":\"pointsAtY\",\"pointsatz\":\"pointsAtZ\",\"preservealpha\":\"preserveAlpha\",\"preserveaspectratio\":\"preserveAspectRatio\",\"primitiveunits\":\"primitiveUnits\",\"refx\":\"refX\",\"refy\":\"refY\",\"repeatcount\":\"repeatCount\",\"repeatdur\":\"repeatDur\",\"requiredextensions\":\"requiredExtensions\",\"requiredfeatures\":\"requiredFeatures\",\"specularconstant\":\"specularConstant\",\"specularexponent\":\"specularExponent\",\"spreadmethod\":\"spreadMethod\",\"startoffset\":\"startOffset\",\"stddeviation\":\"stdDeviation\",\"stitchtiles\":\"stitchTiles\",\"surfacescale\":\"surfaceScale\",\"systemlanguage\":\"systemLanguage\",\"tablevalues\":\"tableValues\",\"targetx\":\"targetX\",\"targety\":\"targetY\",\"textlength\":\"textLength\",\"viewbox\":\"viewBox\",\"viewtarget\":\"viewTarget\",\"xchannelselector\":\"xChannelSelector\",\"ychannelselector\":\"yChannelSelector\",\"zoomandpan\":\"zoomAndPan\"}}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/foreignNames.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/index.js":
/*!**********************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/index.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n  Module dependencies\n*/\nvar ElementType = __webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/dom-serializer/node_modules/domelementtype/lib/index.js\");\nvar entities = __webpack_require__(/*! entities */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/index.js\");\n\n/* mixed-case SVG and MathML tags & attributes\n   recognized by the HTML parser, see\n   https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n*/\nvar foreignNames = __webpack_require__(/*! ./foreignNames.json */ \"../scratch-vm/node_modules/dom-serializer/foreignNames.json\");\nforeignNames.elementNames.__proto__ = null; /* use as a simple dictionary */\nforeignNames.attributeNames.__proto__ = null;\n\nvar unencodedElements = {\n  __proto__: null,\n  style: true,\n  script: true,\n  xmp: true,\n  iframe: true,\n  noembed: true,\n  noframes: true,\n  plaintext: true,\n  noscript: true\n};\n\n/*\n  Format attributes\n*/\nfunction formatAttrs(attributes, opts) {\n  if (!attributes) return;\n\n  var output = '';\n  var value;\n\n  // Loop through the attributes\n  for (var key in attributes) {\n    value = attributes[key];\n    if (output) {\n      output += ' ';\n    }\n\n    if (opts.xmlMode === 'foreign') {\n      /* fix up mixed-case attribute names */\n      key = foreignNames.attributeNames[key] || key;\n    }\n    output += key;\n    if ((value !== null && value !== '') || opts.xmlMode) {\n      output +=\n        '=\"' +\n        (opts.decodeEntities\n          ? entities.encodeXML(value)\n          : value.replace(/\\\"/g, '&quot;')) +\n        '\"';\n    }\n  }\n\n  return output;\n}\n\n/*\n  Self-enclosing tags (stolen from node-htmlparser)\n*/\nvar singleTag = {\n  __proto__: null,\n  area: true,\n  base: true,\n  basefont: true,\n  br: true,\n  col: true,\n  command: true,\n  embed: true,\n  frame: true,\n  hr: true,\n  img: true,\n  input: true,\n  isindex: true,\n  keygen: true,\n  link: true,\n  meta: true,\n  param: true,\n  source: true,\n  track: true,\n  wbr: true\n};\n\nvar render = (module.exports = function(dom, opts) {\n  if (!Array.isArray(dom) && !dom.cheerio) dom = [dom];\n  opts = opts || {};\n\n  var output = '';\n\n  for (var i = 0; i < dom.length; i++) {\n    var elem = dom[i];\n\n    if (elem.type === 'root') output += render(elem.children, opts);\n    else if (ElementType.isTag(elem)) output += renderTag(elem, opts);\n    else if (elem.type === ElementType.Directive)\n      output += renderDirective(elem);\n    else if (elem.type === ElementType.Comment) output += renderComment(elem);\n    else if (elem.type === ElementType.CDATA) output += renderCdata(elem);\n    else output += renderText(elem, opts);\n  }\n\n  return output;\n});\n\nvar foreignModeIntegrationPoints = [\n  'mi',\n  'mo',\n  'mn',\n  'ms',\n  'mtext',\n  'annotation-xml',\n  'foreignObject',\n  'desc',\n  'title'\n];\n\nfunction renderTag(elem, opts) {\n  // Handle SVG / MathML in HTML\n  if (opts.xmlMode === 'foreign') {\n    /* fix up mixed-case element names */\n    elem.name = foreignNames.elementNames[elem.name] || elem.name;\n    /* exit foreign mode at integration points */\n    if (\n      elem.parent &&\n      foreignModeIntegrationPoints.indexOf(elem.parent.name) >= 0\n    )\n      opts = Object.assign({}, opts, { xmlMode: false });\n  }\n  if (!opts.xmlMode && ['svg', 'math'].indexOf(elem.name) >= 0) {\n    opts = Object.assign({}, opts, { xmlMode: 'foreign' });\n  }\n\n  var tag = '<' + elem.name;\n  var attribs = formatAttrs(elem.attribs, opts);\n\n  if (attribs) {\n    tag += ' ' + attribs;\n  }\n\n  if (opts.xmlMode && (!elem.children || elem.children.length === 0)) {\n    tag += '/>';\n  } else {\n    tag += '>';\n    if (elem.children) {\n      tag += render(elem.children, opts);\n    }\n\n    if (!singleTag[elem.name] || opts.xmlMode) {\n      tag += '</' + elem.name + '>';\n    }\n  }\n\n  return tag;\n}\n\nfunction renderDirective(elem) {\n  return '<' + elem.data + '>';\n}\n\nfunction renderText(elem, opts) {\n  var data = elem.data || '';\n\n  // if entities weren't decoded, no need to encode them back\n  if (\n    opts.decodeEntities &&\n    !(elem.parent && elem.parent.name in unencodedElements)\n  ) {\n    data = entities.encodeXML(data);\n  }\n\n  return data;\n}\n\nfunction renderCdata(elem) {\n  return '<![CDATA[' + elem.children[0].data + ']]>';\n}\n\nfunction renderComment(elem) {\n  return '<!--' + elem.data + '-->';\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/domelementtype/lib/index.js":
/*!******************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/domelementtype/lib/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;\n/** Types of elements found in htmlparser2's DOM */\nvar ElementType;\n(function (ElementType) {\n    /** Type for the root element of a document */\n    ElementType[\"Root\"] = \"root\";\n    /** Type for Text */\n    ElementType[\"Text\"] = \"text\";\n    /** Type for <? ... ?> */\n    ElementType[\"Directive\"] = \"directive\";\n    /** Type for <!-- ... --> */\n    ElementType[\"Comment\"] = \"comment\";\n    /** Type for <script> tags */\n    ElementType[\"Script\"] = \"script\";\n    /** Type for <style> tags */\n    ElementType[\"Style\"] = \"style\";\n    /** Type for Any tag */\n    ElementType[\"Tag\"] = \"tag\";\n    /** Type for <![CDATA[ ... ]]> */\n    ElementType[\"CDATA\"] = \"cdata\";\n    /** Type for <!doctype ...> */\n    ElementType[\"Doctype\"] = \"doctype\";\n})(ElementType = exports.ElementType || (exports.ElementType = {}));\n/**\n * Tests whether an element is a tag or not.\n *\n * @param elem Element to test\n */\nfunction isTag(elem) {\n    return (elem.type === ElementType.Tag ||\n        elem.type === ElementType.Script ||\n        elem.type === ElementType.Style);\n}\nexports.isTag = isTag;\n// Exports for backwards compatibility\n/** Type for the root element of a document */\nexports.Root = ElementType.Root;\n/** Type for Text */\nexports.Text = ElementType.Text;\n/** Type for <? ... ?> */\nexports.Directive = ElementType.Directive;\n/** Type for <!-- ... --> */\nexports.Comment = ElementType.Comment;\n/** Type for <script> tags */\nexports.Script = ElementType.Script;\n/** Type for <style> tags */\nexports.Style = ElementType.Style;\n/** Type for Any tag */\nexports.Tag = ElementType.Tag;\n/** Type for <![CDATA[ ... ]]> */\nexports.CDATA = ElementType.CDATA;\n/** Type for <!doctype ...> */\nexports.Doctype = ElementType.Doctype;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/domelementtype/lib/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode.js":
/*!*************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeHTML = exports.decodeHTMLStrict = exports.decodeXML = void 0;\nvar entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json\"));\nvar legacy_json_1 = __importDefault(__webpack_require__(/*! ./maps/legacy.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json\"));\nvar xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json\"));\nvar decode_codepoint_1 = __importDefault(__webpack_require__(/*! ./decode_codepoint */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js\"));\nvar strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\\da-fA-F]+|#\\d+);/g;\nexports.decodeXML = getStrictDecoder(xml_json_1.default);\nexports.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);\nfunction getStrictDecoder(map) {\n    var replace = getReplacer(map);\n    return function (str) { return String(str).replace(strictEntityRe, replace); };\n}\nvar sorter = function (a, b) { return (a < b ? 1 : -1); };\nexports.decodeHTML = (function () {\n    var legacy = Object.keys(legacy_json_1.default).sort(sorter);\n    var keys = Object.keys(entities_json_1.default).sort(sorter);\n    for (var i = 0, j = 0; i < keys.length; i++) {\n        if (legacy[j] === keys[i]) {\n            keys[i] += \";?\";\n            j++;\n        }\n        else {\n            keys[i] += \";\";\n        }\n    }\n    var re = new RegExp(\"&(?:\" + keys.join(\"|\") + \"|#[xX][\\\\da-fA-F]+;?|#\\\\d+;?)\", \"g\");\n    var replace = getReplacer(entities_json_1.default);\n    function replacer(str) {\n        if (str.substr(-1) !== \";\")\n            str += \";\";\n        return replace(str);\n    }\n    // TODO consider creating a merged map\n    return function (str) { return String(str).replace(re, replacer); };\n})();\nfunction getReplacer(map) {\n    return function replace(str) {\n        if (str.charAt(1) === \"#\") {\n            var secondChar = str.charAt(2);\n            if (secondChar === \"X\" || secondChar === \"x\") {\n                return decode_codepoint_1.default(parseInt(str.substr(3), 16));\n            }\n            return decode_codepoint_1.default(parseInt(str.substr(2), 10));\n        }\n        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n        return map[str.slice(1, -1)] || str;\n    };\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js":
/*!***********************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar decode_json_1 = __importDefault(__webpack_require__(/*! ./maps/decode.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json\"));\n// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nvar fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.fromCodePoint ||\n    function (codePoint) {\n        var output = \"\";\n        if (codePoint > 0xffff) {\n            codePoint -= 0x10000;\n            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n            codePoint = 0xdc00 | (codePoint & 0x3ff);\n        }\n        output += String.fromCharCode(codePoint);\n        return output;\n    };\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n    if (codePoint in decode_json_1.default) {\n        codePoint = decode_json_1.default[codePoint];\n    }\n    return fromCodePoint(codePoint);\n}\nexports[\"default\"] = decodeCodePoint;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/encode.js":
/*!*************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/encode.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = void 0;\nvar xml_json_1 = __importDefault(__webpack_require__(/*! ./maps/xml.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json\"));\nvar inverseXML = getInverseObj(xml_json_1.default);\nvar xmlReplacer = getInverseReplacer(inverseXML);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeXML = getASCIIEncoder(inverseXML);\nvar entities_json_1 = __importDefault(__webpack_require__(/*! ./maps/entities.json */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json\"));\nvar inverseHTML = getInverseObj(entities_json_1.default);\nvar htmlReplacer = getInverseReplacer(inverseHTML);\n/**\n * Encodes all entities and non-ASCII characters in the input.\n *\n * This includes characters that are valid ASCII characters in HTML documents.\n * For example `#` will be encoded as `&num;`. To get a more compact output,\n * consider using the `encodeNonAsciiHTML` function.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeHTML = getInverse(inverseHTML, htmlReplacer);\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nexports.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);\nfunction getInverseObj(obj) {\n    return Object.keys(obj)\n        .sort()\n        .reduce(function (inverse, name) {\n        inverse[obj[name]] = \"&\" + name + \";\";\n        return inverse;\n    }, {});\n}\nfunction getInverseReplacer(inverse) {\n    var single = [];\n    var multiple = [];\n    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {\n        var k = _a[_i];\n        if (k.length === 1) {\n            // Add value to single array\n            single.push(\"\\\\\" + k);\n        }\n        else {\n            // Add value to multiple array\n            multiple.push(k);\n        }\n    }\n    // Add ranges to single characters.\n    single.sort();\n    for (var start = 0; start < single.length - 1; start++) {\n        // Find the end of a run of characters\n        var end = start;\n        while (end < single.length - 1 &&\n            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {\n            end += 1;\n        }\n        var count = 1 + end - start;\n        // We want to replace at least three characters\n        if (count < 3)\n            continue;\n        single.splice(start, count, single[start] + \"-\" + single[end]);\n    }\n    multiple.unshift(\"[\" + single.join(\"\") + \"]\");\n    return new RegExp(multiple.join(\"|\"), \"g\");\n}\n// /[^\\0-\\x7F]/gu\nvar reNonASCII = /(?:[\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])/g;\nvar getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        function (str) { return str.codePointAt(0); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c) {\n            return (c.charCodeAt(0) - 0xd800) * 0x400 +\n                c.charCodeAt(1) -\n                0xdc00 +\n                0x10000;\n        };\nfunction singleCharReplacer(c) {\n    return \"&#x\" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))\n        .toString(16)\n        .toUpperCase() + \";\";\n}\nfunction getInverse(inverse, re) {\n    return function (data) {\n        return data\n            .replace(re, function (name) { return inverse[name]; })\n            .replace(reNonASCII, singleCharReplacer);\n    };\n}\nvar reEscapeChars = new RegExp(xmlReplacer.source + \"|\" + reNonASCII.source, \"g\");\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nfunction escape(data) {\n    return data.replace(reEscapeChars, singleCharReplacer);\n}\nexports.escape = escape;\n/**\n * Encodes all characters not valid in XML documents using numeric hexadecimal\n * reference (eg. `&#xfc;`).\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nfunction escapeUTF8(data) {\n    return data.replace(xmlReplacer, singleCharReplacer);\n}\nexports.escapeUTF8 = escapeUTF8;\nfunction getASCIIEncoder(obj) {\n    return function (data) {\n        return data.replace(reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });\n    };\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/encode.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/index.js":
/*!************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;\nvar decode_1 = __webpack_require__(/*! ./decode */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode.js\");\nvar encode_1 = __webpack_require__(/*! ./encode */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/encode.js\");\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeXML` or `decodeHTML` directly.\n */\nfunction decode(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);\n}\nexports.decode = decode;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.\n */\nfunction decodeStrict(data, level) {\n    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.\n * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.\n */\nfunction encode(data, level) {\n    return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);\n}\nexports.encode = encode;\nvar encode_2 = __webpack_require__(/*! ./encode */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/encode.js\");\nObject.defineProperty(exports, \"encodeXML\", ({ enumerable: true, get: function () { return encode_2.encodeXML; } }));\nObject.defineProperty(exports, \"encodeHTML\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", ({ enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } }));\nObject.defineProperty(exports, \"escape\", ({ enumerable: true, get: function () { return encode_2.escape; } }));\nObject.defineProperty(exports, \"escapeUTF8\", ({ enumerable: true, get: function () { return encode_2.escapeUTF8; } }));\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nObject.defineProperty(exports, \"encodeHTML5\", ({ enumerable: true, get: function () { return encode_2.encodeHTML; } }));\nvar decode_2 = __webpack_require__(/*! ./decode */ \"../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/decode.js\");\nObject.defineProperty(exports, \"decodeXML\", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));\nObject.defineProperty(exports, \"decodeHTML\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTMLStrict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTML5\", ({ enumerable: true, get: function () { return decode_2.decodeHTML; } }));\nObject.defineProperty(exports, \"decodeHTML4Strict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\nObject.defineProperty(exports, \"decodeHTML5Strict\", ({ enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } }));\nObject.defineProperty(exports, \"decodeXMLStrict\", ({ enumerable: true, get: function () { return decode_2.decodeXML; } }));\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json":
/*!********************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/decode.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json":
/*!**********************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json ***!
  \**********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"\\'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/entities.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json":
/*!********************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json ***!
  \********************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/legacy.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json":
/*!*****************************************************************************************!*\
  !*** ../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json ***!
  \*****************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"amp\":\"&\",\"apos\":\"\\'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\\\"\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/dom-serializer/node_modules/entities/lib/maps/xml.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/domelementtype/index.js":
/*!**********************************************************!*\
  !*** ../scratch-vm/node_modules/domelementtype/index.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("//Types of elements found in the DOM\nmodule.exports = {\n\tText: \"text\", //Text\n\tDirective: \"directive\", //<? ... ?>\n\tComment: \"comment\", //<!-- ... -->\n\tScript: \"script\", //<script> tags\n\tStyle: \"style\", //<style> tags\n\tTag: \"tag\", //Any tag\n\tCDATA: \"cdata\", //<![CDATA[ ... ]]>\n\tDoctype: \"doctype\",\n\n\tisTag: function(elem){\n\t\treturn elem.type === \"tag\" || elem.type === \"script\" || elem.type === \"style\";\n\t}\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domelementtype/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domhandler/index.js":
/*!******************************************************!*\
  !*** ../scratch-vm/node_modules/domhandler/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ElementType = __webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/domelementtype/index.js\");\n\nvar re_whitespace = /\\s+/g;\nvar NodePrototype = __webpack_require__(/*! ./lib/node */ \"../scratch-vm/node_modules/domhandler/lib/node.js\");\nvar ElementPrototype = __webpack_require__(/*! ./lib/element */ \"../scratch-vm/node_modules/domhandler/lib/element.js\");\n\nfunction DomHandler(callback, options, elementCB){\n\tif(typeof callback === \"object\"){\n\t\telementCB = options;\n\t\toptions = callback;\n\t\tcallback = null;\n\t} else if(typeof options === \"function\"){\n\t\telementCB = options;\n\t\toptions = defaultOpts;\n\t}\n\tthis._callback = callback;\n\tthis._options = options || defaultOpts;\n\tthis._elementCB = elementCB;\n\tthis.dom = [];\n\tthis._done = false;\n\tthis._tagStack = [];\n\tthis._parser = this._parser || null;\n}\n\n//default options\nvar defaultOpts = {\n\tnormalizeWhitespace: false, //Replace all whitespace with single spaces\n\twithStartIndices: false, //Add startIndex properties to nodes\n\twithEndIndices: false, //Add endIndex properties to nodes\n};\n\nDomHandler.prototype.onparserinit = function(parser){\n\tthis._parser = parser;\n};\n\n//Resets the handler back to starting state\nDomHandler.prototype.onreset = function(){\n\tDomHandler.call(this, this._callback, this._options, this._elementCB);\n};\n\n//Signals the handler that parsing is done\nDomHandler.prototype.onend = function(){\n\tif(this._done) return;\n\tthis._done = true;\n\tthis._parser = null;\n\tthis._handleCallback(null);\n};\n\nDomHandler.prototype._handleCallback =\nDomHandler.prototype.onerror = function(error){\n\tif(typeof this._callback === \"function\"){\n\t\tthis._callback(error, this.dom);\n\t} else {\n\t\tif(error) throw error;\n\t}\n};\n\nDomHandler.prototype.onclosetag = function(){\n\t//if(this._tagStack.pop().name !== name) this._handleCallback(Error(\"Tagname didn't match!\"));\n\t\n\tvar elem = this._tagStack.pop();\n\n\tif(this._options.withEndIndices && elem){\n\t\telem.endIndex = this._parser.endIndex;\n\t}\n\n\tif(this._elementCB) this._elementCB(elem);\n};\n\nDomHandler.prototype._createDomElement = function(properties){\n\tif (!this._options.withDomLvl1) return properties;\n\n\tvar element;\n\tif (properties.type === \"tag\") {\n\t\telement = Object.create(ElementPrototype);\n\t} else {\n\t\telement = Object.create(NodePrototype);\n\t}\n\n\tfor (var key in properties) {\n\t\tif (properties.hasOwnProperty(key)) {\n\t\t\telement[key] = properties[key];\n\t\t}\n\t}\n\n\treturn element;\n};\n\nDomHandler.prototype._addDomElement = function(element){\n\tvar parent = this._tagStack[this._tagStack.length - 1];\n\tvar siblings = parent ? parent.children : this.dom;\n\tvar previousSibling = siblings[siblings.length - 1];\n\n\telement.next = null;\n\n\tif(this._options.withStartIndices){\n\t\telement.startIndex = this._parser.startIndex;\n\t}\n\tif(this._options.withEndIndices){\n\t\telement.endIndex = this._parser.endIndex;\n\t}\n\n\tif(previousSibling){\n\t\telement.prev = previousSibling;\n\t\tpreviousSibling.next = element;\n\t} else {\n\t\telement.prev = null;\n\t}\n\n\tsiblings.push(element);\n\telement.parent = parent || null;\n};\n\nDomHandler.prototype.onopentag = function(name, attribs){\n\tvar properties = {\n\t\ttype: name === \"script\" ? ElementType.Script : name === \"style\" ? ElementType.Style : ElementType.Tag,\n\t\tname: name,\n\t\tattribs: attribs,\n\t\tchildren: []\n\t};\n\n\tvar element = this._createDomElement(properties);\n\n\tthis._addDomElement(element);\n\n\tthis._tagStack.push(element);\n};\n\nDomHandler.prototype.ontext = function(data){\n\t//the ignoreWhitespace is officially dropped, but for now,\n\t//it's an alias for normalizeWhitespace\n\tvar normalize = this._options.normalizeWhitespace || this._options.ignoreWhitespace;\n\n\tvar lastTag;\n\n\tif(!this._tagStack.length && this.dom.length && (lastTag = this.dom[this.dom.length-1]).type === ElementType.Text){\n\t\tif(normalize){\n\t\t\tlastTag.data = (lastTag.data + data).replace(re_whitespace, \" \");\n\t\t} else {\n\t\t\tlastTag.data += data;\n\t\t}\n\t} else {\n\t\tif(\n\t\t\tthis._tagStack.length &&\n\t\t\t(lastTag = this._tagStack[this._tagStack.length - 1]) &&\n\t\t\t(lastTag = lastTag.children[lastTag.children.length - 1]) &&\n\t\t\tlastTag.type === ElementType.Text\n\t\t){\n\t\t\tif(normalize){\n\t\t\t\tlastTag.data = (lastTag.data + data).replace(re_whitespace, \" \");\n\t\t\t} else {\n\t\t\t\tlastTag.data += data;\n\t\t\t}\n\t\t} else {\n\t\t\tif(normalize){\n\t\t\t\tdata = data.replace(re_whitespace, \" \");\n\t\t\t}\n\n\t\t\tvar element = this._createDomElement({\n\t\t\t\tdata: data,\n\t\t\t\ttype: ElementType.Text\n\t\t\t});\n\n\t\t\tthis._addDomElement(element);\n\t\t}\n\t}\n};\n\nDomHandler.prototype.oncomment = function(data){\n\tvar lastTag = this._tagStack[this._tagStack.length - 1];\n\n\tif(lastTag && lastTag.type === ElementType.Comment){\n\t\tlastTag.data += data;\n\t\treturn;\n\t}\n\n\tvar properties = {\n\t\tdata: data,\n\t\ttype: ElementType.Comment\n\t};\n\n\tvar element = this._createDomElement(properties);\n\n\tthis._addDomElement(element);\n\tthis._tagStack.push(element);\n};\n\nDomHandler.prototype.oncdatastart = function(){\n\tvar properties = {\n\t\tchildren: [{\n\t\t\tdata: \"\",\n\t\t\ttype: ElementType.Text\n\t\t}],\n\t\ttype: ElementType.CDATA\n\t};\n\n\tvar element = this._createDomElement(properties);\n\n\tthis._addDomElement(element);\n\tthis._tagStack.push(element);\n};\n\nDomHandler.prototype.oncommentend = DomHandler.prototype.oncdataend = function(){\n\tthis._tagStack.pop();\n};\n\nDomHandler.prototype.onprocessinginstruction = function(name, data){\n\tvar element = this._createDomElement({\n\t\tname: name,\n\t\tdata: data,\n\t\ttype: ElementType.Directive\n\t});\n\n\tthis._addDomElement(element);\n};\n\nmodule.exports = DomHandler;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domhandler/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domhandler/lib/element.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/domhandler/lib/element.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// DOM-Level-1-compliant structure\nvar NodePrototype = __webpack_require__(/*! ./node */ \"../scratch-vm/node_modules/domhandler/lib/node.js\");\nvar ElementPrototype = module.exports = Object.create(NodePrototype);\n\nvar domLvl1 = {\n\ttagName: \"name\"\n};\n\nObject.keys(domLvl1).forEach(function(key) {\n\tvar shorthand = domLvl1[key];\n\tObject.defineProperty(ElementPrototype, key, {\n\t\tget: function() {\n\t\t\treturn this[shorthand] || null;\n\t\t},\n\t\tset: function(val) {\n\t\t\tthis[shorthand] = val;\n\t\t\treturn val;\n\t\t}\n\t});\n});\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domhandler/lib/element.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domhandler/lib/node.js":
/*!*********************************************************!*\
  !*** ../scratch-vm/node_modules/domhandler/lib/node.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("// This object will be used as the prototype for Nodes when creating a\n// DOM-Level-1-compliant structure.\nvar NodePrototype = module.exports = {\n\tget firstChild() {\n\t\tvar children = this.children;\n\t\treturn children && children[0] || null;\n\t},\n\tget lastChild() {\n\t\tvar children = this.children;\n\t\treturn children && children[children.length - 1] || null;\n\t},\n\tget nodeType() {\n\t\treturn nodeTypes[this.type] || nodeTypes.element;\n\t}\n};\n\nvar domLvl1 = {\n\ttagName: \"name\",\n\tchildNodes: \"children\",\n\tparentNode: \"parent\",\n\tpreviousSibling: \"prev\",\n\tnextSibling: \"next\",\n\tnodeValue: \"data\"\n};\n\nvar nodeTypes = {\n\telement: 1,\n\ttext: 3,\n\tcdata: 4,\n\tcomment: 8\n};\n\nObject.keys(domLvl1).forEach(function(key) {\n\tvar shorthand = domLvl1[key];\n\tObject.defineProperty(NodePrototype, key, {\n\t\tget: function() {\n\t\t\treturn this[shorthand] || null;\n\t\t},\n\t\tset: function(val) {\n\t\t\tthis[shorthand] = val;\n\t\t\treturn val;\n\t\t}\n\t});\n});\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domhandler/lib/node.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/index.js":
/*!****************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var DomUtils = module.exports;\n\n[\n\t__webpack_require__(/*! ./lib/stringify */ \"../scratch-vm/node_modules/domutils/lib/stringify.js\"),\n\t__webpack_require__(/*! ./lib/traversal */ \"../scratch-vm/node_modules/domutils/lib/traversal.js\"),\n\t__webpack_require__(/*! ./lib/manipulation */ \"../scratch-vm/node_modules/domutils/lib/manipulation.js\"),\n\t__webpack_require__(/*! ./lib/querying */ \"../scratch-vm/node_modules/domutils/lib/querying.js\"),\n\t__webpack_require__(/*! ./lib/legacy */ \"../scratch-vm/node_modules/domutils/lib/legacy.js\"),\n\t__webpack_require__(/*! ./lib/helpers */ \"../scratch-vm/node_modules/domutils/lib/helpers.js\")\n].forEach(function(ext){\n\tObject.keys(ext).forEach(function(key){\n\t\tDomUtils[key] = ext[key].bind(DomUtils);\n\t});\n});\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/helpers.js":
/*!**********************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/helpers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// removeSubsets\n// Given an array of nodes, remove any member that is contained by another.\nexports.removeSubsets = function(nodes) {\n\tvar idx = nodes.length, node, ancestor, replace;\n\n\t// Check if each node (or one of its ancestors) is already contained in the\n\t// array.\n\twhile (--idx > -1) {\n\t\tnode = ancestor = nodes[idx];\n\n\t\t// Temporarily remove the node under consideration\n\t\tnodes[idx] = null;\n\t\treplace = true;\n\n\t\twhile (ancestor) {\n\t\t\tif (nodes.indexOf(ancestor) > -1) {\n\t\t\t\treplace = false;\n\t\t\t\tnodes.splice(idx, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tancestor = ancestor.parent;\n\t\t}\n\n\t\t// If the node has been found to be unique, re-insert it.\n\t\tif (replace) {\n\t\t\tnodes[idx] = node;\n\t\t}\n\t}\n\n\treturn nodes;\n};\n\n// Source: http://dom.spec.whatwg.org/#dom-node-comparedocumentposition\nvar POSITION = {\n\tDISCONNECTED: 1,\n\tPRECEDING: 2,\n\tFOLLOWING: 4,\n\tCONTAINS: 8,\n\tCONTAINED_BY: 16\n};\n\n// Compare the position of one node against another node in any other document.\n// The return value is a bitmask with the following values:\n//\n// document order:\n// > There is an ordering, document order, defined on all the nodes in the\n// > document corresponding to the order in which the first character of the\n// > XML representation of each node occurs in the XML representation of the\n// > document after expansion of general entities. Thus, the document element\n// > node will be the first node. Element nodes occur before their children.\n// > Thus, document order orders element nodes in order of the occurrence of\n// > their start-tag in the XML (after expansion of entities). The attribute\n// > nodes of an element occur after the element and before its children. The\n// > relative order of attribute nodes is implementation-dependent./\n// Source:\n// http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n//\n// @argument {Node} nodaA The first node to use in the comparison\n// @argument {Node} nodeB The second node to use in the comparison\n//\n// @return {Number} A bitmask describing the input nodes' relative position.\n//         See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n//         a description of these values.\nvar comparePos = exports.compareDocumentPosition = function(nodeA, nodeB) {\n\tvar aParents = [];\n\tvar bParents = [];\n\tvar current, sharedParent, siblings, aSibling, bSibling, idx;\n\n\tif (nodeA === nodeB) {\n\t\treturn 0;\n\t}\n\n\tcurrent = nodeA;\n\twhile (current) {\n\t\taParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\tcurrent = nodeB;\n\twhile (current) {\n\t\tbParents.unshift(current);\n\t\tcurrent = current.parent;\n\t}\n\n\tidx = 0;\n\twhile (aParents[idx] === bParents[idx]) {\n\t\tidx++;\n\t}\n\n\tif (idx === 0) {\n\t\treturn POSITION.DISCONNECTED;\n\t}\n\n\tsharedParent = aParents[idx - 1];\n\tsiblings = sharedParent.children;\n\taSibling = aParents[idx];\n\tbSibling = bParents[idx];\n\n\tif (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n\t\tif (sharedParent === nodeB) {\n\t\t\treturn POSITION.FOLLOWING | POSITION.CONTAINED_BY;\n\t\t}\n\t\treturn POSITION.FOLLOWING;\n\t} else {\n\t\tif (sharedParent === nodeA) {\n\t\t\treturn POSITION.PRECEDING | POSITION.CONTAINS;\n\t\t}\n\t\treturn POSITION.PRECEDING;\n\t}\n};\n\n// Sort an array of nodes based on their relative position in the document and\n// remove any duplicate nodes. If the array contains nodes that do not belong\n// to the same document, sort order is unspecified.\n//\n// @argument {Array} nodes Array of DOM nodes\n//\n// @returns {Array} collection of unique nodes, sorted in document order\nexports.uniqueSort = function(nodes) {\n\tvar idx = nodes.length, node, position;\n\n\tnodes = nodes.slice();\n\n\twhile (--idx > -1) {\n\t\tnode = nodes[idx];\n\t\tposition = nodes.indexOf(node);\n\t\tif (position > -1 && position < idx) {\n\t\t\tnodes.splice(idx, 1);\n\t\t}\n\t}\n\tnodes.sort(function(a, b) {\n\t\tvar relative = comparePos(a, b);\n\t\tif (relative & POSITION.PRECEDING) {\n\t\t\treturn -1;\n\t\t} else if (relative & POSITION.FOLLOWING) {\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t});\n\n\treturn nodes;\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/helpers.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/legacy.js":
/*!*********************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/legacy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var ElementType = __webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/domelementtype/index.js\");\nvar isTag = exports.isTag = ElementType.isTag;\n\nexports.testElement = function(options, element){\n\tfor(var key in options){\n\t\tif(!options.hasOwnProperty(key));\n\t\telse if(key === \"tag_name\"){\n\t\t\tif(!isTag(element) || !options.tag_name(element.name)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(key === \"tag_type\"){\n\t\t\tif(!options.tag_type(element.type)) return false;\n\t\t} else if(key === \"tag_contains\"){\n\t\t\tif(isTag(element) || !options.tag_contains(element.data)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if(!element.attribs || !options[key](element.attribs[key])){\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\n\nvar Checks = {\n\ttag_name: function(name){\n\t\tif(typeof name === \"function\"){\n\t\t\treturn function(elem){ return isTag(elem) && name(elem.name); };\n\t\t} else if(name === \"*\"){\n\t\t\treturn isTag;\n\t\t} else {\n\t\t\treturn function(elem){ return isTag(elem) && elem.name === name; };\n\t\t}\n\t},\n\ttag_type: function(type){\n\t\tif(typeof type === \"function\"){\n\t\t\treturn function(elem){ return type(elem.type); };\n\t\t} else {\n\t\t\treturn function(elem){ return elem.type === type; };\n\t\t}\n\t},\n\ttag_contains: function(data){\n\t\tif(typeof data === \"function\"){\n\t\t\treturn function(elem){ return !isTag(elem) && data(elem.data); };\n\t\t} else {\n\t\t\treturn function(elem){ return !isTag(elem) && elem.data === data; };\n\t\t}\n\t}\n};\n\nfunction getAttribCheck(attrib, value){\n\tif(typeof value === \"function\"){\n\t\treturn function(elem){ return elem.attribs && value(elem.attribs[attrib]); };\n\t} else {\n\t\treturn function(elem){ return elem.attribs && elem.attribs[attrib] === value; };\n\t}\n}\n\nfunction combineFuncs(a, b){\n\treturn function(elem){\n\t\treturn a(elem) || b(elem);\n\t};\n}\n\nexports.getElements = function(options, element, recurse, limit){\n\tvar funcs = Object.keys(options).map(function(key){\n\t\tvar value = options[key];\n\t\treturn key in Checks ? Checks[key](value) : getAttribCheck(key, value);\n\t});\n\n\treturn funcs.length === 0 ? [] : this.filter(\n\t\tfuncs.reduce(combineFuncs),\n\t\telement, recurse, limit\n\t);\n};\n\nexports.getElementById = function(id, element, recurse){\n\tif(!Array.isArray(element)) element = [element];\n\treturn this.findOne(getAttribCheck(\"id\", id), element, recurse !== false);\n};\n\nexports.getElementsByTagName = function(name, element, recurse, limit){\n\treturn this.filter(Checks.tag_name(name), element, recurse, limit);\n};\n\nexports.getElementsByTagType = function(type, element, recurse, limit){\n\treturn this.filter(Checks.tag_type(type), element, recurse, limit);\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/legacy.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/manipulation.js":
/*!***************************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/manipulation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.removeElement = function(elem){\n\tif(elem.prev) elem.prev.next = elem.next;\n\tif(elem.next) elem.next.prev = elem.prev;\n\n\tif(elem.parent){\n\t\tvar childs = elem.parent.children;\n\t\tchilds.splice(childs.lastIndexOf(elem), 1);\n\t}\n};\n\nexports.replaceElement = function(elem, replacement){\n\tvar prev = replacement.prev = elem.prev;\n\tif(prev){\n\t\tprev.next = replacement;\n\t}\n\n\tvar next = replacement.next = elem.next;\n\tif(next){\n\t\tnext.prev = replacement;\n\t}\n\n\tvar parent = replacement.parent = elem.parent;\n\tif(parent){\n\t\tvar childs = parent.children;\n\t\tchilds[childs.lastIndexOf(elem)] = replacement;\n\t}\n};\n\nexports.appendChild = function(elem, child){\n\tchild.parent = elem;\n\n\tif(elem.children.push(child) !== 1){\n\t\tvar sibling = elem.children[elem.children.length - 2];\n\t\tsibling.next = child;\n\t\tchild.prev = sibling;\n\t\tchild.next = null;\n\t}\n};\n\nexports.append = function(elem, next){\n\tvar parent = elem.parent,\n\t\tcurrNext = elem.next;\n\n\tnext.next = currNext;\n\tnext.prev = elem;\n\telem.next = next;\n\tnext.parent = parent;\n\n\tif(currNext){\n\t\tcurrNext.prev = next;\n\t\tif(parent){\n\t\t\tvar childs = parent.children;\n\t\t\tchilds.splice(childs.lastIndexOf(currNext), 0, next);\n\t\t}\n\t} else if(parent){\n\t\tparent.children.push(next);\n\t}\n};\n\nexports.prepend = function(elem, prev){\n\tvar parent = elem.parent;\n\tif(parent){\n\t\tvar childs = parent.children;\n\t\tchilds.splice(childs.lastIndexOf(elem), 0, prev);\n\t}\n\n\tif(elem.prev){\n\t\telem.prev.next = prev;\n\t}\n\t\n\tprev.parent = parent;\n\tprev.prev = elem.prev;\n\tprev.next = elem;\n\telem.prev = prev;\n};\n\n\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/manipulation.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/querying.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/querying.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var isTag = (__webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/domelementtype/index.js\").isTag);\n\nmodule.exports = {\n\tfilter: filter,\n\tfind: find,\n\tfindOneChild: findOneChild,\n\tfindOne: findOne,\n\texistsOne: existsOne,\n\tfindAll: findAll\n};\n\nfunction filter(test, element, recurse, limit){\n\tif(!Array.isArray(element)) element = [element];\n\n\tif(typeof limit !== \"number\" || !isFinite(limit)){\n\t\tlimit = Infinity;\n\t}\n\treturn find(test, element, recurse !== false, limit);\n}\n\nfunction find(test, elems, recurse, limit){\n\tvar result = [], childs;\n\n\tfor(var i = 0, j = elems.length; i < j; i++){\n\t\tif(test(elems[i])){\n\t\t\tresult.push(elems[i]);\n\t\t\tif(--limit <= 0) break;\n\t\t}\n\n\t\tchilds = elems[i].children;\n\t\tif(recurse && childs && childs.length > 0){\n\t\t\tchilds = find(test, childs, recurse, limit);\n\t\t\tresult = result.concat(childs);\n\t\t\tlimit -= childs.length;\n\t\t\tif(limit <= 0) break;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction findOneChild(test, elems){\n\tfor(var i = 0, l = elems.length; i < l; i++){\n\t\tif(test(elems[i])) return elems[i];\n\t}\n\n\treturn null;\n}\n\nfunction findOne(test, elems){\n\tvar elem = null;\n\n\tfor(var i = 0, l = elems.length; i < l && !elem; i++){\n\t\tif(!isTag(elems[i])){\n\t\t\tcontinue;\n\t\t} else if(test(elems[i])){\n\t\t\telem = elems[i];\n\t\t} else if(elems[i].children.length > 0){\n\t\t\telem = findOne(test, elems[i].children);\n\t\t}\n\t}\n\n\treturn elem;\n}\n\nfunction existsOne(test, elems){\n\tfor(var i = 0, l = elems.length; i < l; i++){\n\t\tif(\n\t\t\tisTag(elems[i]) && (\n\t\t\t\ttest(elems[i]) || (\n\t\t\t\t\telems[i].children.length > 0 &&\n\t\t\t\t\texistsOne(test, elems[i].children)\n\t\t\t\t)\n\t\t\t)\n\t\t){\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nfunction findAll(test, rootElems){\n\tvar result = [];\n\tvar stack = rootElems.slice();\n\twhile(stack.length){\n\t\tvar elem = stack.shift();\n\t\tif(!isTag(elem)) continue;\n\t\tif (elem.children && elem.children.length > 0) {\n\t\t\tstack.unshift.apply(stack, elem.children);\n\t\t}\n\t\tif(test(elem)) result.push(elem);\n\t}\n\treturn result;\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/querying.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/stringify.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/stringify.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var ElementType = __webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/domelementtype/index.js\"),\n    getOuterHTML = __webpack_require__(/*! dom-serializer */ \"../scratch-vm/node_modules/dom-serializer/index.js\"),\n    isTag = ElementType.isTag;\n\nmodule.exports = {\n\tgetInnerHTML: getInnerHTML,\n\tgetOuterHTML: getOuterHTML,\n\tgetText: getText\n};\n\nfunction getInnerHTML(elem, opts){\n\treturn elem.children ? elem.children.map(function(elem){\n\t\treturn getOuterHTML(elem, opts);\n\t}).join(\"\") : \"\";\n}\n\nfunction getText(elem){\n\tif(Array.isArray(elem)) return elem.map(getText).join(\"\");\n\tif(isTag(elem)) return elem.name === \"br\" ? \"\\n\" : getText(elem.children);\n\tif(elem.type === ElementType.CDATA) return getText(elem.children);\n\tif(elem.type === ElementType.Text) return elem.data;\n\treturn \"\";\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/stringify.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/domutils/lib/traversal.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/domutils/lib/traversal.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var getChildren = exports.getChildren = function(elem){\n\treturn elem.children;\n};\n\nvar getParent = exports.getParent = function(elem){\n\treturn elem.parent;\n};\n\nexports.getSiblings = function(elem){\n\tvar parent = getParent(elem);\n\treturn parent ? getChildren(parent) : [elem];\n};\n\nexports.getAttributeValue = function(elem, name){\n\treturn elem.attribs && elem.attribs[name];\n};\n\nexports.hasAttrib = function(elem, name){\n\treturn !!elem.attribs && hasOwnProperty.call(elem.attribs, name);\n};\n\nexports.getName = function(elem){\n\treturn elem.name;\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/domutils/lib/traversal.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/entities/lib/decode_codepoint.js":
/*!*******************************************************************!*\
  !*** ../scratch-vm/node_modules/entities/lib/decode_codepoint.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var decodeMap = __webpack_require__(/*! ../maps/decode.json */ \"../scratch-vm/node_modules/entities/maps/decode.json\");\n\nmodule.exports = decodeCodePoint;\n\n// modified version of https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119\nfunction decodeCodePoint(codePoint) {\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return \"\\uFFFD\";\n    }\n\n    if (codePoint in decodeMap) {\n        codePoint = decodeMap[codePoint];\n    }\n\n    var output = \"\";\n\n    if (codePoint > 0xffff) {\n        codePoint -= 0x10000;\n        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n        codePoint = 0xdc00 | (codePoint & 0x3ff);\n    }\n\n    output += String.fromCharCode(codePoint);\n    return output;\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/entities/lib/decode_codepoint.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/entities/maps/decode.json":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/entities/maps/decode.json ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"0\":65533,\"128\":8364,\"130\":8218,\"131\":402,\"132\":8222,\"133\":8230,\"134\":8224,\"135\":8225,\"136\":710,\"137\":8240,\"138\":352,\"139\":8249,\"140\":338,\"142\":381,\"145\":8216,\"146\":8217,\"147\":8220,\"148\":8221,\"149\":8226,\"150\":8211,\"151\":8212,\"152\":732,\"153\":8482,\"154\":353,\"155\":8250,\"156\":339,\"158\":382,\"159\":376}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/entities/maps/decode.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/entities/maps/entities.json":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/entities/maps/entities.json ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Abreve\":\"Ă\",\"abreve\":\"ă\",\"ac\":\"∾\",\"acd\":\"∿\",\"acE\":\"∾̳\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"Acy\":\"А\",\"acy\":\"а\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"af\":\"⁡\",\"Afr\":\"𝔄\",\"afr\":\"𝔞\",\"Agrave\":\"À\",\"agrave\":\"à\",\"alefsym\":\"ℵ\",\"aleph\":\"ℵ\",\"Alpha\":\"Α\",\"alpha\":\"α\",\"Amacr\":\"Ā\",\"amacr\":\"ā\",\"amalg\":\"⨿\",\"amp\":\"&\",\"AMP\":\"&\",\"andand\":\"⩕\",\"And\":\"⩓\",\"and\":\"∧\",\"andd\":\"⩜\",\"andslope\":\"⩘\",\"andv\":\"⩚\",\"ang\":\"∠\",\"ange\":\"⦤\",\"angle\":\"∠\",\"angmsdaa\":\"⦨\",\"angmsdab\":\"⦩\",\"angmsdac\":\"⦪\",\"angmsdad\":\"⦫\",\"angmsdae\":\"⦬\",\"angmsdaf\":\"⦭\",\"angmsdag\":\"⦮\",\"angmsdah\":\"⦯\",\"angmsd\":\"∡\",\"angrt\":\"∟\",\"angrtvb\":\"⊾\",\"angrtvbd\":\"⦝\",\"angsph\":\"∢\",\"angst\":\"Å\",\"angzarr\":\"⍼\",\"Aogon\":\"Ą\",\"aogon\":\"ą\",\"Aopf\":\"𝔸\",\"aopf\":\"𝕒\",\"apacir\":\"⩯\",\"ap\":\"≈\",\"apE\":\"⩰\",\"ape\":\"≊\",\"apid\":\"≋\",\"apos\":\"\\'\",\"ApplyFunction\":\"⁡\",\"approx\":\"≈\",\"approxeq\":\"≊\",\"Aring\":\"Å\",\"aring\":\"å\",\"Ascr\":\"𝒜\",\"ascr\":\"𝒶\",\"Assign\":\"≔\",\"ast\":\"*\",\"asymp\":\"≈\",\"asympeq\":\"≍\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"awconint\":\"∳\",\"awint\":\"⨑\",\"backcong\":\"≌\",\"backepsilon\":\"϶\",\"backprime\":\"‵\",\"backsim\":\"∽\",\"backsimeq\":\"⋍\",\"Backslash\":\"∖\",\"Barv\":\"⫧\",\"barvee\":\"⊽\",\"barwed\":\"⌅\",\"Barwed\":\"⌆\",\"barwedge\":\"⌅\",\"bbrk\":\"⎵\",\"bbrktbrk\":\"⎶\",\"bcong\":\"≌\",\"Bcy\":\"Б\",\"bcy\":\"б\",\"bdquo\":\"„\",\"becaus\":\"∵\",\"because\":\"∵\",\"Because\":\"∵\",\"bemptyv\":\"⦰\",\"bepsi\":\"϶\",\"bernou\":\"ℬ\",\"Bernoullis\":\"ℬ\",\"Beta\":\"Β\",\"beta\":\"β\",\"beth\":\"ℶ\",\"between\":\"≬\",\"Bfr\":\"𝔅\",\"bfr\":\"𝔟\",\"bigcap\":\"⋂\",\"bigcirc\":\"◯\",\"bigcup\":\"⋃\",\"bigodot\":\"⨀\",\"bigoplus\":\"⨁\",\"bigotimes\":\"⨂\",\"bigsqcup\":\"⨆\",\"bigstar\":\"★\",\"bigtriangledown\":\"▽\",\"bigtriangleup\":\"△\",\"biguplus\":\"⨄\",\"bigvee\":\"⋁\",\"bigwedge\":\"⋀\",\"bkarow\":\"⤍\",\"blacklozenge\":\"⧫\",\"blacksquare\":\"▪\",\"blacktriangle\":\"▴\",\"blacktriangledown\":\"▾\",\"blacktriangleleft\":\"◂\",\"blacktriangleright\":\"▸\",\"blank\":\"␣\",\"blk12\":\"▒\",\"blk14\":\"░\",\"blk34\":\"▓\",\"block\":\"█\",\"bne\":\"=⃥\",\"bnequiv\":\"≡⃥\",\"bNot\":\"⫭\",\"bnot\":\"⌐\",\"Bopf\":\"𝔹\",\"bopf\":\"𝕓\",\"bot\":\"⊥\",\"bottom\":\"⊥\",\"bowtie\":\"⋈\",\"boxbox\":\"⧉\",\"boxdl\":\"┐\",\"boxdL\":\"╕\",\"boxDl\":\"╖\",\"boxDL\":\"╗\",\"boxdr\":\"┌\",\"boxdR\":\"╒\",\"boxDr\":\"╓\",\"boxDR\":\"╔\",\"boxh\":\"─\",\"boxH\":\"═\",\"boxhd\":\"┬\",\"boxHd\":\"╤\",\"boxhD\":\"╥\",\"boxHD\":\"╦\",\"boxhu\":\"┴\",\"boxHu\":\"╧\",\"boxhU\":\"╨\",\"boxHU\":\"╩\",\"boxminus\":\"⊟\",\"boxplus\":\"⊞\",\"boxtimes\":\"⊠\",\"boxul\":\"┘\",\"boxuL\":\"╛\",\"boxUl\":\"╜\",\"boxUL\":\"╝\",\"boxur\":\"└\",\"boxuR\":\"╘\",\"boxUr\":\"╙\",\"boxUR\":\"╚\",\"boxv\":\"│\",\"boxV\":\"║\",\"boxvh\":\"┼\",\"boxvH\":\"╪\",\"boxVh\":\"╫\",\"boxVH\":\"╬\",\"boxvl\":\"┤\",\"boxvL\":\"╡\",\"boxVl\":\"╢\",\"boxVL\":\"╣\",\"boxvr\":\"├\",\"boxvR\":\"╞\",\"boxVr\":\"╟\",\"boxVR\":\"╠\",\"bprime\":\"‵\",\"breve\":\"˘\",\"Breve\":\"˘\",\"brvbar\":\"¦\",\"bscr\":\"𝒷\",\"Bscr\":\"ℬ\",\"bsemi\":\"⁏\",\"bsim\":\"∽\",\"bsime\":\"⋍\",\"bsolb\":\"⧅\",\"bsol\":\"\\\\\\\\\",\"bsolhsub\":\"⟈\",\"bull\":\"•\",\"bullet\":\"•\",\"bump\":\"≎\",\"bumpE\":\"⪮\",\"bumpe\":\"≏\",\"Bumpeq\":\"≎\",\"bumpeq\":\"≏\",\"Cacute\":\"Ć\",\"cacute\":\"ć\",\"capand\":\"⩄\",\"capbrcup\":\"⩉\",\"capcap\":\"⩋\",\"cap\":\"∩\",\"Cap\":\"⋒\",\"capcup\":\"⩇\",\"capdot\":\"⩀\",\"CapitalDifferentialD\":\"ⅅ\",\"caps\":\"∩︀\",\"caret\":\"⁁\",\"caron\":\"ˇ\",\"Cayleys\":\"ℭ\",\"ccaps\":\"⩍\",\"Ccaron\":\"Č\",\"ccaron\":\"č\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"Ccirc\":\"Ĉ\",\"ccirc\":\"ĉ\",\"Cconint\":\"∰\",\"ccups\":\"⩌\",\"ccupssm\":\"⩐\",\"Cdot\":\"Ċ\",\"cdot\":\"ċ\",\"cedil\":\"¸\",\"Cedilla\":\"¸\",\"cemptyv\":\"⦲\",\"cent\":\"¢\",\"centerdot\":\"·\",\"CenterDot\":\"·\",\"cfr\":\"𝔠\",\"Cfr\":\"ℭ\",\"CHcy\":\"Ч\",\"chcy\":\"ч\",\"check\":\"✓\",\"checkmark\":\"✓\",\"Chi\":\"Χ\",\"chi\":\"χ\",\"circ\":\"ˆ\",\"circeq\":\"≗\",\"circlearrowleft\":\"↺\",\"circlearrowright\":\"↻\",\"circledast\":\"⊛\",\"circledcirc\":\"⊚\",\"circleddash\":\"⊝\",\"CircleDot\":\"⊙\",\"circledR\":\"®\",\"circledS\":\"Ⓢ\",\"CircleMinus\":\"⊖\",\"CirclePlus\":\"⊕\",\"CircleTimes\":\"⊗\",\"cir\":\"○\",\"cirE\":\"⧃\",\"cire\":\"≗\",\"cirfnint\":\"⨐\",\"cirmid\":\"⫯\",\"cirscir\":\"⧂\",\"ClockwiseContourIntegral\":\"∲\",\"CloseCurlyDoubleQuote\":\"”\",\"CloseCurlyQuote\":\"’\",\"clubs\":\"♣\",\"clubsuit\":\"♣\",\"colon\":\":\",\"Colon\":\"∷\",\"Colone\":\"⩴\",\"colone\":\"≔\",\"coloneq\":\"≔\",\"comma\":\",\",\"commat\":\"@\",\"comp\":\"∁\",\"compfn\":\"∘\",\"complement\":\"∁\",\"complexes\":\"ℂ\",\"cong\":\"≅\",\"congdot\":\"⩭\",\"Congruent\":\"≡\",\"conint\":\"∮\",\"Conint\":\"∯\",\"ContourIntegral\":\"∮\",\"copf\":\"𝕔\",\"Copf\":\"ℂ\",\"coprod\":\"∐\",\"Coproduct\":\"∐\",\"copy\":\"©\",\"COPY\":\"©\",\"copysr\":\"℗\",\"CounterClockwiseContourIntegral\":\"∳\",\"crarr\":\"↵\",\"cross\":\"✗\",\"Cross\":\"⨯\",\"Cscr\":\"𝒞\",\"cscr\":\"𝒸\",\"csub\":\"⫏\",\"csube\":\"⫑\",\"csup\":\"⫐\",\"csupe\":\"⫒\",\"ctdot\":\"⋯\",\"cudarrl\":\"⤸\",\"cudarrr\":\"⤵\",\"cuepr\":\"⋞\",\"cuesc\":\"⋟\",\"cularr\":\"↶\",\"cularrp\":\"⤽\",\"cupbrcap\":\"⩈\",\"cupcap\":\"⩆\",\"CupCap\":\"≍\",\"cup\":\"∪\",\"Cup\":\"⋓\",\"cupcup\":\"⩊\",\"cupdot\":\"⊍\",\"cupor\":\"⩅\",\"cups\":\"∪︀\",\"curarr\":\"↷\",\"curarrm\":\"⤼\",\"curlyeqprec\":\"⋞\",\"curlyeqsucc\":\"⋟\",\"curlyvee\":\"⋎\",\"curlywedge\":\"⋏\",\"curren\":\"¤\",\"curvearrowleft\":\"↶\",\"curvearrowright\":\"↷\",\"cuvee\":\"⋎\",\"cuwed\":\"⋏\",\"cwconint\":\"∲\",\"cwint\":\"∱\",\"cylcty\":\"⌭\",\"dagger\":\"†\",\"Dagger\":\"‡\",\"daleth\":\"ℸ\",\"darr\":\"↓\",\"Darr\":\"↡\",\"dArr\":\"⇓\",\"dash\":\"‐\",\"Dashv\":\"⫤\",\"dashv\":\"⊣\",\"dbkarow\":\"⤏\",\"dblac\":\"˝\",\"Dcaron\":\"Ď\",\"dcaron\":\"ď\",\"Dcy\":\"Д\",\"dcy\":\"д\",\"ddagger\":\"‡\",\"ddarr\":\"⇊\",\"DD\":\"ⅅ\",\"dd\":\"ⅆ\",\"DDotrahd\":\"⤑\",\"ddotseq\":\"⩷\",\"deg\":\"°\",\"Del\":\"∇\",\"Delta\":\"Δ\",\"delta\":\"δ\",\"demptyv\":\"⦱\",\"dfisht\":\"⥿\",\"Dfr\":\"𝔇\",\"dfr\":\"𝔡\",\"dHar\":\"⥥\",\"dharl\":\"⇃\",\"dharr\":\"⇂\",\"DiacriticalAcute\":\"´\",\"DiacriticalDot\":\"˙\",\"DiacriticalDoubleAcute\":\"˝\",\"DiacriticalGrave\":\"`\",\"DiacriticalTilde\":\"˜\",\"diam\":\"⋄\",\"diamond\":\"⋄\",\"Diamond\":\"⋄\",\"diamondsuit\":\"♦\",\"diams\":\"♦\",\"die\":\"¨\",\"DifferentialD\":\"ⅆ\",\"digamma\":\"ϝ\",\"disin\":\"⋲\",\"div\":\"÷\",\"divide\":\"÷\",\"divideontimes\":\"⋇\",\"divonx\":\"⋇\",\"DJcy\":\"Ђ\",\"djcy\":\"ђ\",\"dlcorn\":\"⌞\",\"dlcrop\":\"⌍\",\"dollar\":\"$\",\"Dopf\":\"𝔻\",\"dopf\":\"𝕕\",\"Dot\":\"¨\",\"dot\":\"˙\",\"DotDot\":\"⃜\",\"doteq\":\"≐\",\"doteqdot\":\"≑\",\"DotEqual\":\"≐\",\"dotminus\":\"∸\",\"dotplus\":\"∔\",\"dotsquare\":\"⊡\",\"doublebarwedge\":\"⌆\",\"DoubleContourIntegral\":\"∯\",\"DoubleDot\":\"¨\",\"DoubleDownArrow\":\"⇓\",\"DoubleLeftArrow\":\"⇐\",\"DoubleLeftRightArrow\":\"⇔\",\"DoubleLeftTee\":\"⫤\",\"DoubleLongLeftArrow\":\"⟸\",\"DoubleLongLeftRightArrow\":\"⟺\",\"DoubleLongRightArrow\":\"⟹\",\"DoubleRightArrow\":\"⇒\",\"DoubleRightTee\":\"⊨\",\"DoubleUpArrow\":\"⇑\",\"DoubleUpDownArrow\":\"⇕\",\"DoubleVerticalBar\":\"∥\",\"DownArrowBar\":\"⤓\",\"downarrow\":\"↓\",\"DownArrow\":\"↓\",\"Downarrow\":\"⇓\",\"DownArrowUpArrow\":\"⇵\",\"DownBreve\":\"̑\",\"downdownarrows\":\"⇊\",\"downharpoonleft\":\"⇃\",\"downharpoonright\":\"⇂\",\"DownLeftRightVector\":\"⥐\",\"DownLeftTeeVector\":\"⥞\",\"DownLeftVectorBar\":\"⥖\",\"DownLeftVector\":\"↽\",\"DownRightTeeVector\":\"⥟\",\"DownRightVectorBar\":\"⥗\",\"DownRightVector\":\"⇁\",\"DownTeeArrow\":\"↧\",\"DownTee\":\"⊤\",\"drbkarow\":\"⤐\",\"drcorn\":\"⌟\",\"drcrop\":\"⌌\",\"Dscr\":\"𝒟\",\"dscr\":\"𝒹\",\"DScy\":\"Ѕ\",\"dscy\":\"ѕ\",\"dsol\":\"⧶\",\"Dstrok\":\"Đ\",\"dstrok\":\"đ\",\"dtdot\":\"⋱\",\"dtri\":\"▿\",\"dtrif\":\"▾\",\"duarr\":\"⇵\",\"duhar\":\"⥯\",\"dwangle\":\"⦦\",\"DZcy\":\"Џ\",\"dzcy\":\"џ\",\"dzigrarr\":\"⟿\",\"Eacute\":\"É\",\"eacute\":\"é\",\"easter\":\"⩮\",\"Ecaron\":\"Ě\",\"ecaron\":\"ě\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"ecir\":\"≖\",\"ecolon\":\"≕\",\"Ecy\":\"Э\",\"ecy\":\"э\",\"eDDot\":\"⩷\",\"Edot\":\"Ė\",\"edot\":\"ė\",\"eDot\":\"≑\",\"ee\":\"ⅇ\",\"efDot\":\"≒\",\"Efr\":\"𝔈\",\"efr\":\"𝔢\",\"eg\":\"⪚\",\"Egrave\":\"È\",\"egrave\":\"è\",\"egs\":\"⪖\",\"egsdot\":\"⪘\",\"el\":\"⪙\",\"Element\":\"∈\",\"elinters\":\"⏧\",\"ell\":\"ℓ\",\"els\":\"⪕\",\"elsdot\":\"⪗\",\"Emacr\":\"Ē\",\"emacr\":\"ē\",\"empty\":\"∅\",\"emptyset\":\"∅\",\"EmptySmallSquare\":\"◻\",\"emptyv\":\"∅\",\"EmptyVerySmallSquare\":\"▫\",\"emsp13\":\" \",\"emsp14\":\" \",\"emsp\":\" \",\"ENG\":\"Ŋ\",\"eng\":\"ŋ\",\"ensp\":\" \",\"Eogon\":\"Ę\",\"eogon\":\"ę\",\"Eopf\":\"𝔼\",\"eopf\":\"𝕖\",\"epar\":\"⋕\",\"eparsl\":\"⧣\",\"eplus\":\"⩱\",\"epsi\":\"ε\",\"Epsilon\":\"Ε\",\"epsilon\":\"ε\",\"epsiv\":\"ϵ\",\"eqcirc\":\"≖\",\"eqcolon\":\"≕\",\"eqsim\":\"≂\",\"eqslantgtr\":\"⪖\",\"eqslantless\":\"⪕\",\"Equal\":\"⩵\",\"equals\":\"=\",\"EqualTilde\":\"≂\",\"equest\":\"≟\",\"Equilibrium\":\"⇌\",\"equiv\":\"≡\",\"equivDD\":\"⩸\",\"eqvparsl\":\"⧥\",\"erarr\":\"⥱\",\"erDot\":\"≓\",\"escr\":\"ℯ\",\"Escr\":\"ℰ\",\"esdot\":\"≐\",\"Esim\":\"⩳\",\"esim\":\"≂\",\"Eta\":\"Η\",\"eta\":\"η\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"euro\":\"€\",\"excl\":\"!\",\"exist\":\"∃\",\"Exists\":\"∃\",\"expectation\":\"ℰ\",\"exponentiale\":\"ⅇ\",\"ExponentialE\":\"ⅇ\",\"fallingdotseq\":\"≒\",\"Fcy\":\"Ф\",\"fcy\":\"ф\",\"female\":\"♀\",\"ffilig\":\"ﬃ\",\"fflig\":\"ﬀ\",\"ffllig\":\"ﬄ\",\"Ffr\":\"𝔉\",\"ffr\":\"𝔣\",\"filig\":\"ﬁ\",\"FilledSmallSquare\":\"◼\",\"FilledVerySmallSquare\":\"▪\",\"fjlig\":\"fj\",\"flat\":\"♭\",\"fllig\":\"ﬂ\",\"fltns\":\"▱\",\"fnof\":\"ƒ\",\"Fopf\":\"𝔽\",\"fopf\":\"𝕗\",\"forall\":\"∀\",\"ForAll\":\"∀\",\"fork\":\"⋔\",\"forkv\":\"⫙\",\"Fouriertrf\":\"ℱ\",\"fpartint\":\"⨍\",\"frac12\":\"½\",\"frac13\":\"⅓\",\"frac14\":\"¼\",\"frac15\":\"⅕\",\"frac16\":\"⅙\",\"frac18\":\"⅛\",\"frac23\":\"⅔\",\"frac25\":\"⅖\",\"frac34\":\"¾\",\"frac35\":\"⅗\",\"frac38\":\"⅜\",\"frac45\":\"⅘\",\"frac56\":\"⅚\",\"frac58\":\"⅝\",\"frac78\":\"⅞\",\"frasl\":\"⁄\",\"frown\":\"⌢\",\"fscr\":\"𝒻\",\"Fscr\":\"ℱ\",\"gacute\":\"ǵ\",\"Gamma\":\"Γ\",\"gamma\":\"γ\",\"Gammad\":\"Ϝ\",\"gammad\":\"ϝ\",\"gap\":\"⪆\",\"Gbreve\":\"Ğ\",\"gbreve\":\"ğ\",\"Gcedil\":\"Ģ\",\"Gcirc\":\"Ĝ\",\"gcirc\":\"ĝ\",\"Gcy\":\"Г\",\"gcy\":\"г\",\"Gdot\":\"Ġ\",\"gdot\":\"ġ\",\"ge\":\"≥\",\"gE\":\"≧\",\"gEl\":\"⪌\",\"gel\":\"⋛\",\"geq\":\"≥\",\"geqq\":\"≧\",\"geqslant\":\"⩾\",\"gescc\":\"⪩\",\"ges\":\"⩾\",\"gesdot\":\"⪀\",\"gesdoto\":\"⪂\",\"gesdotol\":\"⪄\",\"gesl\":\"⋛︀\",\"gesles\":\"⪔\",\"Gfr\":\"𝔊\",\"gfr\":\"𝔤\",\"gg\":\"≫\",\"Gg\":\"⋙\",\"ggg\":\"⋙\",\"gimel\":\"ℷ\",\"GJcy\":\"Ѓ\",\"gjcy\":\"ѓ\",\"gla\":\"⪥\",\"gl\":\"≷\",\"glE\":\"⪒\",\"glj\":\"⪤\",\"gnap\":\"⪊\",\"gnapprox\":\"⪊\",\"gne\":\"⪈\",\"gnE\":\"≩\",\"gneq\":\"⪈\",\"gneqq\":\"≩\",\"gnsim\":\"⋧\",\"Gopf\":\"𝔾\",\"gopf\":\"𝕘\",\"grave\":\"`\",\"GreaterEqual\":\"≥\",\"GreaterEqualLess\":\"⋛\",\"GreaterFullEqual\":\"≧\",\"GreaterGreater\":\"⪢\",\"GreaterLess\":\"≷\",\"GreaterSlantEqual\":\"⩾\",\"GreaterTilde\":\"≳\",\"Gscr\":\"𝒢\",\"gscr\":\"ℊ\",\"gsim\":\"≳\",\"gsime\":\"⪎\",\"gsiml\":\"⪐\",\"gtcc\":\"⪧\",\"gtcir\":\"⩺\",\"gt\":\">\",\"GT\":\">\",\"Gt\":\"≫\",\"gtdot\":\"⋗\",\"gtlPar\":\"⦕\",\"gtquest\":\"⩼\",\"gtrapprox\":\"⪆\",\"gtrarr\":\"⥸\",\"gtrdot\":\"⋗\",\"gtreqless\":\"⋛\",\"gtreqqless\":\"⪌\",\"gtrless\":\"≷\",\"gtrsim\":\"≳\",\"gvertneqq\":\"≩︀\",\"gvnE\":\"≩︀\",\"Hacek\":\"ˇ\",\"hairsp\":\" \",\"half\":\"½\",\"hamilt\":\"ℋ\",\"HARDcy\":\"Ъ\",\"hardcy\":\"ъ\",\"harrcir\":\"⥈\",\"harr\":\"↔\",\"hArr\":\"⇔\",\"harrw\":\"↭\",\"Hat\":\"^\",\"hbar\":\"ℏ\",\"Hcirc\":\"Ĥ\",\"hcirc\":\"ĥ\",\"hearts\":\"♥\",\"heartsuit\":\"♥\",\"hellip\":\"…\",\"hercon\":\"⊹\",\"hfr\":\"𝔥\",\"Hfr\":\"ℌ\",\"HilbertSpace\":\"ℋ\",\"hksearow\":\"⤥\",\"hkswarow\":\"⤦\",\"hoarr\":\"⇿\",\"homtht\":\"∻\",\"hookleftarrow\":\"↩\",\"hookrightarrow\":\"↪\",\"hopf\":\"𝕙\",\"Hopf\":\"ℍ\",\"horbar\":\"―\",\"HorizontalLine\":\"─\",\"hscr\":\"𝒽\",\"Hscr\":\"ℋ\",\"hslash\":\"ℏ\",\"Hstrok\":\"Ħ\",\"hstrok\":\"ħ\",\"HumpDownHump\":\"≎\",\"HumpEqual\":\"≏\",\"hybull\":\"⁃\",\"hyphen\":\"‐\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"ic\":\"⁣\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"Icy\":\"И\",\"icy\":\"и\",\"Idot\":\"İ\",\"IEcy\":\"Е\",\"iecy\":\"е\",\"iexcl\":\"¡\",\"iff\":\"⇔\",\"ifr\":\"𝔦\",\"Ifr\":\"ℑ\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"ii\":\"ⅈ\",\"iiiint\":\"⨌\",\"iiint\":\"∭\",\"iinfin\":\"⧜\",\"iiota\":\"℩\",\"IJlig\":\"Ĳ\",\"ijlig\":\"ĳ\",\"Imacr\":\"Ī\",\"imacr\":\"ī\",\"image\":\"ℑ\",\"ImaginaryI\":\"ⅈ\",\"imagline\":\"ℐ\",\"imagpart\":\"ℑ\",\"imath\":\"ı\",\"Im\":\"ℑ\",\"imof\":\"⊷\",\"imped\":\"Ƶ\",\"Implies\":\"⇒\",\"incare\":\"℅\",\"in\":\"∈\",\"infin\":\"∞\",\"infintie\":\"⧝\",\"inodot\":\"ı\",\"intcal\":\"⊺\",\"int\":\"∫\",\"Int\":\"∬\",\"integers\":\"ℤ\",\"Integral\":\"∫\",\"intercal\":\"⊺\",\"Intersection\":\"⋂\",\"intlarhk\":\"⨗\",\"intprod\":\"⨼\",\"InvisibleComma\":\"⁣\",\"InvisibleTimes\":\"⁢\",\"IOcy\":\"Ё\",\"iocy\":\"ё\",\"Iogon\":\"Į\",\"iogon\":\"į\",\"Iopf\":\"𝕀\",\"iopf\":\"𝕚\",\"Iota\":\"Ι\",\"iota\":\"ι\",\"iprod\":\"⨼\",\"iquest\":\"¿\",\"iscr\":\"𝒾\",\"Iscr\":\"ℐ\",\"isin\":\"∈\",\"isindot\":\"⋵\",\"isinE\":\"⋹\",\"isins\":\"⋴\",\"isinsv\":\"⋳\",\"isinv\":\"∈\",\"it\":\"⁢\",\"Itilde\":\"Ĩ\",\"itilde\":\"ĩ\",\"Iukcy\":\"І\",\"iukcy\":\"і\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"Jcirc\":\"Ĵ\",\"jcirc\":\"ĵ\",\"Jcy\":\"Й\",\"jcy\":\"й\",\"Jfr\":\"𝔍\",\"jfr\":\"𝔧\",\"jmath\":\"ȷ\",\"Jopf\":\"𝕁\",\"jopf\":\"𝕛\",\"Jscr\":\"𝒥\",\"jscr\":\"𝒿\",\"Jsercy\":\"Ј\",\"jsercy\":\"ј\",\"Jukcy\":\"Є\",\"jukcy\":\"є\",\"Kappa\":\"Κ\",\"kappa\":\"κ\",\"kappav\":\"ϰ\",\"Kcedil\":\"Ķ\",\"kcedil\":\"ķ\",\"Kcy\":\"К\",\"kcy\":\"к\",\"Kfr\":\"𝔎\",\"kfr\":\"𝔨\",\"kgreen\":\"ĸ\",\"KHcy\":\"Х\",\"khcy\":\"х\",\"KJcy\":\"Ќ\",\"kjcy\":\"ќ\",\"Kopf\":\"𝕂\",\"kopf\":\"𝕜\",\"Kscr\":\"𝒦\",\"kscr\":\"𝓀\",\"lAarr\":\"⇚\",\"Lacute\":\"Ĺ\",\"lacute\":\"ĺ\",\"laemptyv\":\"⦴\",\"lagran\":\"ℒ\",\"Lambda\":\"Λ\",\"lambda\":\"λ\",\"lang\":\"⟨\",\"Lang\":\"⟪\",\"langd\":\"⦑\",\"langle\":\"⟨\",\"lap\":\"⪅\",\"Laplacetrf\":\"ℒ\",\"laquo\":\"«\",\"larrb\":\"⇤\",\"larrbfs\":\"⤟\",\"larr\":\"←\",\"Larr\":\"↞\",\"lArr\":\"⇐\",\"larrfs\":\"⤝\",\"larrhk\":\"↩\",\"larrlp\":\"↫\",\"larrpl\":\"⤹\",\"larrsim\":\"⥳\",\"larrtl\":\"↢\",\"latail\":\"⤙\",\"lAtail\":\"⤛\",\"lat\":\"⪫\",\"late\":\"⪭\",\"lates\":\"⪭︀\",\"lbarr\":\"⤌\",\"lBarr\":\"⤎\",\"lbbrk\":\"❲\",\"lbrace\":\"{\",\"lbrack\":\"[\",\"lbrke\":\"⦋\",\"lbrksld\":\"⦏\",\"lbrkslu\":\"⦍\",\"Lcaron\":\"Ľ\",\"lcaron\":\"ľ\",\"Lcedil\":\"Ļ\",\"lcedil\":\"ļ\",\"lceil\":\"⌈\",\"lcub\":\"{\",\"Lcy\":\"Л\",\"lcy\":\"л\",\"ldca\":\"⤶\",\"ldquo\":\"“\",\"ldquor\":\"„\",\"ldrdhar\":\"⥧\",\"ldrushar\":\"⥋\",\"ldsh\":\"↲\",\"le\":\"≤\",\"lE\":\"≦\",\"LeftAngleBracket\":\"⟨\",\"LeftArrowBar\":\"⇤\",\"leftarrow\":\"←\",\"LeftArrow\":\"←\",\"Leftarrow\":\"⇐\",\"LeftArrowRightArrow\":\"⇆\",\"leftarrowtail\":\"↢\",\"LeftCeiling\":\"⌈\",\"LeftDoubleBracket\":\"⟦\",\"LeftDownTeeVector\":\"⥡\",\"LeftDownVectorBar\":\"⥙\",\"LeftDownVector\":\"⇃\",\"LeftFloor\":\"⌊\",\"leftharpoondown\":\"↽\",\"leftharpoonup\":\"↼\",\"leftleftarrows\":\"⇇\",\"leftrightarrow\":\"↔\",\"LeftRightArrow\":\"↔\",\"Leftrightarrow\":\"⇔\",\"leftrightarrows\":\"⇆\",\"leftrightharpoons\":\"⇋\",\"leftrightsquigarrow\":\"↭\",\"LeftRightVector\":\"⥎\",\"LeftTeeArrow\":\"↤\",\"LeftTee\":\"⊣\",\"LeftTeeVector\":\"⥚\",\"leftthreetimes\":\"⋋\",\"LeftTriangleBar\":\"⧏\",\"LeftTriangle\":\"⊲\",\"LeftTriangleEqual\":\"⊴\",\"LeftUpDownVector\":\"⥑\",\"LeftUpTeeVector\":\"⥠\",\"LeftUpVectorBar\":\"⥘\",\"LeftUpVector\":\"↿\",\"LeftVectorBar\":\"⥒\",\"LeftVector\":\"↼\",\"lEg\":\"⪋\",\"leg\":\"⋚\",\"leq\":\"≤\",\"leqq\":\"≦\",\"leqslant\":\"⩽\",\"lescc\":\"⪨\",\"les\":\"⩽\",\"lesdot\":\"⩿\",\"lesdoto\":\"⪁\",\"lesdotor\":\"⪃\",\"lesg\":\"⋚︀\",\"lesges\":\"⪓\",\"lessapprox\":\"⪅\",\"lessdot\":\"⋖\",\"lesseqgtr\":\"⋚\",\"lesseqqgtr\":\"⪋\",\"LessEqualGreater\":\"⋚\",\"LessFullEqual\":\"≦\",\"LessGreater\":\"≶\",\"lessgtr\":\"≶\",\"LessLess\":\"⪡\",\"lesssim\":\"≲\",\"LessSlantEqual\":\"⩽\",\"LessTilde\":\"≲\",\"lfisht\":\"⥼\",\"lfloor\":\"⌊\",\"Lfr\":\"𝔏\",\"lfr\":\"𝔩\",\"lg\":\"≶\",\"lgE\":\"⪑\",\"lHar\":\"⥢\",\"lhard\":\"↽\",\"lharu\":\"↼\",\"lharul\":\"⥪\",\"lhblk\":\"▄\",\"LJcy\":\"Љ\",\"ljcy\":\"љ\",\"llarr\":\"⇇\",\"ll\":\"≪\",\"Ll\":\"⋘\",\"llcorner\":\"⌞\",\"Lleftarrow\":\"⇚\",\"llhard\":\"⥫\",\"lltri\":\"◺\",\"Lmidot\":\"Ŀ\",\"lmidot\":\"ŀ\",\"lmoustache\":\"⎰\",\"lmoust\":\"⎰\",\"lnap\":\"⪉\",\"lnapprox\":\"⪉\",\"lne\":\"⪇\",\"lnE\":\"≨\",\"lneq\":\"⪇\",\"lneqq\":\"≨\",\"lnsim\":\"⋦\",\"loang\":\"⟬\",\"loarr\":\"⇽\",\"lobrk\":\"⟦\",\"longleftarrow\":\"⟵\",\"LongLeftArrow\":\"⟵\",\"Longleftarrow\":\"⟸\",\"longleftrightarrow\":\"⟷\",\"LongLeftRightArrow\":\"⟷\",\"Longleftrightarrow\":\"⟺\",\"longmapsto\":\"⟼\",\"longrightarrow\":\"⟶\",\"LongRightArrow\":\"⟶\",\"Longrightarrow\":\"⟹\",\"looparrowleft\":\"↫\",\"looparrowright\":\"↬\",\"lopar\":\"⦅\",\"Lopf\":\"𝕃\",\"lopf\":\"𝕝\",\"loplus\":\"⨭\",\"lotimes\":\"⨴\",\"lowast\":\"∗\",\"lowbar\":\"_\",\"LowerLeftArrow\":\"↙\",\"LowerRightArrow\":\"↘\",\"loz\":\"◊\",\"lozenge\":\"◊\",\"lozf\":\"⧫\",\"lpar\":\"(\",\"lparlt\":\"⦓\",\"lrarr\":\"⇆\",\"lrcorner\":\"⌟\",\"lrhar\":\"⇋\",\"lrhard\":\"⥭\",\"lrm\":\"‎\",\"lrtri\":\"⊿\",\"lsaquo\":\"‹\",\"lscr\":\"𝓁\",\"Lscr\":\"ℒ\",\"lsh\":\"↰\",\"Lsh\":\"↰\",\"lsim\":\"≲\",\"lsime\":\"⪍\",\"lsimg\":\"⪏\",\"lsqb\":\"[\",\"lsquo\":\"‘\",\"lsquor\":\"‚\",\"Lstrok\":\"Ł\",\"lstrok\":\"ł\",\"ltcc\":\"⪦\",\"ltcir\":\"⩹\",\"lt\":\"<\",\"LT\":\"<\",\"Lt\":\"≪\",\"ltdot\":\"⋖\",\"lthree\":\"⋋\",\"ltimes\":\"⋉\",\"ltlarr\":\"⥶\",\"ltquest\":\"⩻\",\"ltri\":\"◃\",\"ltrie\":\"⊴\",\"ltrif\":\"◂\",\"ltrPar\":\"⦖\",\"lurdshar\":\"⥊\",\"luruhar\":\"⥦\",\"lvertneqq\":\"≨︀\",\"lvnE\":\"≨︀\",\"macr\":\"¯\",\"male\":\"♂\",\"malt\":\"✠\",\"maltese\":\"✠\",\"Map\":\"⤅\",\"map\":\"↦\",\"mapsto\":\"↦\",\"mapstodown\":\"↧\",\"mapstoleft\":\"↤\",\"mapstoup\":\"↥\",\"marker\":\"▮\",\"mcomma\":\"⨩\",\"Mcy\":\"М\",\"mcy\":\"м\",\"mdash\":\"—\",\"mDDot\":\"∺\",\"measuredangle\":\"∡\",\"MediumSpace\":\" \",\"Mellintrf\":\"ℳ\",\"Mfr\":\"𝔐\",\"mfr\":\"𝔪\",\"mho\":\"℧\",\"micro\":\"µ\",\"midast\":\"*\",\"midcir\":\"⫰\",\"mid\":\"∣\",\"middot\":\"·\",\"minusb\":\"⊟\",\"minus\":\"−\",\"minusd\":\"∸\",\"minusdu\":\"⨪\",\"MinusPlus\":\"∓\",\"mlcp\":\"⫛\",\"mldr\":\"…\",\"mnplus\":\"∓\",\"models\":\"⊧\",\"Mopf\":\"𝕄\",\"mopf\":\"𝕞\",\"mp\":\"∓\",\"mscr\":\"𝓂\",\"Mscr\":\"ℳ\",\"mstpos\":\"∾\",\"Mu\":\"Μ\",\"mu\":\"μ\",\"multimap\":\"⊸\",\"mumap\":\"⊸\",\"nabla\":\"∇\",\"Nacute\":\"Ń\",\"nacute\":\"ń\",\"nang\":\"∠⃒\",\"nap\":\"≉\",\"napE\":\"⩰̸\",\"napid\":\"≋̸\",\"napos\":\"ŉ\",\"napprox\":\"≉\",\"natural\":\"♮\",\"naturals\":\"ℕ\",\"natur\":\"♮\",\"nbsp\":\" \",\"nbump\":\"≎̸\",\"nbumpe\":\"≏̸\",\"ncap\":\"⩃\",\"Ncaron\":\"Ň\",\"ncaron\":\"ň\",\"Ncedil\":\"Ņ\",\"ncedil\":\"ņ\",\"ncong\":\"≇\",\"ncongdot\":\"⩭̸\",\"ncup\":\"⩂\",\"Ncy\":\"Н\",\"ncy\":\"н\",\"ndash\":\"–\",\"nearhk\":\"⤤\",\"nearr\":\"↗\",\"neArr\":\"⇗\",\"nearrow\":\"↗\",\"ne\":\"≠\",\"nedot\":\"≐̸\",\"NegativeMediumSpace\":\"​\",\"NegativeThickSpace\":\"​\",\"NegativeThinSpace\":\"​\",\"NegativeVeryThinSpace\":\"​\",\"nequiv\":\"≢\",\"nesear\":\"⤨\",\"nesim\":\"≂̸\",\"NestedGreaterGreater\":\"≫\",\"NestedLessLess\":\"≪\",\"NewLine\":\"\\\\n\",\"nexist\":\"∄\",\"nexists\":\"∄\",\"Nfr\":\"𝔑\",\"nfr\":\"𝔫\",\"ngE\":\"≧̸\",\"nge\":\"≱\",\"ngeq\":\"≱\",\"ngeqq\":\"≧̸\",\"ngeqslant\":\"⩾̸\",\"nges\":\"⩾̸\",\"nGg\":\"⋙̸\",\"ngsim\":\"≵\",\"nGt\":\"≫⃒\",\"ngt\":\"≯\",\"ngtr\":\"≯\",\"nGtv\":\"≫̸\",\"nharr\":\"↮\",\"nhArr\":\"⇎\",\"nhpar\":\"⫲\",\"ni\":\"∋\",\"nis\":\"⋼\",\"nisd\":\"⋺\",\"niv\":\"∋\",\"NJcy\":\"Њ\",\"njcy\":\"њ\",\"nlarr\":\"↚\",\"nlArr\":\"⇍\",\"nldr\":\"‥\",\"nlE\":\"≦̸\",\"nle\":\"≰\",\"nleftarrow\":\"↚\",\"nLeftarrow\":\"⇍\",\"nleftrightarrow\":\"↮\",\"nLeftrightarrow\":\"⇎\",\"nleq\":\"≰\",\"nleqq\":\"≦̸\",\"nleqslant\":\"⩽̸\",\"nles\":\"⩽̸\",\"nless\":\"≮\",\"nLl\":\"⋘̸\",\"nlsim\":\"≴\",\"nLt\":\"≪⃒\",\"nlt\":\"≮\",\"nltri\":\"⋪\",\"nltrie\":\"⋬\",\"nLtv\":\"≪̸\",\"nmid\":\"∤\",\"NoBreak\":\"⁠\",\"NonBreakingSpace\":\" \",\"nopf\":\"𝕟\",\"Nopf\":\"ℕ\",\"Not\":\"⫬\",\"not\":\"¬\",\"NotCongruent\":\"≢\",\"NotCupCap\":\"≭\",\"NotDoubleVerticalBar\":\"∦\",\"NotElement\":\"∉\",\"NotEqual\":\"≠\",\"NotEqualTilde\":\"≂̸\",\"NotExists\":\"∄\",\"NotGreater\":\"≯\",\"NotGreaterEqual\":\"≱\",\"NotGreaterFullEqual\":\"≧̸\",\"NotGreaterGreater\":\"≫̸\",\"NotGreaterLess\":\"≹\",\"NotGreaterSlantEqual\":\"⩾̸\",\"NotGreaterTilde\":\"≵\",\"NotHumpDownHump\":\"≎̸\",\"NotHumpEqual\":\"≏̸\",\"notin\":\"∉\",\"notindot\":\"⋵̸\",\"notinE\":\"⋹̸\",\"notinva\":\"∉\",\"notinvb\":\"⋷\",\"notinvc\":\"⋶\",\"NotLeftTriangleBar\":\"⧏̸\",\"NotLeftTriangle\":\"⋪\",\"NotLeftTriangleEqual\":\"⋬\",\"NotLess\":\"≮\",\"NotLessEqual\":\"≰\",\"NotLessGreater\":\"≸\",\"NotLessLess\":\"≪̸\",\"NotLessSlantEqual\":\"⩽̸\",\"NotLessTilde\":\"≴\",\"NotNestedGreaterGreater\":\"⪢̸\",\"NotNestedLessLess\":\"⪡̸\",\"notni\":\"∌\",\"notniva\":\"∌\",\"notnivb\":\"⋾\",\"notnivc\":\"⋽\",\"NotPrecedes\":\"⊀\",\"NotPrecedesEqual\":\"⪯̸\",\"NotPrecedesSlantEqual\":\"⋠\",\"NotReverseElement\":\"∌\",\"NotRightTriangleBar\":\"⧐̸\",\"NotRightTriangle\":\"⋫\",\"NotRightTriangleEqual\":\"⋭\",\"NotSquareSubset\":\"⊏̸\",\"NotSquareSubsetEqual\":\"⋢\",\"NotSquareSuperset\":\"⊐̸\",\"NotSquareSupersetEqual\":\"⋣\",\"NotSubset\":\"⊂⃒\",\"NotSubsetEqual\":\"⊈\",\"NotSucceeds\":\"⊁\",\"NotSucceedsEqual\":\"⪰̸\",\"NotSucceedsSlantEqual\":\"⋡\",\"NotSucceedsTilde\":\"≿̸\",\"NotSuperset\":\"⊃⃒\",\"NotSupersetEqual\":\"⊉\",\"NotTilde\":\"≁\",\"NotTildeEqual\":\"≄\",\"NotTildeFullEqual\":\"≇\",\"NotTildeTilde\":\"≉\",\"NotVerticalBar\":\"∤\",\"nparallel\":\"∦\",\"npar\":\"∦\",\"nparsl\":\"⫽⃥\",\"npart\":\"∂̸\",\"npolint\":\"⨔\",\"npr\":\"⊀\",\"nprcue\":\"⋠\",\"nprec\":\"⊀\",\"npreceq\":\"⪯̸\",\"npre\":\"⪯̸\",\"nrarrc\":\"⤳̸\",\"nrarr\":\"↛\",\"nrArr\":\"⇏\",\"nrarrw\":\"↝̸\",\"nrightarrow\":\"↛\",\"nRightarrow\":\"⇏\",\"nrtri\":\"⋫\",\"nrtrie\":\"⋭\",\"nsc\":\"⊁\",\"nsccue\":\"⋡\",\"nsce\":\"⪰̸\",\"Nscr\":\"𝒩\",\"nscr\":\"𝓃\",\"nshortmid\":\"∤\",\"nshortparallel\":\"∦\",\"nsim\":\"≁\",\"nsime\":\"≄\",\"nsimeq\":\"≄\",\"nsmid\":\"∤\",\"nspar\":\"∦\",\"nsqsube\":\"⋢\",\"nsqsupe\":\"⋣\",\"nsub\":\"⊄\",\"nsubE\":\"⫅̸\",\"nsube\":\"⊈\",\"nsubset\":\"⊂⃒\",\"nsubseteq\":\"⊈\",\"nsubseteqq\":\"⫅̸\",\"nsucc\":\"⊁\",\"nsucceq\":\"⪰̸\",\"nsup\":\"⊅\",\"nsupE\":\"⫆̸\",\"nsupe\":\"⊉\",\"nsupset\":\"⊃⃒\",\"nsupseteq\":\"⊉\",\"nsupseteqq\":\"⫆̸\",\"ntgl\":\"≹\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"ntlg\":\"≸\",\"ntriangleleft\":\"⋪\",\"ntrianglelefteq\":\"⋬\",\"ntriangleright\":\"⋫\",\"ntrianglerighteq\":\"⋭\",\"Nu\":\"Ν\",\"nu\":\"ν\",\"num\":\"#\",\"numero\":\"№\",\"numsp\":\" \",\"nvap\":\"≍⃒\",\"nvdash\":\"⊬\",\"nvDash\":\"⊭\",\"nVdash\":\"⊮\",\"nVDash\":\"⊯\",\"nvge\":\"≥⃒\",\"nvgt\":\">⃒\",\"nvHarr\":\"⤄\",\"nvinfin\":\"⧞\",\"nvlArr\":\"⤂\",\"nvle\":\"≤⃒\",\"nvlt\":\"<⃒\",\"nvltrie\":\"⊴⃒\",\"nvrArr\":\"⤃\",\"nvrtrie\":\"⊵⃒\",\"nvsim\":\"∼⃒\",\"nwarhk\":\"⤣\",\"nwarr\":\"↖\",\"nwArr\":\"⇖\",\"nwarrow\":\"↖\",\"nwnear\":\"⤧\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"oast\":\"⊛\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"ocir\":\"⊚\",\"Ocy\":\"О\",\"ocy\":\"о\",\"odash\":\"⊝\",\"Odblac\":\"Ő\",\"odblac\":\"ő\",\"odiv\":\"⨸\",\"odot\":\"⊙\",\"odsold\":\"⦼\",\"OElig\":\"Œ\",\"oelig\":\"œ\",\"ofcir\":\"⦿\",\"Ofr\":\"𝔒\",\"ofr\":\"𝔬\",\"ogon\":\"˛\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ogt\":\"⧁\",\"ohbar\":\"⦵\",\"ohm\":\"Ω\",\"oint\":\"∮\",\"olarr\":\"↺\",\"olcir\":\"⦾\",\"olcross\":\"⦻\",\"oline\":\"‾\",\"olt\":\"⧀\",\"Omacr\":\"Ō\",\"omacr\":\"ō\",\"Omega\":\"Ω\",\"omega\":\"ω\",\"Omicron\":\"Ο\",\"omicron\":\"ο\",\"omid\":\"⦶\",\"ominus\":\"⊖\",\"Oopf\":\"𝕆\",\"oopf\":\"𝕠\",\"opar\":\"⦷\",\"OpenCurlyDoubleQuote\":\"“\",\"OpenCurlyQuote\":\"‘\",\"operp\":\"⦹\",\"oplus\":\"⊕\",\"orarr\":\"↻\",\"Or\":\"⩔\",\"or\":\"∨\",\"ord\":\"⩝\",\"order\":\"ℴ\",\"orderof\":\"ℴ\",\"ordf\":\"ª\",\"ordm\":\"º\",\"origof\":\"⊶\",\"oror\":\"⩖\",\"orslope\":\"⩗\",\"orv\":\"⩛\",\"oS\":\"Ⓢ\",\"Oscr\":\"𝒪\",\"oscr\":\"ℴ\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"osol\":\"⊘\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"otimesas\":\"⨶\",\"Otimes\":\"⨷\",\"otimes\":\"⊗\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"ovbar\":\"⌽\",\"OverBar\":\"‾\",\"OverBrace\":\"⏞\",\"OverBracket\":\"⎴\",\"OverParenthesis\":\"⏜\",\"para\":\"¶\",\"parallel\":\"∥\",\"par\":\"∥\",\"parsim\":\"⫳\",\"parsl\":\"⫽\",\"part\":\"∂\",\"PartialD\":\"∂\",\"Pcy\":\"П\",\"pcy\":\"п\",\"percnt\":\"%\",\"period\":\".\",\"permil\":\"‰\",\"perp\":\"⊥\",\"pertenk\":\"‱\",\"Pfr\":\"𝔓\",\"pfr\":\"𝔭\",\"Phi\":\"Φ\",\"phi\":\"φ\",\"phiv\":\"ϕ\",\"phmmat\":\"ℳ\",\"phone\":\"☎\",\"Pi\":\"Π\",\"pi\":\"π\",\"pitchfork\":\"⋔\",\"piv\":\"ϖ\",\"planck\":\"ℏ\",\"planckh\":\"ℎ\",\"plankv\":\"ℏ\",\"plusacir\":\"⨣\",\"plusb\":\"⊞\",\"pluscir\":\"⨢\",\"plus\":\"+\",\"plusdo\":\"∔\",\"plusdu\":\"⨥\",\"pluse\":\"⩲\",\"PlusMinus\":\"±\",\"plusmn\":\"±\",\"plussim\":\"⨦\",\"plustwo\":\"⨧\",\"pm\":\"±\",\"Poincareplane\":\"ℌ\",\"pointint\":\"⨕\",\"popf\":\"𝕡\",\"Popf\":\"ℙ\",\"pound\":\"£\",\"prap\":\"⪷\",\"Pr\":\"⪻\",\"pr\":\"≺\",\"prcue\":\"≼\",\"precapprox\":\"⪷\",\"prec\":\"≺\",\"preccurlyeq\":\"≼\",\"Precedes\":\"≺\",\"PrecedesEqual\":\"⪯\",\"PrecedesSlantEqual\":\"≼\",\"PrecedesTilde\":\"≾\",\"preceq\":\"⪯\",\"precnapprox\":\"⪹\",\"precneqq\":\"⪵\",\"precnsim\":\"⋨\",\"pre\":\"⪯\",\"prE\":\"⪳\",\"precsim\":\"≾\",\"prime\":\"′\",\"Prime\":\"″\",\"primes\":\"ℙ\",\"prnap\":\"⪹\",\"prnE\":\"⪵\",\"prnsim\":\"⋨\",\"prod\":\"∏\",\"Product\":\"∏\",\"profalar\":\"⌮\",\"profline\":\"⌒\",\"profsurf\":\"⌓\",\"prop\":\"∝\",\"Proportional\":\"∝\",\"Proportion\":\"∷\",\"propto\":\"∝\",\"prsim\":\"≾\",\"prurel\":\"⊰\",\"Pscr\":\"𝒫\",\"pscr\":\"𝓅\",\"Psi\":\"Ψ\",\"psi\":\"ψ\",\"puncsp\":\" \",\"Qfr\":\"𝔔\",\"qfr\":\"𝔮\",\"qint\":\"⨌\",\"qopf\":\"𝕢\",\"Qopf\":\"ℚ\",\"qprime\":\"⁗\",\"Qscr\":\"𝒬\",\"qscr\":\"𝓆\",\"quaternions\":\"ℍ\",\"quatint\":\"⨖\",\"quest\":\"?\",\"questeq\":\"≟\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"rAarr\":\"⇛\",\"race\":\"∽̱\",\"Racute\":\"Ŕ\",\"racute\":\"ŕ\",\"radic\":\"√\",\"raemptyv\":\"⦳\",\"rang\":\"⟩\",\"Rang\":\"⟫\",\"rangd\":\"⦒\",\"range\":\"⦥\",\"rangle\":\"⟩\",\"raquo\":\"»\",\"rarrap\":\"⥵\",\"rarrb\":\"⇥\",\"rarrbfs\":\"⤠\",\"rarrc\":\"⤳\",\"rarr\":\"→\",\"Rarr\":\"↠\",\"rArr\":\"⇒\",\"rarrfs\":\"⤞\",\"rarrhk\":\"↪\",\"rarrlp\":\"↬\",\"rarrpl\":\"⥅\",\"rarrsim\":\"⥴\",\"Rarrtl\":\"⤖\",\"rarrtl\":\"↣\",\"rarrw\":\"↝\",\"ratail\":\"⤚\",\"rAtail\":\"⤜\",\"ratio\":\"∶\",\"rationals\":\"ℚ\",\"rbarr\":\"⤍\",\"rBarr\":\"⤏\",\"RBarr\":\"⤐\",\"rbbrk\":\"❳\",\"rbrace\":\"}\",\"rbrack\":\"]\",\"rbrke\":\"⦌\",\"rbrksld\":\"⦎\",\"rbrkslu\":\"⦐\",\"Rcaron\":\"Ř\",\"rcaron\":\"ř\",\"Rcedil\":\"Ŗ\",\"rcedil\":\"ŗ\",\"rceil\":\"⌉\",\"rcub\":\"}\",\"Rcy\":\"Р\",\"rcy\":\"р\",\"rdca\":\"⤷\",\"rdldhar\":\"⥩\",\"rdquo\":\"”\",\"rdquor\":\"”\",\"rdsh\":\"↳\",\"real\":\"ℜ\",\"realine\":\"ℛ\",\"realpart\":\"ℜ\",\"reals\":\"ℝ\",\"Re\":\"ℜ\",\"rect\":\"▭\",\"reg\":\"®\",\"REG\":\"®\",\"ReverseElement\":\"∋\",\"ReverseEquilibrium\":\"⇋\",\"ReverseUpEquilibrium\":\"⥯\",\"rfisht\":\"⥽\",\"rfloor\":\"⌋\",\"rfr\":\"𝔯\",\"Rfr\":\"ℜ\",\"rHar\":\"⥤\",\"rhard\":\"⇁\",\"rharu\":\"⇀\",\"rharul\":\"⥬\",\"Rho\":\"Ρ\",\"rho\":\"ρ\",\"rhov\":\"ϱ\",\"RightAngleBracket\":\"⟩\",\"RightArrowBar\":\"⇥\",\"rightarrow\":\"→\",\"RightArrow\":\"→\",\"Rightarrow\":\"⇒\",\"RightArrowLeftArrow\":\"⇄\",\"rightarrowtail\":\"↣\",\"RightCeiling\":\"⌉\",\"RightDoubleBracket\":\"⟧\",\"RightDownTeeVector\":\"⥝\",\"RightDownVectorBar\":\"⥕\",\"RightDownVector\":\"⇂\",\"RightFloor\":\"⌋\",\"rightharpoondown\":\"⇁\",\"rightharpoonup\":\"⇀\",\"rightleftarrows\":\"⇄\",\"rightleftharpoons\":\"⇌\",\"rightrightarrows\":\"⇉\",\"rightsquigarrow\":\"↝\",\"RightTeeArrow\":\"↦\",\"RightTee\":\"⊢\",\"RightTeeVector\":\"⥛\",\"rightthreetimes\":\"⋌\",\"RightTriangleBar\":\"⧐\",\"RightTriangle\":\"⊳\",\"RightTriangleEqual\":\"⊵\",\"RightUpDownVector\":\"⥏\",\"RightUpTeeVector\":\"⥜\",\"RightUpVectorBar\":\"⥔\",\"RightUpVector\":\"↾\",\"RightVectorBar\":\"⥓\",\"RightVector\":\"⇀\",\"ring\":\"˚\",\"risingdotseq\":\"≓\",\"rlarr\":\"⇄\",\"rlhar\":\"⇌\",\"rlm\":\"‏\",\"rmoustache\":\"⎱\",\"rmoust\":\"⎱\",\"rnmid\":\"⫮\",\"roang\":\"⟭\",\"roarr\":\"⇾\",\"robrk\":\"⟧\",\"ropar\":\"⦆\",\"ropf\":\"𝕣\",\"Ropf\":\"ℝ\",\"roplus\":\"⨮\",\"rotimes\":\"⨵\",\"RoundImplies\":\"⥰\",\"rpar\":\")\",\"rpargt\":\"⦔\",\"rppolint\":\"⨒\",\"rrarr\":\"⇉\",\"Rrightarrow\":\"⇛\",\"rsaquo\":\"›\",\"rscr\":\"𝓇\",\"Rscr\":\"ℛ\",\"rsh\":\"↱\",\"Rsh\":\"↱\",\"rsqb\":\"]\",\"rsquo\":\"’\",\"rsquor\":\"’\",\"rthree\":\"⋌\",\"rtimes\":\"⋊\",\"rtri\":\"▹\",\"rtrie\":\"⊵\",\"rtrif\":\"▸\",\"rtriltri\":\"⧎\",\"RuleDelayed\":\"⧴\",\"ruluhar\":\"⥨\",\"rx\":\"℞\",\"Sacute\":\"Ś\",\"sacute\":\"ś\",\"sbquo\":\"‚\",\"scap\":\"⪸\",\"Scaron\":\"Š\",\"scaron\":\"š\",\"Sc\":\"⪼\",\"sc\":\"≻\",\"sccue\":\"≽\",\"sce\":\"⪰\",\"scE\":\"⪴\",\"Scedil\":\"Ş\",\"scedil\":\"ş\",\"Scirc\":\"Ŝ\",\"scirc\":\"ŝ\",\"scnap\":\"⪺\",\"scnE\":\"⪶\",\"scnsim\":\"⋩\",\"scpolint\":\"⨓\",\"scsim\":\"≿\",\"Scy\":\"С\",\"scy\":\"с\",\"sdotb\":\"⊡\",\"sdot\":\"⋅\",\"sdote\":\"⩦\",\"searhk\":\"⤥\",\"searr\":\"↘\",\"seArr\":\"⇘\",\"searrow\":\"↘\",\"sect\":\"§\",\"semi\":\";\",\"seswar\":\"⤩\",\"setminus\":\"∖\",\"setmn\":\"∖\",\"sext\":\"✶\",\"Sfr\":\"𝔖\",\"sfr\":\"𝔰\",\"sfrown\":\"⌢\",\"sharp\":\"♯\",\"SHCHcy\":\"Щ\",\"shchcy\":\"щ\",\"SHcy\":\"Ш\",\"shcy\":\"ш\",\"ShortDownArrow\":\"↓\",\"ShortLeftArrow\":\"←\",\"shortmid\":\"∣\",\"shortparallel\":\"∥\",\"ShortRightArrow\":\"→\",\"ShortUpArrow\":\"↑\",\"shy\":\"­\",\"Sigma\":\"Σ\",\"sigma\":\"σ\",\"sigmaf\":\"ς\",\"sigmav\":\"ς\",\"sim\":\"∼\",\"simdot\":\"⩪\",\"sime\":\"≃\",\"simeq\":\"≃\",\"simg\":\"⪞\",\"simgE\":\"⪠\",\"siml\":\"⪝\",\"simlE\":\"⪟\",\"simne\":\"≆\",\"simplus\":\"⨤\",\"simrarr\":\"⥲\",\"slarr\":\"←\",\"SmallCircle\":\"∘\",\"smallsetminus\":\"∖\",\"smashp\":\"⨳\",\"smeparsl\":\"⧤\",\"smid\":\"∣\",\"smile\":\"⌣\",\"smt\":\"⪪\",\"smte\":\"⪬\",\"smtes\":\"⪬︀\",\"SOFTcy\":\"Ь\",\"softcy\":\"ь\",\"solbar\":\"⌿\",\"solb\":\"⧄\",\"sol\":\"/\",\"Sopf\":\"𝕊\",\"sopf\":\"𝕤\",\"spades\":\"♠\",\"spadesuit\":\"♠\",\"spar\":\"∥\",\"sqcap\":\"⊓\",\"sqcaps\":\"⊓︀\",\"sqcup\":\"⊔\",\"sqcups\":\"⊔︀\",\"Sqrt\":\"√\",\"sqsub\":\"⊏\",\"sqsube\":\"⊑\",\"sqsubset\":\"⊏\",\"sqsubseteq\":\"⊑\",\"sqsup\":\"⊐\",\"sqsupe\":\"⊒\",\"sqsupset\":\"⊐\",\"sqsupseteq\":\"⊒\",\"square\":\"□\",\"Square\":\"□\",\"SquareIntersection\":\"⊓\",\"SquareSubset\":\"⊏\",\"SquareSubsetEqual\":\"⊑\",\"SquareSuperset\":\"⊐\",\"SquareSupersetEqual\":\"⊒\",\"SquareUnion\":\"⊔\",\"squarf\":\"▪\",\"squ\":\"□\",\"squf\":\"▪\",\"srarr\":\"→\",\"Sscr\":\"𝒮\",\"sscr\":\"𝓈\",\"ssetmn\":\"∖\",\"ssmile\":\"⌣\",\"sstarf\":\"⋆\",\"Star\":\"⋆\",\"star\":\"☆\",\"starf\":\"★\",\"straightepsilon\":\"ϵ\",\"straightphi\":\"ϕ\",\"strns\":\"¯\",\"sub\":\"⊂\",\"Sub\":\"⋐\",\"subdot\":\"⪽\",\"subE\":\"⫅\",\"sube\":\"⊆\",\"subedot\":\"⫃\",\"submult\":\"⫁\",\"subnE\":\"⫋\",\"subne\":\"⊊\",\"subplus\":\"⪿\",\"subrarr\":\"⥹\",\"subset\":\"⊂\",\"Subset\":\"⋐\",\"subseteq\":\"⊆\",\"subseteqq\":\"⫅\",\"SubsetEqual\":\"⊆\",\"subsetneq\":\"⊊\",\"subsetneqq\":\"⫋\",\"subsim\":\"⫇\",\"subsub\":\"⫕\",\"subsup\":\"⫓\",\"succapprox\":\"⪸\",\"succ\":\"≻\",\"succcurlyeq\":\"≽\",\"Succeeds\":\"≻\",\"SucceedsEqual\":\"⪰\",\"SucceedsSlantEqual\":\"≽\",\"SucceedsTilde\":\"≿\",\"succeq\":\"⪰\",\"succnapprox\":\"⪺\",\"succneqq\":\"⪶\",\"succnsim\":\"⋩\",\"succsim\":\"≿\",\"SuchThat\":\"∋\",\"sum\":\"∑\",\"Sum\":\"∑\",\"sung\":\"♪\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"sup\":\"⊃\",\"Sup\":\"⋑\",\"supdot\":\"⪾\",\"supdsub\":\"⫘\",\"supE\":\"⫆\",\"supe\":\"⊇\",\"supedot\":\"⫄\",\"Superset\":\"⊃\",\"SupersetEqual\":\"⊇\",\"suphsol\":\"⟉\",\"suphsub\":\"⫗\",\"suplarr\":\"⥻\",\"supmult\":\"⫂\",\"supnE\":\"⫌\",\"supne\":\"⊋\",\"supplus\":\"⫀\",\"supset\":\"⊃\",\"Supset\":\"⋑\",\"supseteq\":\"⊇\",\"supseteqq\":\"⫆\",\"supsetneq\":\"⊋\",\"supsetneqq\":\"⫌\",\"supsim\":\"⫈\",\"supsub\":\"⫔\",\"supsup\":\"⫖\",\"swarhk\":\"⤦\",\"swarr\":\"↙\",\"swArr\":\"⇙\",\"swarrow\":\"↙\",\"swnwar\":\"⤪\",\"szlig\":\"ß\",\"Tab\":\"\\\\t\",\"target\":\"⌖\",\"Tau\":\"Τ\",\"tau\":\"τ\",\"tbrk\":\"⎴\",\"Tcaron\":\"Ť\",\"tcaron\":\"ť\",\"Tcedil\":\"Ţ\",\"tcedil\":\"ţ\",\"Tcy\":\"Т\",\"tcy\":\"т\",\"tdot\":\"⃛\",\"telrec\":\"⌕\",\"Tfr\":\"𝔗\",\"tfr\":\"𝔱\",\"there4\":\"∴\",\"therefore\":\"∴\",\"Therefore\":\"∴\",\"Theta\":\"Θ\",\"theta\":\"θ\",\"thetasym\":\"ϑ\",\"thetav\":\"ϑ\",\"thickapprox\":\"≈\",\"thicksim\":\"∼\",\"ThickSpace\":\"  \",\"ThinSpace\":\" \",\"thinsp\":\" \",\"thkap\":\"≈\",\"thksim\":\"∼\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"tilde\":\"˜\",\"Tilde\":\"∼\",\"TildeEqual\":\"≃\",\"TildeFullEqual\":\"≅\",\"TildeTilde\":\"≈\",\"timesbar\":\"⨱\",\"timesb\":\"⊠\",\"times\":\"×\",\"timesd\":\"⨰\",\"tint\":\"∭\",\"toea\":\"⤨\",\"topbot\":\"⌶\",\"topcir\":\"⫱\",\"top\":\"⊤\",\"Topf\":\"𝕋\",\"topf\":\"𝕥\",\"topfork\":\"⫚\",\"tosa\":\"⤩\",\"tprime\":\"‴\",\"trade\":\"™\",\"TRADE\":\"™\",\"triangle\":\"▵\",\"triangledown\":\"▿\",\"triangleleft\":\"◃\",\"trianglelefteq\":\"⊴\",\"triangleq\":\"≜\",\"triangleright\":\"▹\",\"trianglerighteq\":\"⊵\",\"tridot\":\"◬\",\"trie\":\"≜\",\"triminus\":\"⨺\",\"TripleDot\":\"⃛\",\"triplus\":\"⨹\",\"trisb\":\"⧍\",\"tritime\":\"⨻\",\"trpezium\":\"⏢\",\"Tscr\":\"𝒯\",\"tscr\":\"𝓉\",\"TScy\":\"Ц\",\"tscy\":\"ц\",\"TSHcy\":\"Ћ\",\"tshcy\":\"ћ\",\"Tstrok\":\"Ŧ\",\"tstrok\":\"ŧ\",\"twixt\":\"≬\",\"twoheadleftarrow\":\"↞\",\"twoheadrightarrow\":\"↠\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"uarr\":\"↑\",\"Uarr\":\"↟\",\"uArr\":\"⇑\",\"Uarrocir\":\"⥉\",\"Ubrcy\":\"Ў\",\"ubrcy\":\"ў\",\"Ubreve\":\"Ŭ\",\"ubreve\":\"ŭ\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ucy\":\"У\",\"ucy\":\"у\",\"udarr\":\"⇅\",\"Udblac\":\"Ű\",\"udblac\":\"ű\",\"udhar\":\"⥮\",\"ufisht\":\"⥾\",\"Ufr\":\"𝔘\",\"ufr\":\"𝔲\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uHar\":\"⥣\",\"uharl\":\"↿\",\"uharr\":\"↾\",\"uhblk\":\"▀\",\"ulcorn\":\"⌜\",\"ulcorner\":\"⌜\",\"ulcrop\":\"⌏\",\"ultri\":\"◸\",\"Umacr\":\"Ū\",\"umacr\":\"ū\",\"uml\":\"¨\",\"UnderBar\":\"_\",\"UnderBrace\":\"⏟\",\"UnderBracket\":\"⎵\",\"UnderParenthesis\":\"⏝\",\"Union\":\"⋃\",\"UnionPlus\":\"⊎\",\"Uogon\":\"Ų\",\"uogon\":\"ų\",\"Uopf\":\"𝕌\",\"uopf\":\"𝕦\",\"UpArrowBar\":\"⤒\",\"uparrow\":\"↑\",\"UpArrow\":\"↑\",\"Uparrow\":\"⇑\",\"UpArrowDownArrow\":\"⇅\",\"updownarrow\":\"↕\",\"UpDownArrow\":\"↕\",\"Updownarrow\":\"⇕\",\"UpEquilibrium\":\"⥮\",\"upharpoonleft\":\"↿\",\"upharpoonright\":\"↾\",\"uplus\":\"⊎\",\"UpperLeftArrow\":\"↖\",\"UpperRightArrow\":\"↗\",\"upsi\":\"υ\",\"Upsi\":\"ϒ\",\"upsih\":\"ϒ\",\"Upsilon\":\"Υ\",\"upsilon\":\"υ\",\"UpTeeArrow\":\"↥\",\"UpTee\":\"⊥\",\"upuparrows\":\"⇈\",\"urcorn\":\"⌝\",\"urcorner\":\"⌝\",\"urcrop\":\"⌎\",\"Uring\":\"Ů\",\"uring\":\"ů\",\"urtri\":\"◹\",\"Uscr\":\"𝒰\",\"uscr\":\"𝓊\",\"utdot\":\"⋰\",\"Utilde\":\"Ũ\",\"utilde\":\"ũ\",\"utri\":\"▵\",\"utrif\":\"▴\",\"uuarr\":\"⇈\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"uwangle\":\"⦧\",\"vangrt\":\"⦜\",\"varepsilon\":\"ϵ\",\"varkappa\":\"ϰ\",\"varnothing\":\"∅\",\"varphi\":\"ϕ\",\"varpi\":\"ϖ\",\"varpropto\":\"∝\",\"varr\":\"↕\",\"vArr\":\"⇕\",\"varrho\":\"ϱ\",\"varsigma\":\"ς\",\"varsubsetneq\":\"⊊︀\",\"varsubsetneqq\":\"⫋︀\",\"varsupsetneq\":\"⊋︀\",\"varsupsetneqq\":\"⫌︀\",\"vartheta\":\"ϑ\",\"vartriangleleft\":\"⊲\",\"vartriangleright\":\"⊳\",\"vBar\":\"⫨\",\"Vbar\":\"⫫\",\"vBarv\":\"⫩\",\"Vcy\":\"В\",\"vcy\":\"в\",\"vdash\":\"⊢\",\"vDash\":\"⊨\",\"Vdash\":\"⊩\",\"VDash\":\"⊫\",\"Vdashl\":\"⫦\",\"veebar\":\"⊻\",\"vee\":\"∨\",\"Vee\":\"⋁\",\"veeeq\":\"≚\",\"vellip\":\"⋮\",\"verbar\":\"|\",\"Verbar\":\"‖\",\"vert\":\"|\",\"Vert\":\"‖\",\"VerticalBar\":\"∣\",\"VerticalLine\":\"|\",\"VerticalSeparator\":\"❘\",\"VerticalTilde\":\"≀\",\"VeryThinSpace\":\" \",\"Vfr\":\"𝔙\",\"vfr\":\"𝔳\",\"vltri\":\"⊲\",\"vnsub\":\"⊂⃒\",\"vnsup\":\"⊃⃒\",\"Vopf\":\"𝕍\",\"vopf\":\"𝕧\",\"vprop\":\"∝\",\"vrtri\":\"⊳\",\"Vscr\":\"𝒱\",\"vscr\":\"𝓋\",\"vsubnE\":\"⫋︀\",\"vsubne\":\"⊊︀\",\"vsupnE\":\"⫌︀\",\"vsupne\":\"⊋︀\",\"Vvdash\":\"⊪\",\"vzigzag\":\"⦚\",\"Wcirc\":\"Ŵ\",\"wcirc\":\"ŵ\",\"wedbar\":\"⩟\",\"wedge\":\"∧\",\"Wedge\":\"⋀\",\"wedgeq\":\"≙\",\"weierp\":\"℘\",\"Wfr\":\"𝔚\",\"wfr\":\"𝔴\",\"Wopf\":\"𝕎\",\"wopf\":\"𝕨\",\"wp\":\"℘\",\"wr\":\"≀\",\"wreath\":\"≀\",\"Wscr\":\"𝒲\",\"wscr\":\"𝓌\",\"xcap\":\"⋂\",\"xcirc\":\"◯\",\"xcup\":\"⋃\",\"xdtri\":\"▽\",\"Xfr\":\"𝔛\",\"xfr\":\"𝔵\",\"xharr\":\"⟷\",\"xhArr\":\"⟺\",\"Xi\":\"Ξ\",\"xi\":\"ξ\",\"xlarr\":\"⟵\",\"xlArr\":\"⟸\",\"xmap\":\"⟼\",\"xnis\":\"⋻\",\"xodot\":\"⨀\",\"Xopf\":\"𝕏\",\"xopf\":\"𝕩\",\"xoplus\":\"⨁\",\"xotime\":\"⨂\",\"xrarr\":\"⟶\",\"xrArr\":\"⟹\",\"Xscr\":\"𝒳\",\"xscr\":\"𝓍\",\"xsqcup\":\"⨆\",\"xuplus\":\"⨄\",\"xutri\":\"△\",\"xvee\":\"⋁\",\"xwedge\":\"⋀\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"YAcy\":\"Я\",\"yacy\":\"я\",\"Ycirc\":\"Ŷ\",\"ycirc\":\"ŷ\",\"Ycy\":\"Ы\",\"ycy\":\"ы\",\"yen\":\"¥\",\"Yfr\":\"𝔜\",\"yfr\":\"𝔶\",\"YIcy\":\"Ї\",\"yicy\":\"ї\",\"Yopf\":\"𝕐\",\"yopf\":\"𝕪\",\"Yscr\":\"𝒴\",\"yscr\":\"𝓎\",\"YUcy\":\"Ю\",\"yucy\":\"ю\",\"yuml\":\"ÿ\",\"Yuml\":\"Ÿ\",\"Zacute\":\"Ź\",\"zacute\":\"ź\",\"Zcaron\":\"Ž\",\"zcaron\":\"ž\",\"Zcy\":\"З\",\"zcy\":\"з\",\"Zdot\":\"Ż\",\"zdot\":\"ż\",\"zeetrf\":\"ℨ\",\"ZeroWidthSpace\":\"​\",\"Zeta\":\"Ζ\",\"zeta\":\"ζ\",\"zfr\":\"𝔷\",\"Zfr\":\"ℨ\",\"ZHcy\":\"Ж\",\"zhcy\":\"ж\",\"zigrarr\":\"⇝\",\"zopf\":\"𝕫\",\"Zopf\":\"ℤ\",\"Zscr\":\"𝒵\",\"zscr\":\"𝓏\",\"zwj\":\"‍\",\"zwnj\":\"‌\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/entities/maps/entities.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/entities/maps/legacy.json":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/entities/maps/legacy.json ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"Aacute\":\"Á\",\"aacute\":\"á\",\"Acirc\":\"Â\",\"acirc\":\"â\",\"acute\":\"´\",\"AElig\":\"Æ\",\"aelig\":\"æ\",\"Agrave\":\"À\",\"agrave\":\"à\",\"amp\":\"&\",\"AMP\":\"&\",\"Aring\":\"Å\",\"aring\":\"å\",\"Atilde\":\"Ã\",\"atilde\":\"ã\",\"Auml\":\"Ä\",\"auml\":\"ä\",\"brvbar\":\"¦\",\"Ccedil\":\"Ç\",\"ccedil\":\"ç\",\"cedil\":\"¸\",\"cent\":\"¢\",\"copy\":\"©\",\"COPY\":\"©\",\"curren\":\"¤\",\"deg\":\"°\",\"divide\":\"÷\",\"Eacute\":\"É\",\"eacute\":\"é\",\"Ecirc\":\"Ê\",\"ecirc\":\"ê\",\"Egrave\":\"È\",\"egrave\":\"è\",\"ETH\":\"Ð\",\"eth\":\"ð\",\"Euml\":\"Ë\",\"euml\":\"ë\",\"frac12\":\"½\",\"frac14\":\"¼\",\"frac34\":\"¾\",\"gt\":\">\",\"GT\":\">\",\"Iacute\":\"Í\",\"iacute\":\"í\",\"Icirc\":\"Î\",\"icirc\":\"î\",\"iexcl\":\"¡\",\"Igrave\":\"Ì\",\"igrave\":\"ì\",\"iquest\":\"¿\",\"Iuml\":\"Ï\",\"iuml\":\"ï\",\"laquo\":\"«\",\"lt\":\"<\",\"LT\":\"<\",\"macr\":\"¯\",\"micro\":\"µ\",\"middot\":\"·\",\"nbsp\":\" \",\"not\":\"¬\",\"Ntilde\":\"Ñ\",\"ntilde\":\"ñ\",\"Oacute\":\"Ó\",\"oacute\":\"ó\",\"Ocirc\":\"Ô\",\"ocirc\":\"ô\",\"Ograve\":\"Ò\",\"ograve\":\"ò\",\"ordf\":\"ª\",\"ordm\":\"º\",\"Oslash\":\"Ø\",\"oslash\":\"ø\",\"Otilde\":\"Õ\",\"otilde\":\"õ\",\"Ouml\":\"Ö\",\"ouml\":\"ö\",\"para\":\"¶\",\"plusmn\":\"±\",\"pound\":\"£\",\"quot\":\"\\\\\"\",\"QUOT\":\"\\\\\"\",\"raquo\":\"»\",\"reg\":\"®\",\"REG\":\"®\",\"sect\":\"§\",\"shy\":\"­\",\"sup1\":\"¹\",\"sup2\":\"²\",\"sup3\":\"³\",\"szlig\":\"ß\",\"THORN\":\"Þ\",\"thorn\":\"þ\",\"times\":\"×\",\"Uacute\":\"Ú\",\"uacute\":\"ú\",\"Ucirc\":\"Û\",\"ucirc\":\"û\",\"Ugrave\":\"Ù\",\"ugrave\":\"ù\",\"uml\":\"¨\",\"Uuml\":\"Ü\",\"uuml\":\"ü\",\"Yacute\":\"Ý\",\"yacute\":\"ý\",\"yen\":\"¥\",\"yuml\":\"ÿ\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/entities/maps/legacy.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/entities/maps/xml.json":
/*!*********************************************************!*\
  !*** ../scratch-vm/node_modules/entities/maps/xml.json ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = /*#__PURE__*/JSON.parse('{\"amp\":\"&\",\"apos\":\"\\'\",\"gt\":\">\",\"lt\":\"<\",\"quot\":\"\\\\\"\"}');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/entities/maps/xml.json?");

/***/ }),

/***/ "../scratch-vm/node_modules/format-message-formats/index.js":
/*!******************************************************************!*\
  !*** ../scratch-vm/node_modules/format-message-formats/index.js ***!
  \******************************************************************/
/***/ ((module) => {

eval("// @flow\nvar LONG = 'long'\nvar SHORT = 'short'\nvar NARROW = 'narrow'\nvar NUMERIC = 'numeric'\nvar TWODIGIT = '2-digit'\n\n/**\n * formatting information\n **/\nmodule.exports = {\n  number: {\n    decimal: {\n      style: 'decimal'\n    },\n    integer: {\n      style: 'decimal',\n      maximumFractionDigits: 0\n    },\n    currency: {\n      style: 'currency',\n      currency: 'USD'\n    },\n    percent: {\n      style: 'percent'\n    },\n    default: {\n      style: 'decimal'\n    }\n  },\n  date: {\n    short: {\n      month: NUMERIC,\n      day: NUMERIC,\n      year: TWODIGIT\n    },\n    medium: {\n      month: SHORT,\n      day: NUMERIC,\n      year: NUMERIC\n    },\n    long: {\n      month: LONG,\n      day: NUMERIC,\n      year: NUMERIC\n    },\n    full: {\n      month: LONG,\n      day: NUMERIC,\n      year: NUMERIC,\n      weekday: LONG\n    },\n    default: {\n      month: SHORT,\n      day: NUMERIC,\n      year: NUMERIC\n    }\n  },\n  time: {\n    short: {\n      hour: NUMERIC,\n      minute: NUMERIC\n    },\n    medium: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC\n    },\n    long: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC,\n      timeZoneName: SHORT\n    },\n    full: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC,\n      timeZoneName: SHORT\n    },\n    default: {\n      hour: NUMERIC,\n      minute: NUMERIC,\n      second: NUMERIC\n    }\n  },\n  duration: {\n    default: {\n      hours: {\n        minimumIntegerDigits: 1,\n        maximumFractionDigits: 0\n      },\n      minutes: {\n        minimumIntegerDigits: 2,\n        maximumFractionDigits: 0\n      },\n      seconds: {\n        minimumIntegerDigits: 2,\n        maximumFractionDigits: 3\n      }\n    }\n  },\n  parseNumberPattern: function (pattern/*: ?string */) {\n    if (!pattern) return\n    var options = {}\n    var currency = pattern.match(/\\b[A-Z]{3}\\b/i)\n    var syms = pattern.replace(/[^¤]/g, '').length\n    if (!syms && currency) syms = 1\n    if (syms) {\n      options.style = 'currency'\n      options.currencyDisplay = syms === 1 ? 'symbol' : syms === 2 ? 'code' : 'name'\n      options.currency = currency ? currency[0].toUpperCase() : 'USD'\n    } else if (pattern.indexOf('%') >= 0) {\n      options.style = 'percent'\n    }\n    if (!/[@#0]/.test(pattern)) return options.style ? options : undefined\n    options.useGrouping = pattern.indexOf(',') >= 0\n    if (/E\\+?[@#0]+/i.test(pattern) || pattern.indexOf('@') >= 0) {\n      var size = pattern.replace(/E\\+?[@#0]+|[^@#0]/gi, '')\n      options.minimumSignificantDigits = Math.min(Math.max(size.replace(/[^@0]/g, '').length, 1), 21)\n      options.maximumSignificantDigits = Math.min(Math.max(size.length, 1), 21)\n    } else {\n      var parts = pattern.replace(/[^#0.]/g, '').split('.')\n      var integer = parts[0]\n      var n = integer.length - 1\n      while (integer[n] === '0') --n\n      options.minimumIntegerDigits = Math.min(Math.max(integer.length - 1 - n, 1), 21)\n      var fraction = parts[1] || ''\n      n = 0\n      while (fraction[n] === '0') ++n\n      options.minimumFractionDigits = Math.min(Math.max(n, 0), 20)\n      while (fraction[n] === '#') ++n\n      options.maximumFractionDigits = Math.min(Math.max(n, 0), 20)\n    }\n    return options\n  },\n  parseDatePattern: function (pattern/*: ?string */) {\n    if (!pattern) return\n    var options = {}\n    for (var i = 0; i < pattern.length;) {\n      var current = pattern[i]\n      var n = 1\n      while (pattern[++i] === current) ++n\n      switch (current) {\n        case 'G':\n          options.era = n === 5 ? NARROW : n === 4 ? LONG : SHORT\n          break\n        case 'y':\n        case 'Y':\n          options.year = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 'M':\n        case 'L':\n          n = Math.min(Math.max(n - 1, 0), 4)\n          options.month = [NUMERIC, TWODIGIT, SHORT, LONG, NARROW][n]\n          break\n        case 'E':\n        case 'e':\n        case 'c':\n          options.weekday = n === 5 ? NARROW : n === 4 ? LONG : SHORT\n          break\n        case 'd':\n        case 'D':\n          options.day = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 'h':\n        case 'K':\n          options.hour12 = true\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 'H':\n        case 'k':\n          options.hour12 = false\n          options.hour = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 'm':\n          options.minute = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 's':\n        case 'S':\n          options.second = n === 2 ? TWODIGIT : NUMERIC\n          break\n        case 'z':\n        case 'Z':\n        case 'v':\n        case 'V':\n          options.timeZoneName = n === 1 ? SHORT : LONG\n          break\n      }\n    }\n    return Object.keys(options).length ? options : undefined\n  }\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/format-message-formats/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/format-message-interpret/index.js":
/*!********************************************************************!*\
  !*** ../scratch-vm/node_modules/format-message-interpret/index.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("// @flow\n\nvar formats = __webpack_require__(/*! format-message-formats */ \"../scratch-vm/node_modules/format-message-formats/index.js\")\nvar lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ \"../scratch-vm/node_modules/lookup-closest-locale/index.js\")\nvar plurals = __webpack_require__(/*! ./plurals */ \"../scratch-vm/node_modules/format-message-interpret/plurals.js\")\n\n/*::\nimport type {\n  AST,\n  SubMessages\n} from '../format-message-parse'\ntype Locale = string\ntype Locales = Locale | Locale[]\ntype Placeholder = any[] // https://github.com/facebook/flow/issues/4050\nexport type Type = (Placeholder, Locales) => (any, ?Object) => any\nexport type Types = { [string]: Type }\n*/\n\nexports = module.exports = function interpret (\n  ast/*: AST */,\n  locale/*:: ?: Locales */,\n  types/*:: ?: Types */\n)/*: (args?: Object) => string */ {\n  return interpretAST(ast, null, locale || 'en', types || {}, true)\n}\n\nexports.toParts = function toParts (\n  ast/*: AST */,\n  locale/*:: ?: Locales */,\n  types/*:: ?: Types */\n)/*: (args?: Object) => any[] */ {\n  return interpretAST(ast, null, locale || 'en', types || {}, false)\n}\n\nfunction interpretAST (\n  elements/*: any[] */,\n  parent/*: ?Placeholder */,\n  locale/*: Locales */,\n  types/*: Types */,\n  join/*: boolean */\n)/*: Function */ {\n  var parts = elements.map(function (element) {\n    return interpretElement(element, parent, locale, types, join)\n  })\n\n  if (!join) {\n    return function format (args) {\n      return parts.reduce(function (parts, part) {\n        return parts.concat(part(args))\n      }, [])\n    }\n  }\n\n  if (parts.length === 1) return parts[0]\n  return function format (args) {\n    var message = ''\n    for (var e = 0; e < parts.length; ++e) {\n      message += parts[e](args)\n    }\n    return message\n  }\n}\n\nfunction interpretElement (\n  element/*: Placeholder */,\n  parent/*: ?Placeholder */,\n  locale/*: Locales */,\n  types/*: Types */,\n  join/*: boolean */\n)/*: Function */ {\n  if (typeof element === 'string') {\n    var value/*: string */ = element\n    return function format () { return value }\n  }\n\n  var id = element[0]\n  var type = element[1]\n\n  if (parent && element[0] === '#') {\n    id = parent[0]\n    var offset = parent[2]\n    var formatter = (types.number || defaults.number)([id, 'number'], locale)\n    return function format (args) {\n      return formatter(getArg(id, args) - offset, args)\n    }\n  }\n\n  // pre-process children\n  var children\n  if (type === 'plural' || type === 'selectordinal') {\n    children = {}\n    Object.keys(element[3]).forEach(function (key) {\n      children[key] = interpretAST(element[3][key], element, locale, types, join)\n    })\n    element = [element[0], element[1], element[2], children]\n  } else if (element[2] && typeof element[2] === 'object') {\n    children = {}\n    Object.keys(element[2]).forEach(function (key) {\n      children[key] = interpretAST(element[2][key], element, locale, types, join)\n    })\n    element = [element[0], element[1], children]\n  }\n\n  var getFrmt = type && (types[type] || defaults[type])\n  if (getFrmt) {\n    var frmt = getFrmt(element, locale)\n    return function format (args) {\n      return frmt(getArg(id, args), args)\n    }\n  }\n\n  return join\n    ? function format (args) { return String(getArg(id, args)) }\n    : function format (args) { return getArg(id, args) }\n}\n\nfunction getArg (id/*: string */, args/*: ?Object */)/*: any */ {\n  if (args && (id in args)) return args[id]\n  var parts = id.split('.')\n  var a = args\n  for (var i = 0, ii = parts.length; a && i < ii; ++i) {\n    a = a[parts[i]]\n  }\n  return a\n}\n\nfunction interpretNumber (element/*: Placeholder */, locales/*: Locales */) {\n  var style = element[2]\n  var options = formats.number[style] || formats.parseNumberPattern(style) || formats.number.default\n  return new Intl.NumberFormat(locales, options).format\n}\n\nfunction interpretDuration (element/*: Placeholder */, locales/*: Locales */) {\n  var style = element[2]\n  var options = formats.duration[style] || formats.duration.default\n  var fs = new Intl.NumberFormat(locales, options.seconds).format\n  var fm = new Intl.NumberFormat(locales, options.minutes).format\n  var fh = new Intl.NumberFormat(locales, options.hours).format\n  var sep = /^fi$|^fi-|^da/.test(String(locales)) ? '.' : ':'\n\n  return function (s, args) {\n    s = +s\n    if (!isFinite(s)) return fs(s)\n    var h = ~~(s / 60 / 60) // ~~ acts much like Math.trunc\n    var m = ~~(s / 60 % 60)\n    var dur = (h ? (fh(Math.abs(h)) + sep) : '') +\n      fm(Math.abs(m)) + sep + fs(Math.abs(s % 60))\n    return s < 0 ? fh(-1).replace(fh(1), dur) : dur\n  }\n}\n\nfunction interpretDateTime (element/*: Placeholder */, locales/*: Locales */) {\n  var type = element[1]\n  var style = element[2]\n  var options = formats[type][style] || formats.parseDatePattern(style) || formats[type].default\n  return new Intl.DateTimeFormat(locales, options).format\n}\n\nfunction interpretPlural (element/*: Placeholder */, locales/*: Locales */) {\n  var type = element[1]\n  var pluralType = type === 'selectordinal' ? 'ordinal' : 'cardinal'\n  var offset = element[2]\n  var children = element[3]\n  var pluralRules\n  if (Intl.PluralRules && Intl.PluralRules.supportedLocalesOf(locales).length > 0) {\n    pluralRules = new Intl.PluralRules(locales, { type: pluralType })\n  } else {\n    var locale = lookupClosestLocale(locales, plurals)\n    var select = (locale && plurals[locale][pluralType]) || returnOther\n    pluralRules = { select: select }\n  }\n\n  return function (value, args) {\n    var clause =\n      children['=' + +value] ||\n      children[pluralRules.select(value - offset)] ||\n      children.other\n    return clause(args)\n  }\n}\n\nfunction returnOther (/*:: n:number */) { return 'other' }\n\nfunction interpretSelect (element/*: Placeholder */, locales/*: Locales */) {\n  var children = element[2]\n  return function (value, args) {\n    var clause = children[value] || children.other\n    return clause(args)\n  }\n}\n\nvar defaults/*: Types */ = {\n  number: interpretNumber,\n  ordinal: interpretNumber, // TODO: support rbnf\n  spellout: interpretNumber, // TODO: support rbnf\n  duration: interpretDuration,\n  date: interpretDateTime,\n  time: interpretDateTime,\n  plural: interpretPlural,\n  selectordinal: interpretPlural,\n  select: interpretSelect\n}\nexports.types = defaults\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/format-message-interpret/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/format-message-interpret/plurals.js":
/*!**********************************************************************!*\
  !*** ../scratch-vm/node_modules/format-message-interpret/plurals.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";
eval("// @flow\n\n\n/*:: export type Rule = 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' */\nvar zero = 'zero', one = 'one', two = 'two', few = 'few', many = 'many', other = 'other'\nvar f = [\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return 0 <= n && n <= 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var n = +s\n    return i === 0 || n === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 0 ? zero\n      : n === 1 ? one\n      : n === 2 ? two\n      : 3 <= n % 100 && n % 100 <= 10 ? few\n      : 11 <= n % 100 && n % 100 <= 99 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return i === 1 && v === 0 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n % 10 === 1 && n % 100 !== 11 ? one\n      : (2 <= n % 10 && n % 10 <= 4) && (n % 100 < 12 || 14 < n % 100) ? few\n      : n % 10 === 0 || (5 <= n % 10 && n % 10 <= 9) || (11 <= n % 100 && n % 100 <= 14) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n % 10 === 1 && (n % 100 !== 11 && n % 100 !== 71 && n % 100 !== 91) ? one\n      : n % 10 === 2 && (n % 100 !== 12 && n % 100 !== 72 && n % 100 !== 92) ? two\n      : ((3 <= n % 10 && n % 10 <= 4) || n % 10 === 9) && ((n % 100 < 10 || 19 < n % 100) && (n % 100 < 70 || 79 < n % 100) && (n % 100 < 90 || 99 < n % 100)) ? few\n      : n !== 0 && n % 1000000 === 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var f = +(s + '.').split('.')[1]\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) || (2 <= f % 10 && f % 10 <= 4) && (f % 100 < 12 || 14 < f % 100) ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return i === 1 && v === 0 ? one\n      : (2 <= i && i <= 4) && v === 0 ? few\n      : v !== 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 0 ? zero\n      : n === 1 ? one\n      : n === 2 ? two\n      : n === 3 ? few\n      : n === 6 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')\n    var n = +s\n    return n === 1 || t !== 0 && (i === 0 || i === 1) ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var f = +(s + '.').split('.')[1]\n    return v === 0 && i % 100 === 1 || f % 100 === 1 ? one\n      : v === 0 && i % 100 === 2 || f % 100 === 2 ? two\n      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || (3 <= f % 100 && f % 100 <= 4) ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    return i === 0 || i === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var f = +(s + '.').split('.')[1]\n    return v === 0 && (i === 1 || i === 2 || i === 3) || v === 0 && (i % 10 !== 4 && i % 10 !== 6 && i % 10 !== 9) || v !== 0 && (f % 10 !== 4 && f % 10 !== 6 && f % 10 !== 9) ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n === 2 ? two\n      : 3 <= n && n <= 6 ? few\n      : 7 <= n && n <= 10 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 || n === 11 ? one\n      : n === 2 || n === 12 ? two\n      : ((3 <= n && n <= 10) || (13 <= n && n <= 19)) ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return v === 0 && i % 10 === 1 ? one\n      : v === 0 && i % 10 === 2 ? two\n      : v === 0 && (i % 100 === 0 || i % 100 === 20 || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? few\n      : v !== 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var n = +s\n    return i === 1 && v === 0 ? one\n      : i === 2 && v === 0 ? two\n      : v === 0 && (n < 0 || 10 < n) && n % 10 === 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var t = +('' + s).replace(/^[^.]*.?|0+$/g, '')\n    return t === 0 && i % 10 === 1 && i % 100 !== 11 || t !== 0 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n === 2 ? two\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 0 ? zero\n      : n === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var n = +s\n    return n === 0 ? zero\n      : (i === 0 || i === 1) && n !== 0 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var f = +(s + '.').split('.')[1]\n    var n = +s\n    return n % 10 === 1 && (n % 100 < 11 || 19 < n % 100) ? one\n      : (2 <= n % 10 && n % 10 <= 9) && (n % 100 < 11 || 19 < n % 100) ? few\n      : f !== 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var v = (s + '.').split('.')[1].length\n    var f = +(s + '.').split('.')[1]\n    var n = +s\n    return n % 10 === 0 || (11 <= n % 100 && n % 100 <= 19) || v === 2 && (11 <= f % 100 && f % 100 <= 19) ? zero\n      : n % 10 === 1 && n % 100 !== 11 || v === 2 && f % 10 === 1 && f % 100 !== 11 || v !== 2 && f % 10 === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var f = +(s + '.').split('.')[1]\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 || f % 10 === 1 && f % 100 !== 11 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    var n = +s\n    return i === 1 && v === 0 ? one\n      : v !== 0 || n === 0 || n !== 1 && (1 <= n % 100 && n % 100 <= 19) ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n === 0 || (2 <= n % 100 && n % 100 <= 10) ? few\n      : 11 <= n % 100 && n % 100 <= 19 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return i === 1 && v === 0 ? one\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few\n      : v === 0 && i !== 1 && (0 <= i % 10 && i % 10 <= 1) || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (12 <= i % 100 && i % 100 <= 14) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    return 0 <= i && i <= 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return v === 0 && i % 10 === 1 && i % 100 !== 11 ? one\n      : v === 0 && (2 <= i % 10 && i % 10 <= 4) && (i % 100 < 12 || 14 < i % 100) ? few\n      : v === 0 && i % 10 === 0 || v === 0 && (5 <= i % 10 && i % 10 <= 9) || v === 0 && (11 <= i % 100 && i % 100 <= 14) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var n = +s\n    return i === 0 || n === 1 ? one\n      : 2 <= n && n <= 10 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var f = +(s + '.').split('.')[1]\n    var n = +s\n    return (n === 0 || n === 1) || i === 0 && f === 1 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    var v = (s + '.').split('.')[1].length\n    return v === 0 && i % 100 === 1 ? one\n      : v === 0 && i % 100 === 2 ? two\n      : v === 0 && (3 <= i % 100 && i % 100 <= 4) || v !== 0 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return (0 <= n && n <= 1) || (11 <= n && n <= 99) ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 || n === 5 || n === 7 || n === 8 || n === 9 || n === 10 ? one\n      : n === 2 || n === 3 ? two\n      : n === 4 ? few\n      : n === 6 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    return (i % 10 === 1 || i % 10 === 2 || i % 10 === 5 || i % 10 === 7 || i % 10 === 8) || (i % 100 === 20 || i % 100 === 50 || i % 100 === 70 || i % 100 === 80) ? one\n      : (i % 10 === 3 || i % 10 === 4) || (i % 1000 === 100 || i % 1000 === 200 || i % 1000 === 300 || i % 1000 === 400 || i % 1000 === 500 || i % 1000 === 600 || i % 1000 === 700 || i % 1000 === 800 || i % 1000 === 900) ? few\n      : i === 0 || i % 10 === 6 || (i % 100 === 40 || i % 100 === 60 || i % 100 === 90) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return (n % 10 === 2 || n % 10 === 3) && (n % 100 !== 12 && n % 100 !== 13) ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 || n === 3 ? one\n      : n === 2 ? two\n      : n === 4 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 0 || n === 7 || n === 8 || n === 9 ? zero\n      : n === 1 ? one\n      : n === 2 ? two\n      : n === 3 || n === 4 ? few\n      : n === 5 || n === 6 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n % 10 === 1 && n % 100 !== 11 ? one\n      : n % 10 === 2 && n % 100 !== 12 ? two\n      : n % 10 === 3 && n % 100 !== 13 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 || n === 11 ? one\n      : n === 2 || n === 12 ? two\n      : n === 3 || n === 13 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n === 2 || n === 3 ? two\n      : n === 4 ? few\n      : n === 6 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 || n === 5 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 11 || n === 8 || n === 80 || n === 800 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    return i === 1 ? one\n      : i === 0 || ((2 <= i % 100 && i % 100 <= 20) || i % 100 === 40 || i % 100 === 60 || i % 100 === 80) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n % 10 === 6 || n % 10 === 9 || n % 10 === 0 && n !== 0 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var i = Math.floor(Math.abs(+s))\n    return i % 10 === 1 && i % 100 !== 11 ? one\n      : i % 10 === 2 && i % 100 !== 12 ? two\n      : (i % 10 === 7 || i % 10 === 8) && (i % 100 !== 17 && i % 100 !== 18) ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n === 2 || n === 3 ? two\n      : n === 4 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return 1 <= n && n <= 4 ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return (n === 1 || n === 5 || (7 <= n && n <= 9)) ? one\n      : n === 2 || n === 3 ? two\n      : n === 4 ? few\n      : n === 6 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n === 1 ? one\n      : n % 10 === 4 && n % 100 !== 14 ? many\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return (n % 10 === 1 || n % 10 === 2) && (n % 100 !== 11 && n % 100 !== 12) ? one\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return (n % 10 === 6 || n % 10 === 9) || n === 10 ? few\n      : other\n  },\n  function (s/*: string | number */)/*: Rule */ {\n    var n = +s\n    return n % 10 === 3 && n % 100 !== 13 ? few\n      : other\n  }\n]\n\nmodule.exports = {\n  af: { cardinal: f[0] },\n  ak: { cardinal: f[1] },\n  am: { cardinal: f[2] },\n  ar: { cardinal: f[3] },\n  ars: { cardinal: f[3] },\n  as: { cardinal: f[2], ordinal: f[34] },\n  asa: { cardinal: f[0] },\n  ast: { cardinal: f[4] },\n  az: { cardinal: f[0], ordinal: f[35] },\n  be: { cardinal: f[5], ordinal: f[36] },\n  bem: { cardinal: f[0] },\n  bez: { cardinal: f[0] },\n  bg: { cardinal: f[0] },\n  bh: { cardinal: f[1] },\n  bn: { cardinal: f[2], ordinal: f[34] },\n  br: { cardinal: f[6] },\n  brx: { cardinal: f[0] },\n  bs: { cardinal: f[7] },\n  ca: { cardinal: f[4], ordinal: f[37] },\n  ce: { cardinal: f[0] },\n  cgg: { cardinal: f[0] },\n  chr: { cardinal: f[0] },\n  ckb: { cardinal: f[0] },\n  cs: { cardinal: f[8] },\n  cy: { cardinal: f[9], ordinal: f[38] },\n  da: { cardinal: f[10] },\n  de: { cardinal: f[4] },\n  dsb: { cardinal: f[11] },\n  dv: { cardinal: f[0] },\n  ee: { cardinal: f[0] },\n  el: { cardinal: f[0] },\n  en: { cardinal: f[4], ordinal: f[39] },\n  eo: { cardinal: f[0] },\n  es: { cardinal: f[0] },\n  et: { cardinal: f[4] },\n  eu: { cardinal: f[0] },\n  fa: { cardinal: f[2] },\n  ff: { cardinal: f[12] },\n  fi: { cardinal: f[4] },\n  fil: { cardinal: f[13], ordinal: f[0] },\n  fo: { cardinal: f[0] },\n  fr: { cardinal: f[12], ordinal: f[0] },\n  fur: { cardinal: f[0] },\n  fy: { cardinal: f[4] },\n  ga: { cardinal: f[14], ordinal: f[0] },\n  gd: { cardinal: f[15], ordinal: f[40] },\n  gl: { cardinal: f[4] },\n  gsw: { cardinal: f[0] },\n  gu: { cardinal: f[2], ordinal: f[41] },\n  guw: { cardinal: f[1] },\n  gv: { cardinal: f[16] },\n  ha: { cardinal: f[0] },\n  haw: { cardinal: f[0] },\n  he: { cardinal: f[17] },\n  hi: { cardinal: f[2], ordinal: f[41] },\n  hr: { cardinal: f[7] },\n  hsb: { cardinal: f[11] },\n  hu: { cardinal: f[0], ordinal: f[42] },\n  hy: { cardinal: f[12], ordinal: f[0] },\n  ia: { cardinal: f[4] },\n  io: { cardinal: f[4] },\n  is: { cardinal: f[18] },\n  it: { cardinal: f[4], ordinal: f[43] },\n  iu: { cardinal: f[19] },\n  iw: { cardinal: f[17] },\n  jgo: { cardinal: f[0] },\n  ji: { cardinal: f[4] },\n  jmc: { cardinal: f[0] },\n  ka: { cardinal: f[0], ordinal: f[44] },\n  kab: { cardinal: f[12] },\n  kaj: { cardinal: f[0] },\n  kcg: { cardinal: f[0] },\n  kk: { cardinal: f[0], ordinal: f[45] },\n  kkj: { cardinal: f[0] },\n  kl: { cardinal: f[0] },\n  kn: { cardinal: f[2] },\n  ks: { cardinal: f[0] },\n  ksb: { cardinal: f[0] },\n  ksh: { cardinal: f[20] },\n  ku: { cardinal: f[0] },\n  kw: { cardinal: f[19] },\n  ky: { cardinal: f[0] },\n  lag: { cardinal: f[21] },\n  lb: { cardinal: f[0] },\n  lg: { cardinal: f[0] },\n  ln: { cardinal: f[1] },\n  lt: { cardinal: f[22] },\n  lv: { cardinal: f[23] },\n  mas: { cardinal: f[0] },\n  mg: { cardinal: f[1] },\n  mgo: { cardinal: f[0] },\n  mk: { cardinal: f[24], ordinal: f[46] },\n  ml: { cardinal: f[0] },\n  mn: { cardinal: f[0] },\n  mo: { cardinal: f[25], ordinal: f[0] },\n  mr: { cardinal: f[2], ordinal: f[47] },\n  mt: { cardinal: f[26] },\n  nah: { cardinal: f[0] },\n  naq: { cardinal: f[19] },\n  nb: { cardinal: f[0] },\n  nd: { cardinal: f[0] },\n  ne: { cardinal: f[0], ordinal: f[48] },\n  nl: { cardinal: f[4] },\n  nn: { cardinal: f[0] },\n  nnh: { cardinal: f[0] },\n  no: { cardinal: f[0] },\n  nr: { cardinal: f[0] },\n  nso: { cardinal: f[1] },\n  ny: { cardinal: f[0] },\n  nyn: { cardinal: f[0] },\n  om: { cardinal: f[0] },\n  or: { cardinal: f[0], ordinal: f[49] },\n  os: { cardinal: f[0] },\n  pa: { cardinal: f[1] },\n  pap: { cardinal: f[0] },\n  pl: { cardinal: f[27] },\n  prg: { cardinal: f[23] },\n  ps: { cardinal: f[0] },\n  pt: { cardinal: f[28] },\n  'pt-PT': { cardinal: f[4] },\n  rm: { cardinal: f[0] },\n  ro: { cardinal: f[25], ordinal: f[0] },\n  rof: { cardinal: f[0] },\n  ru: { cardinal: f[29] },\n  rwk: { cardinal: f[0] },\n  saq: { cardinal: f[0] },\n  sc: { cardinal: f[4], ordinal: f[43] },\n  scn: { cardinal: f[4], ordinal: f[43] },\n  sd: { cardinal: f[0] },\n  sdh: { cardinal: f[0] },\n  se: { cardinal: f[19] },\n  seh: { cardinal: f[0] },\n  sh: { cardinal: f[7] },\n  shi: { cardinal: f[30] },\n  si: { cardinal: f[31] },\n  sk: { cardinal: f[8] },\n  sl: { cardinal: f[32] },\n  sma: { cardinal: f[19] },\n  smi: { cardinal: f[19] },\n  smj: { cardinal: f[19] },\n  smn: { cardinal: f[19] },\n  sms: { cardinal: f[19] },\n  sn: { cardinal: f[0] },\n  so: { cardinal: f[0] },\n  sq: { cardinal: f[0], ordinal: f[50] },\n  sr: { cardinal: f[7] },\n  ss: { cardinal: f[0] },\n  ssy: { cardinal: f[0] },\n  st: { cardinal: f[0] },\n  sv: { cardinal: f[4], ordinal: f[51] },\n  sw: { cardinal: f[4] },\n  syr: { cardinal: f[0] },\n  ta: { cardinal: f[0] },\n  te: { cardinal: f[0] },\n  teo: { cardinal: f[0] },\n  ti: { cardinal: f[1] },\n  tig: { cardinal: f[0] },\n  tk: { cardinal: f[0], ordinal: f[52] },\n  tl: { cardinal: f[13], ordinal: f[0] },\n  tn: { cardinal: f[0] },\n  tr: { cardinal: f[0] },\n  ts: { cardinal: f[0] },\n  tzm: { cardinal: f[33] },\n  ug: { cardinal: f[0] },\n  uk: { cardinal: f[29], ordinal: f[53] },\n  ur: { cardinal: f[4] },\n  uz: { cardinal: f[0] },\n  ve: { cardinal: f[0] },\n  vo: { cardinal: f[0] },\n  vun: { cardinal: f[0] },\n  wa: { cardinal: f[1] },\n  wae: { cardinal: f[0] },\n  xh: { cardinal: f[0] },\n  xog: { cardinal: f[0] },\n  yi: { cardinal: f[4] },\n  zu: { cardinal: f[2] },\n  lo: { ordinal: f[0] },\n  ms: { ordinal: f[0] },\n  vi: { ordinal: f[0] }\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/format-message-interpret/plurals.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/format-message-parse/index.js":
/*!****************************************************************!*\
  !*** ../scratch-vm/node_modules/format-message-parse/index.js ***!
  \****************************************************************/
/***/ ((module, exports) => {

"use strict";
eval("// @flow\n\n\n/*::\nexport type AST = Element[]\nexport type Element = string | Placeholder\nexport type Placeholder = Plural | Styled | Typed | Simple\nexport type Plural = [ string, 'plural' | 'selectordinal', number, SubMessages ]\nexport type Styled = [ string, string, string | SubMessages ]\nexport type Typed = [ string, string ]\nexport type Simple = [ string ]\nexport type SubMessages = { [string]: AST }\nexport type Token = [ TokenType, string ]\nexport type TokenType = 'text' | 'space' | 'id' | 'type' | 'style' | 'offset' | 'number' | 'selector' | 'syntax'\ntype Context = {|\n  pattern: string,\n  index: number,\n  tagsType: ?string,\n  tokens: ?Token[]\n|}\n*/\n\nvar ARG_OPN = '{'\nvar ARG_CLS = '}'\nvar ARG_SEP = ','\nvar NUM_ARG = '#'\nvar TAG_OPN = '<'\nvar TAG_CLS = '>'\nvar TAG_END = '</'\nvar TAG_SELF_CLS = '/>'\nvar ESC = '\\''\nvar OFFSET = 'offset:'\nvar simpleTypes = [\n  'number',\n  'date',\n  'time',\n  'ordinal',\n  'duration',\n  'spellout'\n]\nvar submTypes = [\n  'plural',\n  'select',\n  'selectordinal'\n]\n\n/**\n * parse\n *\n * Turns this:\n *  `You have { numBananas, plural,\n *       =0 {no bananas}\n *      one {a banana}\n *    other {# bananas}\n *  } for sale`\n *\n * into this:\n *  [ \"You have \", [ \"numBananas\", \"plural\", 0, {\n *       \"=0\": [ \"no bananas\" ],\n *      \"one\": [ \"a banana\" ],\n *    \"other\": [ [ '#' ], \" bananas\" ]\n *  } ], \" for sale.\" ]\n *\n * tokens:\n *  [\n *    [ \"text\", \"You have \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"space\", \" \" ],\n *    [ \"id\", \"numBananas\" ],\n *    [ \"syntax\", \", \" ],\n *    [ \"space\", \" \" ],\n *    [ \"type\", \"plural\" ],\n *    [ \"syntax\", \",\" ],\n *    [ \"space\", \"\\n     \" ],\n *    [ \"selector\", \"=0\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"text\", \"no bananas\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n    \" ],\n *    [ \"selector\", \"one\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"text\", \"a banana\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n  \" ],\n *    [ \"selector\", \"other\" ],\n *    [ \"space\", \" \" ],\n *    [ \"syntax\", \"{\" ],\n *    [ \"syntax\", \"#\" ],\n *    [ \"text\", \" bananas\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"space\", \"\\n\" ],\n *    [ \"syntax\", \"}\" ],\n *    [ \"text\", \" for sale.\" ]\n *  ]\n **/\nexports = module.exports = function parse (\n  pattern/*: string */,\n  options/*:: ?: { tagsType?: string, tokens?: Token[] } */\n)/*: AST */ {\n  return parseAST({\n    pattern: String(pattern),\n    index: 0,\n    tagsType: (options && options.tagsType) || null,\n    tokens: (options && options.tokens) || null\n  }, '')\n}\n\nfunction parseAST (current/*: Context */, parentType/*: string */)/*: AST */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var elements/*: AST */ = []\n  var start = current.index\n  var text = parseText(current, parentType)\n  if (text) elements.push(text)\n  if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)])\n  while (current.index < length) {\n    if (pattern[current.index] === ARG_CLS) {\n      if (!parentType) throw expected(current)\n      break\n    }\n    if (parentType && current.tagsType && pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) break\n    elements.push(parsePlaceholder(current))\n    start = current.index\n    text = parseText(current, parentType)\n    if (text) elements.push(text)\n    if (text && current.tokens) current.tokens.push(['text', pattern.slice(start, current.index)])\n  }\n  return elements\n}\n\nfunction parseText (current/*: Context */, parentType/*: string */)/*: string */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var isHashSpecial = (parentType === 'plural' || parentType === 'selectordinal')\n  var isAngleSpecial = !!current.tagsType\n  var isArgStyle = (parentType === '{style}')\n  var text = ''\n  while (current.index < length) {\n    var char = pattern[current.index]\n    if (\n      char === ARG_OPN || char === ARG_CLS ||\n      (isHashSpecial && char === NUM_ARG) ||\n      (isAngleSpecial && char === TAG_OPN) ||\n      (isArgStyle && isWhitespace(char.charCodeAt(0)))\n    ) {\n      break\n    } else if (char === ESC) {\n      char = pattern[++current.index]\n      if (char === ESC) { // double is always 1 '\n        text += char\n        ++current.index\n      } else if (\n        // only when necessary\n        char === ARG_OPN || char === ARG_CLS ||\n        (isHashSpecial && char === NUM_ARG) ||\n        (isAngleSpecial && char === TAG_OPN) ||\n        isArgStyle\n      ) {\n        text += char\n        while (++current.index < length) {\n          char = pattern[current.index]\n          if (char === ESC && pattern[current.index + 1] === ESC) { // double is always 1 '\n            text += ESC\n            ++current.index\n          } else if (char === ESC) { // end of quoted\n            ++current.index\n            break\n          } else {\n            text += char\n          }\n        }\n      } else { // lone ' is just a '\n        text += ESC\n        // already incremented\n      }\n    } else {\n      text += char\n      ++current.index\n    }\n  }\n  return text\n}\n\nfunction isWhitespace (code/*: number */)/*: boolean */ {\n  return (\n    (code >= 0x09 && code <= 0x0D) ||\n    code === 0x20 || code === 0x85 || code === 0xA0 || code === 0x180E ||\n    (code >= 0x2000 && code <= 0x200D) ||\n    code === 0x2028 || code === 0x2029 || code === 0x202F || code === 0x205F ||\n    code === 0x2060 || code === 0x3000 || code === 0xFEFF\n  )\n}\n\nfunction skipWhitespace (current/*: Context */)/*: void */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var start = current.index\n  while (current.index < length && isWhitespace(pattern.charCodeAt(current.index))) {\n    ++current.index\n  }\n  if (start < current.index && current.tokens) {\n    current.tokens.push(['space', current.pattern.slice(start, current.index)])\n  }\n}\n\nfunction parsePlaceholder (current/*: Context */)/*: Placeholder */ {\n  var pattern = current.pattern\n  if (pattern[current.index] === NUM_ARG) {\n    if (current.tokens) current.tokens.push(['syntax', NUM_ARG])\n    ++current.index // move passed #\n    return [NUM_ARG]\n  }\n\n  var tag = parseTag(current)\n  if (tag) return tag\n\n  /* istanbul ignore if should be unreachable if parseAST and parseText are right */\n  if (pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN)\n  if (current.tokens) current.tokens.push(['syntax', ARG_OPN])\n  ++current.index // move passed {\n  skipWhitespace(current)\n\n  var id = parseId(current)\n  if (!id) throw expected(current, 'placeholder id')\n  if (current.tokens) current.tokens.push(['id', id])\n  skipWhitespace(current)\n\n  var char = pattern[current.index]\n  if (char === ARG_CLS) { // end placeholder\n    if (current.tokens) current.tokens.push(['syntax', ARG_CLS])\n    ++current.index // move passed }\n    return [id]\n  }\n\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', ARG_SEP])\n  ++current.index // move passed ,\n  skipWhitespace(current)\n\n  var type = parseId(current)\n  if (!type) throw expected(current, 'placeholder type')\n  if (current.tokens) current.tokens.push(['type', type])\n  skipWhitespace(current)\n  char = pattern[current.index]\n  if (char === ARG_CLS) { // end placeholder\n    if (current.tokens) current.tokens.push(['syntax', ARG_CLS])\n    if (type === 'plural' || type === 'selectordinal' || type === 'select') {\n      throw expected(current, type + ' sub-messages')\n    }\n    ++current.index // move passed }\n    return [id, type]\n  }\n\n  if (char !== ARG_SEP) throw expected(current, ARG_SEP + ' or ' + ARG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', ARG_SEP])\n  ++current.index // move passed ,\n  skipWhitespace(current)\n\n  var arg\n  if (type === 'plural' || type === 'selectordinal') {\n    var offset = parsePluralOffset(current)\n    skipWhitespace(current)\n    arg = [id, type, offset, parseSubMessages(current, type)]\n  } else if (type === 'select') {\n    arg = [id, type, parseSubMessages(current, type)]\n  } else if (simpleTypes.indexOf(type) >= 0) {\n    arg = [id, type, parseSimpleFormat(current)]\n  } else { // custom placeholder type\n    var index = current.index\n    var format/*: string | SubMessages */ = parseSimpleFormat(current)\n    skipWhitespace(current)\n    if (pattern[current.index] === ARG_OPN) {\n      current.index = index // rewind, since should have been submessages\n      format = parseSubMessages(current, type)\n    }\n    arg = [id, type, format]\n  }\n\n  skipWhitespace(current)\n  if (pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', ARG_CLS])\n  ++current.index // move passed }\n  return arg\n}\n\nfunction parseTag (current/*: Context */)/*: ?Placeholder */ {\n  var tagsType = current.tagsType\n  if (!tagsType || current.pattern[current.index] !== TAG_OPN) return\n\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) === TAG_END) {\n    throw expected(current, null, 'closing tag without matching opening tag')\n  }\n  if (current.tokens) current.tokens.push(['syntax', TAG_OPN])\n  ++current.index // move passed <\n\n  var id = parseId(current, true)\n  if (!id) throw expected(current, 'placeholder id')\n  if (current.tokens) current.tokens.push(['id', id])\n  skipWhitespace(current)\n\n  if (current.pattern.slice(current.index, current.index + TAG_SELF_CLS.length) === TAG_SELF_CLS) {\n    if (current.tokens) current.tokens.push(['syntax', TAG_SELF_CLS])\n    current.index += TAG_SELF_CLS.length\n    return [id, tagsType]\n  }\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', TAG_CLS])\n  ++current.index // move passed >\n\n  var children = parseAST(current, tagsType)\n\n  var end = current.index\n  if (current.pattern.slice(current.index, current.index + TAG_END.length) !== TAG_END) throw expected(current, TAG_END + id + TAG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', TAG_END])\n  current.index += TAG_END.length\n  var closeId = parseId(current, true)\n  if (closeId && current.tokens) current.tokens.push(['id', closeId])\n  if (id !== closeId) {\n    current.index = end // rewind for better error message\n    throw expected(current, TAG_END + id + TAG_CLS, TAG_END + closeId + TAG_CLS)\n  }\n  skipWhitespace(current)\n  if (current.pattern[current.index] !== TAG_CLS) throw expected(current, TAG_CLS)\n  if (current.tokens) current.tokens.push(['syntax', TAG_CLS])\n  ++current.index // move passed >\n\n  return [id, tagsType, { children: children }]\n}\n\nfunction parseId (current/*: Context */, isTag/*:: ?: boolean */)/*: string */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var id = ''\n  while (current.index < length) {\n    var char = pattern[current.index]\n    if (\n      char === ARG_OPN || char === ARG_CLS || char === ARG_SEP ||\n      char === NUM_ARG || char === ESC || isWhitespace(char.charCodeAt(0)) ||\n      (isTag && (char === TAG_OPN || char === TAG_CLS || char === '/'))\n    ) break\n    id += char\n    ++current.index\n  }\n  return id\n}\n\nfunction parseSimpleFormat (current/*: Context */)/*: string */ {\n  var start = current.index\n  var style = parseText(current, '{style}')\n  if (!style) throw expected(current, 'placeholder style name')\n  if (current.tokens) current.tokens.push(['style', current.pattern.slice(start, current.index)])\n  return style\n}\n\nfunction parsePluralOffset (current/*: Context */)/*: number */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var offset = 0\n  if (pattern.slice(current.index, current.index + OFFSET.length) === OFFSET) {\n    if (current.tokens) current.tokens.push(['offset', 'offset'], ['syntax', ':'])\n    current.index += OFFSET.length // move passed offset:\n    skipWhitespace(current)\n    var start = current.index\n    while (current.index < length && isDigit(pattern.charCodeAt(current.index))) {\n      ++current.index\n    }\n    if (start === current.index) throw expected(current, 'offset number')\n    if (current.tokens) current.tokens.push(['number', pattern.slice(start, current.index)])\n    offset = +pattern.slice(start, current.index)\n  }\n  return offset\n}\n\nfunction isDigit (code/*: number */)/*: boolean */ {\n  return (code >= 0x30 && code <= 0x39)\n}\n\nfunction parseSubMessages (current/*: Context */, parentType/*: string */)/*: SubMessages */ {\n  var pattern = current.pattern\n  var length = pattern.length\n  var options/*: SubMessages */ = {}\n  while (current.index < length && pattern[current.index] !== ARG_CLS) {\n    var selector = parseId(current)\n    if (!selector) throw expected(current, 'sub-message selector')\n    if (current.tokens) current.tokens.push(['selector', selector])\n    skipWhitespace(current)\n    options[selector] = parseSubMessage(current, parentType)\n    skipWhitespace(current)\n  }\n  if (!options.other && submTypes.indexOf(parentType) >= 0) {\n    throw expected(current, null, null, '\"other\" sub-message must be specified in ' + parentType)\n  }\n  return options\n}\n\nfunction parseSubMessage (current/*: Context */, parentType/*: string */)/*: AST */ {\n  if (current.pattern[current.index] !== ARG_OPN) throw expected(current, ARG_OPN + ' to start sub-message')\n  if (current.tokens) current.tokens.push(['syntax', ARG_OPN])\n  ++current.index // move passed {\n  var message = parseAST(current, parentType)\n  if (current.pattern[current.index] !== ARG_CLS) throw expected(current, ARG_CLS + ' to end sub-message')\n  if (current.tokens) current.tokens.push(['syntax', ARG_CLS])\n  ++current.index // move passed }\n  return message\n}\n\nfunction expected (current/*: Context */, expected/*:: ?: ?string */, found/*:: ?: ?string */, message/*:: ?: string */) {\n  var pattern = current.pattern\n  var lines = pattern.slice(0, current.index).split(/\\r?\\n/)\n  var offset = current.index\n  var line = lines.length\n  var column = lines.slice(-1)[0].length\n  found = found || (\n    (current.index >= pattern.length) ? 'end of message pattern'\n      : (parseId(current) || pattern[current.index])\n  )\n  if (!message) message = errorMessage(expected, found)\n  message += ' in ' + pattern.replace(/\\r?\\n/g, '\\n')\n  return new SyntaxError(message, expected, found, offset, line, column)\n}\n\nfunction errorMessage (expected/*: ?string */, found/* string */) {\n  if (!expected) return 'Unexpected ' + found + ' found'\n  return 'Expected ' + expected + ' but found ' + found\n}\n\n/**\n * SyntaxError\n *  Holds information about bad syntax found in a message pattern\n **/\nfunction SyntaxError (message/*: string */, expected/*: ?string */, found/*: ?string */, offset/*: number */, line/*: number */, column/*: number */) {\n  Error.call(this, message)\n  this.name = 'SyntaxError'\n  this.message = message\n  this.expected = expected\n  this.found = found\n  this.offset = offset\n  this.line = line\n  this.column = column\n}\nSyntaxError.prototype = Object.create(Error.prototype)\nexports.SyntaxError = SyntaxError\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/format-message-parse/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/format-message/index.js":
/*!**********************************************************!*\
  !*** ../scratch-vm/node_modules/format-message/index.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("// @flow\n\nvar parse = __webpack_require__(/*! format-message-parse */ \"../scratch-vm/node_modules/format-message-parse/index.js\")\nvar interpret = __webpack_require__(/*! format-message-interpret */ \"../scratch-vm/node_modules/format-message-interpret/index.js\")\nvar plurals = __webpack_require__(/*! format-message-interpret/plurals */ \"../scratch-vm/node_modules/format-message-interpret/plurals.js\")\nvar lookupClosestLocale = __webpack_require__(/*! lookup-closest-locale */ \"../scratch-vm/node_modules/lookup-closest-locale/index.js\")\nvar origFormats = __webpack_require__(/*! format-message-formats */ \"../scratch-vm/node_modules/format-message-formats/index.js\")\n\n/*::\nimport type { Types } from 'format-message-interpret'\ntype Locale = string\ntype Locales = Locale | Locale[]\ntype Message = string | {|\n  id?: string,\n  default: string,\n  description?: string\n|}\ntype Translations = { [string]: ?{ [string]: string | Translation } }\ntype Translation = {\n  message: string,\n  format?: (args?: Object) => string,\n  toParts?: (args?: Object) => any[],\n}\ntype Replacement = ?string | (string, string, locales?: Locales) => ?string\ntype GenerateId = (string) => string\ntype MissingTranslation = 'ignore' | 'warning' | 'error'\ntype FormatObject = { [string]: * }\ntype Options = {\n  locale?: Locales,\n  translations?: ?Translations,\n  generateId?: GenerateId,\n  missingReplacement?: Replacement,\n  missingTranslation?: MissingTranslation,\n  formats?: {\n    number?: FormatObject,\n    date?: FormatObject,\n    time?: FormatObject\n  },\n  types?: Types\n}\ntype Setup = {|\n  locale: Locales,\n  translations: Translations,\n  generateId: GenerateId,\n  missingReplacement: Replacement,\n  missingTranslation: MissingTranslation,\n  formats: {\n    number: FormatObject,\n    date: FormatObject,\n    time: FormatObject\n  },\n  types: Types\n|}\ntype FormatMessage = {\n  (msg: Message, args?: Object, locales?: Locales): string,\n  rich (msg: Message, args?: Object, locales?: Locales): any[],\n  setup (opt?: Options): Setup,\n  number (value: number, style?: string, locales?: Locales): string,\n  date (value: number | Date, style?: string, locales?: Locales): string,\n  time (value: number | Date, style?: string, locales?: Locales): string,\n  select (value: any, options: Object): any,\n  custom (placeholder: any[], locales: Locales, value: any, args: Object): any,\n  plural (value: number, offset: any, options: any, locale: any): any,\n  selectordinal (value: number, offset: any, options: any, locale: any): any,\n  namespace (): FormatMessage\n}\n*/\n\nfunction assign/*:: <T: Object> */ (target/*: T */, source/*: Object */) {\n  Object.keys(source).forEach(function (key) { target[key] = source[key] })\n  return target\n}\n\nfunction namespace ()/*: FormatMessage */ {\n  var formats = assign({}, origFormats)\n  var currentLocales/*: Locales */ = 'en'\n  var translations/*: Translations */ = {}\n  var generateId/*: GenerateId */ = function (pattern) { return pattern }\n  var missingReplacement/*: Replacement */ = null\n  var missingTranslation/*: MissingTranslation */ = 'warning'\n  var types/*: Types */ = {}\n\n  function formatMessage (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {\n    var pattern = typeof msg === 'string' ? msg : msg.default\n    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)\n    var translated = translate(pattern, id, locales || currentLocales)\n    var format = translated.format || (\n      translated.format = interpret(parse(translated.message), locales || currentLocales, types)\n    )\n    return format(args)\n  }\n\n  formatMessage.rich = function rich (msg/*: Message */, args/*:: ?: Object */, locales/*:: ?: Locales */) {\n    var pattern = typeof msg === 'string' ? msg : msg.default\n    var id = (typeof msg === 'object' && msg.id) || generateId(pattern)\n    var translated = translate(pattern, id, locales || currentLocales)\n    var format = translated.toParts || (\n      translated.toParts = interpret.toParts(parse(translated.message, { tagsType: tagsType }), locales || currentLocales, types)\n    )\n    return format(args)\n  }\n\n  var tagsType = '<>'\n  function richType (node/*: any[] */, locales/*: Locales */) {\n    var style = node[2]\n    return function (fn, args) {\n      var props = typeof style === 'object' ? mapObject(style, args) : style\n      return typeof fn === 'function' ? fn(props) : fn\n    }\n  }\n  types[tagsType] = richType\n\n  function mapObject (object/* { [string]: (args?: Object) => any } */, args/*: ?Object */) {\n    return Object.keys(object).reduce(function (mapped, key) {\n      mapped[key] = object[key](args)\n      return mapped\n    }, {})\n  }\n\n  function translate (pattern/*: string */, id/*: string */, locales/*: Locales */)/*: Translation */ {\n    var locale = lookupClosestLocale(locales, translations) || 'en'\n    var messages = translations[locale] || (translations[locale] = {})\n    var translated = messages[id]\n    if (typeof translated === 'string') {\n      translated = messages[id] = { message: translated }\n    }\n    if (!translated) {\n      var message = 'Translation for \"' + id + '\" in \"' + locale + '\" is missing'\n      if (missingTranslation === 'warning') {\n        /* istanbul ignore else */\n        if (typeof console !== 'undefined') console.warn(message)\n      } else if (missingTranslation !== 'ignore') { // 'error'\n        throw new Error(message)\n      }\n      var replacement = typeof missingReplacement === 'function'\n        ? missingReplacement(pattern, id, locale) || pattern\n        : missingReplacement || pattern\n      translated = messages[id] = { message: replacement }\n    }\n    return translated\n  }\n\n  formatMessage.setup = function setup (opt/*:: ?: Options */) {\n    opt = opt || {}\n    if (opt.locale) currentLocales = opt.locale\n    if ('translations' in opt) translations = opt.translations || {}\n    if (opt.generateId) generateId = opt.generateId\n    if ('missingReplacement' in opt) missingReplacement = opt.missingReplacement\n    if (opt.missingTranslation) missingTranslation = opt.missingTranslation\n    if (opt.formats) {\n      if (opt.formats.number) assign(formats.number, opt.formats.number)\n      if (opt.formats.date) assign(formats.date, opt.formats.date)\n      if (opt.formats.time) assign(formats.time, opt.formats.time)\n    }\n    if (opt.types) {\n      types = opt.types\n      types[tagsType] = richType\n    }\n    return {\n      locale: currentLocales,\n      translations: translations,\n      generateId: generateId,\n      missingReplacement: missingReplacement,\n      missingTranslation: missingTranslation,\n      formats: formats,\n      types: types\n    }\n  }\n\n  formatMessage.number = function (value/*: number */, style/*:: ?: string */, locales/*:: ?: Locales */) {\n    var options = (style && formats.number[style]) ||\n      formats.parseNumberPattern(style) ||\n      formats.number.default\n    return new Intl.NumberFormat(locales || currentLocales, options).format(value)\n  }\n\n  formatMessage.date = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {\n    var options = (style && formats.date[style]) ||\n      formats.parseDatePattern(style) ||\n      formats.date.default\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)\n  }\n\n  formatMessage.time = function (value/*:: ?: number | Date */, style/*:: ?: string */, locales/*:: ?: Locales */) {\n    var options = (style && formats.time[style]) ||\n      formats.parseDatePattern(style) ||\n      formats.time.default\n    return new Intl.DateTimeFormat(locales || currentLocales, options).format(value)\n  }\n\n  formatMessage.select = function (value/*: any */, options/*: Object */) {\n    return options[value] || options.other\n  }\n\n  formatMessage.custom = function (placeholder/*: any[] */, locales/*: Locales */, value/*: any */, args/*: Object */) {\n    if (!(placeholder[1] in types)) return value\n    return types[placeholder[1]](placeholder, locales)(value, args)\n  }\n\n  formatMessage.plural = plural.bind(null, 'cardinal')\n  formatMessage.selectordinal = plural.bind(null, 'ordinal')\n  function plural (\n    pluralType/*: 'cardinal' | 'ordinal' */,\n    value/*: number */,\n    offset/*: any */,\n    options/*: any */,\n    locale/*: any */\n  ) {\n    if (typeof offset === 'object' && typeof options !== 'object') { // offset is optional\n      locale = options\n      options = offset\n      offset = 0\n    }\n    var closest = lookupClosestLocale(locale || currentLocales, plurals)\n    var plural = (closest && plurals[closest][pluralType]) || returnOther\n    return options['=' + +value] || options[plural(value - offset)] || options.other\n  }\n  function returnOther (/*:: n:number */) { return 'other' }\n\n  formatMessage.namespace = namespace\n\n  return formatMessage\n}\n\nmodule.exports = exports = namespace()\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/format-message/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/CollectingHandler.js":
/*!***********************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/CollectingHandler.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = CollectingHandler;\n\nfunction CollectingHandler(cbs) {\n    this._cbs = cbs || {};\n    this.events = [];\n}\n\nvar EVENTS = (__webpack_require__(/*! ./ */ \"../scratch-vm/node_modules/htmlparser2/lib/index.js\").EVENTS);\nObject.keys(EVENTS).forEach(function(name) {\n    if (EVENTS[name] === 0) {\n        name = \"on\" + name;\n        CollectingHandler.prototype[name] = function() {\n            this.events.push([name]);\n            if (this._cbs[name]) this._cbs[name]();\n        };\n    } else if (EVENTS[name] === 1) {\n        name = \"on\" + name;\n        CollectingHandler.prototype[name] = function(a) {\n            this.events.push([name, a]);\n            if (this._cbs[name]) this._cbs[name](a);\n        };\n    } else if (EVENTS[name] === 2) {\n        name = \"on\" + name;\n        CollectingHandler.prototype[name] = function(a, b) {\n            this.events.push([name, a, b]);\n            if (this._cbs[name]) this._cbs[name](a, b);\n        };\n    } else {\n        throw Error(\"wrong number of arguments\");\n    }\n});\n\nCollectingHandler.prototype.onreset = function() {\n    this.events = [];\n    if (this._cbs.onreset) this._cbs.onreset();\n};\n\nCollectingHandler.prototype.restart = function() {\n    if (this._cbs.onreset) this._cbs.onreset();\n\n    for (var i = 0, len = this.events.length; i < len; i++) {\n        if (this._cbs[this.events[i][0]]) {\n            var num = this.events[i].length;\n\n            if (num === 1) {\n                this._cbs[this.events[i][0]]();\n            } else if (num === 2) {\n                this._cbs[this.events[i][0]](this.events[i][1]);\n            } else {\n                this._cbs[this.events[i][0]](\n                    this.events[i][1],\n                    this.events[i][2]\n                );\n            }\n        }\n    }\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/CollectingHandler.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/FeedHandler.js":
/*!*****************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/FeedHandler.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var DomHandler = __webpack_require__(/*! domhandler */ \"../scratch-vm/node_modules/domhandler/index.js\");\nvar DomUtils = __webpack_require__(/*! domutils */ \"../scratch-vm/node_modules/domutils/index.js\");\n\n//TODO: make this a streamable handler\nfunction FeedHandler(callback, options) {\n    this.init(callback, options);\n}\n\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(FeedHandler, DomHandler);\n\nFeedHandler.prototype.init = DomHandler;\n\nfunction getElements(what, where) {\n    return DomUtils.getElementsByTagName(what, where, true);\n}\nfunction getOneElement(what, where) {\n    return DomUtils.getElementsByTagName(what, where, true, 1)[0];\n}\nfunction fetch(what, where, recurse) {\n    return DomUtils.getText(\n        DomUtils.getElementsByTagName(what, where, recurse, 1)\n    ).trim();\n}\n\nfunction addConditionally(obj, prop, what, where, recurse) {\n    var tmp = fetch(what, where, recurse);\n    if (tmp) obj[prop] = tmp;\n}\n\nvar isValidFeed = function(value) {\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n};\n\nFeedHandler.prototype.onend = function() {\n    var feed = {},\n        feedRoot = getOneElement(isValidFeed, this.dom),\n        tmp,\n        childs;\n\n    if (feedRoot) {\n        if (feedRoot.name === \"feed\") {\n            childs = feedRoot.children;\n\n            feed.type = \"atom\";\n            addConditionally(feed, \"id\", \"id\", childs);\n            addConditionally(feed, \"title\", \"title\", childs);\n            if (\n                (tmp = getOneElement(\"link\", childs)) &&\n                (tmp = tmp.attribs) &&\n                (tmp = tmp.href)\n            )\n                feed.link = tmp;\n            addConditionally(feed, \"description\", \"subtitle\", childs);\n            if ((tmp = fetch(\"updated\", childs))) feed.updated = new Date(tmp);\n            addConditionally(feed, \"author\", \"email\", childs, true);\n\n            feed.items = getElements(\"entry\", childs).map(function(item) {\n                var entry = {},\n                    tmp;\n\n                item = item.children;\n\n                addConditionally(entry, \"id\", \"id\", item);\n                addConditionally(entry, \"title\", \"title\", item);\n                if (\n                    (tmp = getOneElement(\"link\", item)) &&\n                    (tmp = tmp.attribs) &&\n                    (tmp = tmp.href)\n                )\n                    entry.link = tmp;\n                if ((tmp = fetch(\"summary\", item) || fetch(\"content\", item)))\n                    entry.description = tmp;\n                if ((tmp = fetch(\"updated\", item)))\n                    entry.pubDate = new Date(tmp);\n                return entry;\n            });\n        } else {\n            childs = getOneElement(\"channel\", feedRoot.children).children;\n\n            feed.type = feedRoot.name.substr(0, 3);\n            feed.id = \"\";\n            addConditionally(feed, \"title\", \"title\", childs);\n            addConditionally(feed, \"link\", \"link\", childs);\n            addConditionally(feed, \"description\", \"description\", childs);\n            if ((tmp = fetch(\"lastBuildDate\", childs)))\n                feed.updated = new Date(tmp);\n            addConditionally(feed, \"author\", \"managingEditor\", childs, true);\n\n            feed.items = getElements(\"item\", feedRoot.children).map(function(\n                item\n            ) {\n                var entry = {},\n                    tmp;\n\n                item = item.children;\n\n                addConditionally(entry, \"id\", \"guid\", item);\n                addConditionally(entry, \"title\", \"title\", item);\n                addConditionally(entry, \"link\", \"link\", item);\n                addConditionally(entry, \"description\", \"description\", item);\n                if ((tmp = fetch(\"pubDate\", item)))\n                    entry.pubDate = new Date(tmp);\n                return entry;\n            });\n        }\n    }\n    this.dom = feed;\n    DomHandler.prototype._handleCallback.call(\n        this,\n        feedRoot ? null : Error(\"couldn't find root of feed\")\n    );\n};\n\nmodule.exports = FeedHandler;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/FeedHandler.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/Parser.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/Parser.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Tokenizer = __webpack_require__(/*! ./Tokenizer.js */ \"../scratch-vm/node_modules/htmlparser2/lib/Tokenizer.js\");\n\n/*\n\tOptions:\n\n\txmlMode: Disables the special behavior for script/style tags (false by default)\n\tlowerCaseAttributeNames: call .toLowerCase for each attribute name (true if xmlMode is `false`)\n\tlowerCaseTags: call .toLowerCase for each tag name (true if xmlMode is `false`)\n*/\n\n/*\n\tCallbacks:\n\n\toncdataend,\n\toncdatastart,\n\tonclosetag,\n\toncomment,\n\toncommentend,\n\tonerror,\n\tonopentag,\n\tonprocessinginstruction,\n\tonreset,\n\tontext\n*/\n\nvar formTags = {\n    input: true,\n    option: true,\n    optgroup: true,\n    select: true,\n    button: true,\n    datalist: true,\n    textarea: true\n};\n\nvar openImpliesClose = {\n    tr: { tr: true, th: true, td: true },\n    th: { th: true },\n    td: { thead: true, th: true, td: true },\n    body: { head: true, link: true, script: true },\n    li: { li: true },\n    p: { p: true },\n    h1: { p: true },\n    h2: { p: true },\n    h3: { p: true },\n    h4: { p: true },\n    h5: { p: true },\n    h6: { p: true },\n    select: formTags,\n    input: formTags,\n    output: formTags,\n    button: formTags,\n    datalist: formTags,\n    textarea: formTags,\n    option: { option: true },\n    optgroup: { optgroup: true }\n};\n\nvar voidElements = {\n    __proto__: null,\n    area: true,\n    base: true,\n    basefont: true,\n    br: true,\n    col: true,\n    command: true,\n    embed: true,\n    frame: true,\n    hr: true,\n    img: true,\n    input: true,\n    isindex: true,\n    keygen: true,\n    link: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\n\nvar foreignContextElements = {\n    __proto__: null,\n    math: true,\n    svg: true\n};\nvar htmlIntegrationElements = {\n    __proto__: null,\n    mi: true,\n    mo: true,\n    mn: true,\n    ms: true,\n    mtext: true,\n    \"annotation-xml\": true,\n    foreignObject: true,\n    desc: true,\n    title: true\n};\n\nvar re_nameEnd = /\\s|\\//;\n\nfunction Parser(cbs, options) {\n    this._options = options || {};\n    this._cbs = cbs || {};\n\n    this._tagname = \"\";\n    this._attribname = \"\";\n    this._attribvalue = \"\";\n    this._attribs = null;\n    this._stack = [];\n    this._foreignContext = [];\n\n    this.startIndex = 0;\n    this.endIndex = null;\n\n    this._lowerCaseTagNames =\n        \"lowerCaseTags\" in this._options\n            ? !!this._options.lowerCaseTags\n            : !this._options.xmlMode;\n    this._lowerCaseAttributeNames =\n        \"lowerCaseAttributeNames\" in this._options\n            ? !!this._options.lowerCaseAttributeNames\n            : !this._options.xmlMode;\n\n    if (this._options.Tokenizer) {\n        Tokenizer = this._options.Tokenizer;\n    }\n    this._tokenizer = new Tokenizer(this._options, this);\n\n    if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n}\n\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Parser, (__webpack_require__(/*! events */ \"events\").EventEmitter));\n\nParser.prototype._updatePosition = function(initialOffset) {\n    if (this.endIndex === null) {\n        if (this._tokenizer._sectionStart <= initialOffset) {\n            this.startIndex = 0;\n        } else {\n            this.startIndex = this._tokenizer._sectionStart - initialOffset;\n        }\n    } else this.startIndex = this.endIndex + 1;\n    this.endIndex = this._tokenizer.getAbsoluteIndex();\n};\n\n//Tokenizer event handlers\nParser.prototype.ontext = function(data) {\n    this._updatePosition(1);\n    this.endIndex--;\n\n    if (this._cbs.ontext) this._cbs.ontext(data);\n};\n\nParser.prototype.onopentagname = function(name) {\n    if (this._lowerCaseTagNames) {\n        name = name.toLowerCase();\n    }\n\n    this._tagname = name;\n\n    if (!this._options.xmlMode && name in openImpliesClose) {\n        for (\n            var el;\n            (el = this._stack[this._stack.length - 1]) in\n            openImpliesClose[name];\n            this.onclosetag(el)\n        );\n    }\n\n    if (this._options.xmlMode || !(name in voidElements)) {\n        this._stack.push(name);\n        if (name in foreignContextElements) this._foreignContext.push(true);\n        else if (name in htmlIntegrationElements)\n            this._foreignContext.push(false);\n    }\n\n    if (this._cbs.onopentagname) this._cbs.onopentagname(name);\n    if (this._cbs.onopentag) this._attribs = {};\n};\n\nParser.prototype.onopentagend = function() {\n    this._updatePosition(1);\n\n    if (this._attribs) {\n        if (this._cbs.onopentag)\n            this._cbs.onopentag(this._tagname, this._attribs);\n        this._attribs = null;\n    }\n\n    if (\n        !this._options.xmlMode &&\n        this._cbs.onclosetag &&\n        this._tagname in voidElements\n    ) {\n        this._cbs.onclosetag(this._tagname);\n    }\n\n    this._tagname = \"\";\n};\n\nParser.prototype.onclosetag = function(name) {\n    this._updatePosition(1);\n\n    if (this._lowerCaseTagNames) {\n        name = name.toLowerCase();\n    }\n    \n    if (name in foreignContextElements || name in htmlIntegrationElements) {\n        this._foreignContext.pop();\n    }\n\n    if (\n        this._stack.length &&\n        (!(name in voidElements) || this._options.xmlMode)\n    ) {\n        var pos = this._stack.lastIndexOf(name);\n        if (pos !== -1) {\n            if (this._cbs.onclosetag) {\n                pos = this._stack.length - pos;\n                while (pos--) this._cbs.onclosetag(this._stack.pop());\n            } else this._stack.length = pos;\n        } else if (name === \"p\" && !this._options.xmlMode) {\n            this.onopentagname(name);\n            this._closeCurrentTag();\n        }\n    } else if (!this._options.xmlMode && (name === \"br\" || name === \"p\")) {\n        this.onopentagname(name);\n        this._closeCurrentTag();\n    }\n};\n\nParser.prototype.onselfclosingtag = function() {\n    if (\n        this._options.xmlMode ||\n        this._options.recognizeSelfClosing ||\n        this._foreignContext[this._foreignContext.length - 1]\n    ) {\n        this._closeCurrentTag();\n    } else {\n        this.onopentagend();\n    }\n};\n\nParser.prototype._closeCurrentTag = function() {\n    var name = this._tagname;\n\n    this.onopentagend();\n\n    //self-closing tags will be on the top of the stack\n    //(cheaper check than in onclosetag)\n    if (this._stack[this._stack.length - 1] === name) {\n        if (this._cbs.onclosetag) {\n            this._cbs.onclosetag(name);\n        }\n        this._stack.pop();\n        \n    }\n};\n\nParser.prototype.onattribname = function(name) {\n    if (this._lowerCaseAttributeNames) {\n        name = name.toLowerCase();\n    }\n    this._attribname = name;\n};\n\nParser.prototype.onattribdata = function(value) {\n    this._attribvalue += value;\n};\n\nParser.prototype.onattribend = function() {\n    if (this._cbs.onattribute)\n        this._cbs.onattribute(this._attribname, this._attribvalue);\n    if (\n        this._attribs &&\n        !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname)\n    ) {\n        this._attribs[this._attribname] = this._attribvalue;\n    }\n    this._attribname = \"\";\n    this._attribvalue = \"\";\n};\n\nParser.prototype._getInstructionName = function(value) {\n    var idx = value.search(re_nameEnd),\n        name = idx < 0 ? value : value.substr(0, idx);\n\n    if (this._lowerCaseTagNames) {\n        name = name.toLowerCase();\n    }\n\n    return name;\n};\n\nParser.prototype.ondeclaration = function(value) {\n    if (this._cbs.onprocessinginstruction) {\n        var name = this._getInstructionName(value);\n        this._cbs.onprocessinginstruction(\"!\" + name, \"!\" + value);\n    }\n};\n\nParser.prototype.onprocessinginstruction = function(value) {\n    if (this._cbs.onprocessinginstruction) {\n        var name = this._getInstructionName(value);\n        this._cbs.onprocessinginstruction(\"?\" + name, \"?\" + value);\n    }\n};\n\nParser.prototype.oncomment = function(value) {\n    this._updatePosition(4);\n\n    if (this._cbs.oncomment) this._cbs.oncomment(value);\n    if (this._cbs.oncommentend) this._cbs.oncommentend();\n};\n\nParser.prototype.oncdata = function(value) {\n    this._updatePosition(1);\n\n    if (this._options.xmlMode || this._options.recognizeCDATA) {\n        if (this._cbs.oncdatastart) this._cbs.oncdatastart();\n        if (this._cbs.ontext) this._cbs.ontext(value);\n        if (this._cbs.oncdataend) this._cbs.oncdataend();\n    } else {\n        this.oncomment(\"[CDATA[\" + value + \"]]\");\n    }\n};\n\nParser.prototype.onerror = function(err) {\n    if (this._cbs.onerror) this._cbs.onerror(err);\n};\n\nParser.prototype.onend = function() {\n    if (this._cbs.onclosetag) {\n        for (\n            var i = this._stack.length;\n            i > 0;\n            this._cbs.onclosetag(this._stack[--i])\n        );\n    }\n    if (this._cbs.onend) this._cbs.onend();\n};\n\n//Resets the parser to a blank state, ready to parse a new HTML document\nParser.prototype.reset = function() {\n    if (this._cbs.onreset) this._cbs.onreset();\n    this._tokenizer.reset();\n\n    this._tagname = \"\";\n    this._attribname = \"\";\n    this._attribs = null;\n    this._stack = [];\n\n    if (this._cbs.onparserinit) this._cbs.onparserinit(this);\n};\n\n//Parses a complete HTML document and pushes it to the handler\nParser.prototype.parseComplete = function(data) {\n    this.reset();\n    this.end(data);\n};\n\nParser.prototype.write = function(chunk) {\n    this._tokenizer.write(chunk);\n};\n\nParser.prototype.end = function(chunk) {\n    this._tokenizer.end(chunk);\n};\n\nParser.prototype.pause = function() {\n    this._tokenizer.pause();\n};\n\nParser.prototype.resume = function() {\n    this._tokenizer.resume();\n};\n\n//alias for backwards compat\nParser.prototype.parseChunk = Parser.prototype.write;\nParser.prototype.done = Parser.prototype.end;\n\nmodule.exports = Parser;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/Parser.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/ProxyHandler.js":
/*!******************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/ProxyHandler.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = ProxyHandler;\n\nfunction ProxyHandler(cbs) {\n    this._cbs = cbs || {};\n}\n\nvar EVENTS = (__webpack_require__(/*! ./ */ \"../scratch-vm/node_modules/htmlparser2/lib/index.js\").EVENTS);\nObject.keys(EVENTS).forEach(function(name) {\n    if (EVENTS[name] === 0) {\n        name = \"on\" + name;\n        ProxyHandler.prototype[name] = function() {\n            if (this._cbs[name]) this._cbs[name]();\n        };\n    } else if (EVENTS[name] === 1) {\n        name = \"on\" + name;\n        ProxyHandler.prototype[name] = function(a) {\n            if (this._cbs[name]) this._cbs[name](a);\n        };\n    } else if (EVENTS[name] === 2) {\n        name = \"on\" + name;\n        ProxyHandler.prototype[name] = function(a, b) {\n            if (this._cbs[name]) this._cbs[name](a, b);\n        };\n    } else {\n        throw Error(\"wrong number of arguments\");\n    }\n});\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/ProxyHandler.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/Stream.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/Stream.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Stream;\n\nvar Parser = __webpack_require__(/*! ./WritableStream.js */ \"../scratch-vm/node_modules/htmlparser2/lib/WritableStream.js\");\n\nfunction Stream(options) {\n    Parser.call(this, new Cbs(this), options);\n}\n\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Stream, Parser);\n\nStream.prototype.readable = true;\n\nfunction Cbs(scope) {\n    this.scope = scope;\n}\n\nvar EVENTS = (__webpack_require__(/*! ../ */ \"../scratch-vm/node_modules/htmlparser2/lib/index.js\").EVENTS);\n\nObject.keys(EVENTS).forEach(function(name) {\n    if (EVENTS[name] === 0) {\n        Cbs.prototype[\"on\" + name] = function() {\n            this.scope.emit(name);\n        };\n    } else if (EVENTS[name] === 1) {\n        Cbs.prototype[\"on\" + name] = function(a) {\n            this.scope.emit(name, a);\n        };\n    } else if (EVENTS[name] === 2) {\n        Cbs.prototype[\"on\" + name] = function(a, b) {\n            this.scope.emit(name, a, b);\n        };\n    } else {\n        throw Error(\"wrong number of arguments!\");\n    }\n});\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/Stream.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/Tokenizer.js":
/*!***************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/Tokenizer.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Tokenizer;\n\nvar decodeCodePoint = __webpack_require__(/*! entities/lib/decode_codepoint.js */ \"../scratch-vm/node_modules/entities/lib/decode_codepoint.js\");\nvar entityMap = __webpack_require__(/*! entities/maps/entities.json */ \"../scratch-vm/node_modules/entities/maps/entities.json\");\nvar legacyMap = __webpack_require__(/*! entities/maps/legacy.json */ \"../scratch-vm/node_modules/entities/maps/legacy.json\");\nvar xmlMap = __webpack_require__(/*! entities/maps/xml.json */ \"../scratch-vm/node_modules/entities/maps/xml.json\");\n\nvar i = 0;\n\nvar TEXT = i++;\nvar BEFORE_TAG_NAME = i++; //after <\nvar IN_TAG_NAME = i++;\nvar IN_SELF_CLOSING_TAG = i++;\nvar BEFORE_CLOSING_TAG_NAME = i++;\nvar IN_CLOSING_TAG_NAME = i++;\nvar AFTER_CLOSING_TAG_NAME = i++;\n\n//attributes\nvar BEFORE_ATTRIBUTE_NAME = i++;\nvar IN_ATTRIBUTE_NAME = i++;\nvar AFTER_ATTRIBUTE_NAME = i++;\nvar BEFORE_ATTRIBUTE_VALUE = i++;\nvar IN_ATTRIBUTE_VALUE_DQ = i++; // \"\nvar IN_ATTRIBUTE_VALUE_SQ = i++; // '\nvar IN_ATTRIBUTE_VALUE_NQ = i++;\n\n//declarations\nvar BEFORE_DECLARATION = i++; // !\nvar IN_DECLARATION = i++;\n\n//processing instructions\nvar IN_PROCESSING_INSTRUCTION = i++; // ?\n\n//comments\nvar BEFORE_COMMENT = i++;\nvar IN_COMMENT = i++;\nvar AFTER_COMMENT_1 = i++;\nvar AFTER_COMMENT_2 = i++;\n\n//cdata\nvar BEFORE_CDATA_1 = i++; // [\nvar BEFORE_CDATA_2 = i++; // C\nvar BEFORE_CDATA_3 = i++; // D\nvar BEFORE_CDATA_4 = i++; // A\nvar BEFORE_CDATA_5 = i++; // T\nvar BEFORE_CDATA_6 = i++; // A\nvar IN_CDATA = i++; // [\nvar AFTER_CDATA_1 = i++; // ]\nvar AFTER_CDATA_2 = i++; // ]\n\n//special tags\nvar BEFORE_SPECIAL = i++; //S\nvar BEFORE_SPECIAL_END = i++; //S\n\nvar BEFORE_SCRIPT_1 = i++; //C\nvar BEFORE_SCRIPT_2 = i++; //R\nvar BEFORE_SCRIPT_3 = i++; //I\nvar BEFORE_SCRIPT_4 = i++; //P\nvar BEFORE_SCRIPT_5 = i++; //T\nvar AFTER_SCRIPT_1 = i++; //C\nvar AFTER_SCRIPT_2 = i++; //R\nvar AFTER_SCRIPT_3 = i++; //I\nvar AFTER_SCRIPT_4 = i++; //P\nvar AFTER_SCRIPT_5 = i++; //T\n\nvar BEFORE_STYLE_1 = i++; //T\nvar BEFORE_STYLE_2 = i++; //Y\nvar BEFORE_STYLE_3 = i++; //L\nvar BEFORE_STYLE_4 = i++; //E\nvar AFTER_STYLE_1 = i++; //T\nvar AFTER_STYLE_2 = i++; //Y\nvar AFTER_STYLE_3 = i++; //L\nvar AFTER_STYLE_4 = i++; //E\n\nvar BEFORE_ENTITY = i++; //&\nvar BEFORE_NUMERIC_ENTITY = i++; //#\nvar IN_NAMED_ENTITY = i++;\nvar IN_NUMERIC_ENTITY = i++;\nvar IN_HEX_ENTITY = i++; //X\n\nvar j = 0;\n\nvar SPECIAL_NONE = j++;\nvar SPECIAL_SCRIPT = j++;\nvar SPECIAL_STYLE = j++;\n\nfunction whitespace(c) {\n    return c === \" \" || c === \"\\n\" || c === \"\\t\" || c === \"\\f\" || c === \"\\r\";\n}\n\nfunction ifElseState(upper, SUCCESS, FAILURE) {\n    var lower = upper.toLowerCase();\n\n    if (upper === lower) {\n        return function(c) {\n            if (c === lower) {\n                this._state = SUCCESS;\n            } else {\n                this._state = FAILURE;\n                this._index--;\n            }\n        };\n    } else {\n        return function(c) {\n            if (c === lower || c === upper) {\n                this._state = SUCCESS;\n            } else {\n                this._state = FAILURE;\n                this._index--;\n            }\n        };\n    }\n}\n\nfunction consumeSpecialNameChar(upper, NEXT_STATE) {\n    var lower = upper.toLowerCase();\n\n    return function(c) {\n        if (c === lower || c === upper) {\n            this._state = NEXT_STATE;\n        } else {\n            this._state = IN_TAG_NAME;\n            this._index--; //consume the token again\n        }\n    };\n}\n\nfunction Tokenizer(options, cbs) {\n    this._state = TEXT;\n    this._buffer = \"\";\n    this._sectionStart = 0;\n    this._index = 0;\n    this._bufferOffset = 0; //chars removed from _buffer\n    this._baseState = TEXT;\n    this._special = SPECIAL_NONE;\n    this._cbs = cbs;\n    this._running = true;\n    this._ended = false;\n    this._xmlMode = !!(options && options.xmlMode);\n    this._decodeEntities = !!(options && options.decodeEntities);\n}\n\nTokenizer.prototype._stateText = function(c) {\n    if (c === \"<\") {\n        if (this._index > this._sectionStart) {\n            this._cbs.ontext(this._getSection());\n        }\n        this._state = BEFORE_TAG_NAME;\n        this._sectionStart = this._index;\n    } else if (\n        this._decodeEntities &&\n        this._special === SPECIAL_NONE &&\n        c === \"&\"\n    ) {\n        if (this._index > this._sectionStart) {\n            this._cbs.ontext(this._getSection());\n        }\n        this._baseState = TEXT;\n        this._state = BEFORE_ENTITY;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateBeforeTagName = function(c) {\n    if (c === \"/\") {\n        this._state = BEFORE_CLOSING_TAG_NAME;\n    } else if (c === \"<\") {\n        this._cbs.ontext(this._getSection());\n        this._sectionStart = this._index;\n    } else if (c === \">\" || this._special !== SPECIAL_NONE || whitespace(c)) {\n        this._state = TEXT;\n    } else if (c === \"!\") {\n        this._state = BEFORE_DECLARATION;\n        this._sectionStart = this._index + 1;\n    } else if (c === \"?\") {\n        this._state = IN_PROCESSING_INSTRUCTION;\n        this._sectionStart = this._index + 1;\n    } else {\n        this._state =\n            !this._xmlMode && (c === \"s\" || c === \"S\")\n                ? BEFORE_SPECIAL\n                : IN_TAG_NAME;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateInTagName = function(c) {\n    if (c === \"/\" || c === \">\" || whitespace(c)) {\n        this._emitToken(\"onopentagname\");\n        this._state = BEFORE_ATTRIBUTE_NAME;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateBeforeCloseingTagName = function(c) {\n    if (whitespace(c));\n    else if (c === \">\") {\n        this._state = TEXT;\n    } else if (this._special !== SPECIAL_NONE) {\n        if (c === \"s\" || c === \"S\") {\n            this._state = BEFORE_SPECIAL_END;\n        } else {\n            this._state = TEXT;\n            this._index--;\n        }\n    } else {\n        this._state = IN_CLOSING_TAG_NAME;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateInCloseingTagName = function(c) {\n    if (c === \">\" || whitespace(c)) {\n        this._emitToken(\"onclosetag\");\n        this._state = AFTER_CLOSING_TAG_NAME;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateAfterCloseingTagName = function(c) {\n    //skip everything until \">\"\n    if (c === \">\") {\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    }\n};\n\nTokenizer.prototype._stateBeforeAttributeName = function(c) {\n    if (c === \">\") {\n        this._cbs.onopentagend();\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    } else if (c === \"/\") {\n        this._state = IN_SELF_CLOSING_TAG;\n    } else if (!whitespace(c)) {\n        this._state = IN_ATTRIBUTE_NAME;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateInSelfClosingTag = function(c) {\n    if (c === \">\") {\n        this._cbs.onselfclosingtag();\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    } else if (!whitespace(c)) {\n        this._state = BEFORE_ATTRIBUTE_NAME;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateInAttributeName = function(c) {\n    if (c === \"=\" || c === \"/\" || c === \">\" || whitespace(c)) {\n        this._cbs.onattribname(this._getSection());\n        this._sectionStart = -1;\n        this._state = AFTER_ATTRIBUTE_NAME;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateAfterAttributeName = function(c) {\n    if (c === \"=\") {\n        this._state = BEFORE_ATTRIBUTE_VALUE;\n    } else if (c === \"/\" || c === \">\") {\n        this._cbs.onattribend();\n        this._state = BEFORE_ATTRIBUTE_NAME;\n        this._index--;\n    } else if (!whitespace(c)) {\n        this._cbs.onattribend();\n        this._state = IN_ATTRIBUTE_NAME;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateBeforeAttributeValue = function(c) {\n    if (c === '\"') {\n        this._state = IN_ATTRIBUTE_VALUE_DQ;\n        this._sectionStart = this._index + 1;\n    } else if (c === \"'\") {\n        this._state = IN_ATTRIBUTE_VALUE_SQ;\n        this._sectionStart = this._index + 1;\n    } else if (!whitespace(c)) {\n        this._state = IN_ATTRIBUTE_VALUE_NQ;\n        this._sectionStart = this._index;\n        this._index--; //reconsume token\n    }\n};\n\nTokenizer.prototype._stateInAttributeValueDoubleQuotes = function(c) {\n    if (c === '\"') {\n        this._emitToken(\"onattribdata\");\n        this._cbs.onattribend();\n        this._state = BEFORE_ATTRIBUTE_NAME;\n    } else if (this._decodeEntities && c === \"&\") {\n        this._emitToken(\"onattribdata\");\n        this._baseState = this._state;\n        this._state = BEFORE_ENTITY;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateInAttributeValueSingleQuotes = function(c) {\n    if (c === \"'\") {\n        this._emitToken(\"onattribdata\");\n        this._cbs.onattribend();\n        this._state = BEFORE_ATTRIBUTE_NAME;\n    } else if (this._decodeEntities && c === \"&\") {\n        this._emitToken(\"onattribdata\");\n        this._baseState = this._state;\n        this._state = BEFORE_ENTITY;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateInAttributeValueNoQuotes = function(c) {\n    if (whitespace(c) || c === \">\") {\n        this._emitToken(\"onattribdata\");\n        this._cbs.onattribend();\n        this._state = BEFORE_ATTRIBUTE_NAME;\n        this._index--;\n    } else if (this._decodeEntities && c === \"&\") {\n        this._emitToken(\"onattribdata\");\n        this._baseState = this._state;\n        this._state = BEFORE_ENTITY;\n        this._sectionStart = this._index;\n    }\n};\n\nTokenizer.prototype._stateBeforeDeclaration = function(c) {\n    this._state =\n        c === \"[\"\n            ? BEFORE_CDATA_1\n            : c === \"-\"\n                ? BEFORE_COMMENT\n                : IN_DECLARATION;\n};\n\nTokenizer.prototype._stateInDeclaration = function(c) {\n    if (c === \">\") {\n        this._cbs.ondeclaration(this._getSection());\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    }\n};\n\nTokenizer.prototype._stateInProcessingInstruction = function(c) {\n    if (c === \">\") {\n        this._cbs.onprocessinginstruction(this._getSection());\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    }\n};\n\nTokenizer.prototype._stateBeforeComment = function(c) {\n    if (c === \"-\") {\n        this._state = IN_COMMENT;\n        this._sectionStart = this._index + 1;\n    } else {\n        this._state = IN_DECLARATION;\n    }\n};\n\nTokenizer.prototype._stateInComment = function(c) {\n    if (c === \"-\") this._state = AFTER_COMMENT_1;\n};\n\nTokenizer.prototype._stateAfterComment1 = function(c) {\n    if (c === \"-\") {\n        this._state = AFTER_COMMENT_2;\n    } else {\n        this._state = IN_COMMENT;\n    }\n};\n\nTokenizer.prototype._stateAfterComment2 = function(c) {\n    if (c === \">\") {\n        //remove 2 trailing chars\n        this._cbs.oncomment(\n            this._buffer.substring(this._sectionStart, this._index - 2)\n        );\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    } else if (c !== \"-\") {\n        this._state = IN_COMMENT;\n    }\n    // else: stay in AFTER_COMMENT_2 (`--->`)\n};\n\nTokenizer.prototype._stateBeforeCdata1 = ifElseState(\n    \"C\",\n    BEFORE_CDATA_2,\n    IN_DECLARATION\n);\nTokenizer.prototype._stateBeforeCdata2 = ifElseState(\n    \"D\",\n    BEFORE_CDATA_3,\n    IN_DECLARATION\n);\nTokenizer.prototype._stateBeforeCdata3 = ifElseState(\n    \"A\",\n    BEFORE_CDATA_4,\n    IN_DECLARATION\n);\nTokenizer.prototype._stateBeforeCdata4 = ifElseState(\n    \"T\",\n    BEFORE_CDATA_5,\n    IN_DECLARATION\n);\nTokenizer.prototype._stateBeforeCdata5 = ifElseState(\n    \"A\",\n    BEFORE_CDATA_6,\n    IN_DECLARATION\n);\n\nTokenizer.prototype._stateBeforeCdata6 = function(c) {\n    if (c === \"[\") {\n        this._state = IN_CDATA;\n        this._sectionStart = this._index + 1;\n    } else {\n        this._state = IN_DECLARATION;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateInCdata = function(c) {\n    if (c === \"]\") this._state = AFTER_CDATA_1;\n};\n\nTokenizer.prototype._stateAfterCdata1 = function(c) {\n    if (c === \"]\") this._state = AFTER_CDATA_2;\n    else this._state = IN_CDATA;\n};\n\nTokenizer.prototype._stateAfterCdata2 = function(c) {\n    if (c === \">\") {\n        //remove 2 trailing chars\n        this._cbs.oncdata(\n            this._buffer.substring(this._sectionStart, this._index - 2)\n        );\n        this._state = TEXT;\n        this._sectionStart = this._index + 1;\n    } else if (c !== \"]\") {\n        this._state = IN_CDATA;\n    }\n    //else: stay in AFTER_CDATA_2 (`]]]>`)\n};\n\nTokenizer.prototype._stateBeforeSpecial = function(c) {\n    if (c === \"c\" || c === \"C\") {\n        this._state = BEFORE_SCRIPT_1;\n    } else if (c === \"t\" || c === \"T\") {\n        this._state = BEFORE_STYLE_1;\n    } else {\n        this._state = IN_TAG_NAME;\n        this._index--; //consume the token again\n    }\n};\n\nTokenizer.prototype._stateBeforeSpecialEnd = function(c) {\n    if (this._special === SPECIAL_SCRIPT && (c === \"c\" || c === \"C\")) {\n        this._state = AFTER_SCRIPT_1;\n    } else if (this._special === SPECIAL_STYLE && (c === \"t\" || c === \"T\")) {\n        this._state = AFTER_STYLE_1;\n    } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeScript1 = consumeSpecialNameChar(\n    \"R\",\n    BEFORE_SCRIPT_2\n);\nTokenizer.prototype._stateBeforeScript2 = consumeSpecialNameChar(\n    \"I\",\n    BEFORE_SCRIPT_3\n);\nTokenizer.prototype._stateBeforeScript3 = consumeSpecialNameChar(\n    \"P\",\n    BEFORE_SCRIPT_4\n);\nTokenizer.prototype._stateBeforeScript4 = consumeSpecialNameChar(\n    \"T\",\n    BEFORE_SCRIPT_5\n);\n\nTokenizer.prototype._stateBeforeScript5 = function(c) {\n    if (c === \"/\" || c === \">\" || whitespace(c)) {\n        this._special = SPECIAL_SCRIPT;\n    }\n    this._state = IN_TAG_NAME;\n    this._index--; //consume the token again\n};\n\nTokenizer.prototype._stateAfterScript1 = ifElseState(\"R\", AFTER_SCRIPT_2, TEXT);\nTokenizer.prototype._stateAfterScript2 = ifElseState(\"I\", AFTER_SCRIPT_3, TEXT);\nTokenizer.prototype._stateAfterScript3 = ifElseState(\"P\", AFTER_SCRIPT_4, TEXT);\nTokenizer.prototype._stateAfterScript4 = ifElseState(\"T\", AFTER_SCRIPT_5, TEXT);\n\nTokenizer.prototype._stateAfterScript5 = function(c) {\n    if (c === \">\" || whitespace(c)) {\n        this._special = SPECIAL_NONE;\n        this._state = IN_CLOSING_TAG_NAME;\n        this._sectionStart = this._index - 6;\n        this._index--; //reconsume the token\n    } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeStyle1 = consumeSpecialNameChar(\n    \"Y\",\n    BEFORE_STYLE_2\n);\nTokenizer.prototype._stateBeforeStyle2 = consumeSpecialNameChar(\n    \"L\",\n    BEFORE_STYLE_3\n);\nTokenizer.prototype._stateBeforeStyle3 = consumeSpecialNameChar(\n    \"E\",\n    BEFORE_STYLE_4\n);\n\nTokenizer.prototype._stateBeforeStyle4 = function(c) {\n    if (c === \"/\" || c === \">\" || whitespace(c)) {\n        this._special = SPECIAL_STYLE;\n    }\n    this._state = IN_TAG_NAME;\n    this._index--; //consume the token again\n};\n\nTokenizer.prototype._stateAfterStyle1 = ifElseState(\"Y\", AFTER_STYLE_2, TEXT);\nTokenizer.prototype._stateAfterStyle2 = ifElseState(\"L\", AFTER_STYLE_3, TEXT);\nTokenizer.prototype._stateAfterStyle3 = ifElseState(\"E\", AFTER_STYLE_4, TEXT);\n\nTokenizer.prototype._stateAfterStyle4 = function(c) {\n    if (c === \">\" || whitespace(c)) {\n        this._special = SPECIAL_NONE;\n        this._state = IN_CLOSING_TAG_NAME;\n        this._sectionStart = this._index - 5;\n        this._index--; //reconsume the token\n    } else this._state = TEXT;\n};\n\nTokenizer.prototype._stateBeforeEntity = ifElseState(\n    \"#\",\n    BEFORE_NUMERIC_ENTITY,\n    IN_NAMED_ENTITY\n);\nTokenizer.prototype._stateBeforeNumericEntity = ifElseState(\n    \"X\",\n    IN_HEX_ENTITY,\n    IN_NUMERIC_ENTITY\n);\n\n//for entities terminated with a semicolon\nTokenizer.prototype._parseNamedEntityStrict = function() {\n    //offset = 1\n    if (this._sectionStart + 1 < this._index) {\n        var entity = this._buffer.substring(\n                this._sectionStart + 1,\n                this._index\n            ),\n            map = this._xmlMode ? xmlMap : entityMap;\n\n        if (map.hasOwnProperty(entity)) {\n            this._emitPartial(map[entity]);\n            this._sectionStart = this._index + 1;\n        }\n    }\n};\n\n//parses legacy entities (without trailing semicolon)\nTokenizer.prototype._parseLegacyEntity = function() {\n    var start = this._sectionStart + 1,\n        limit = this._index - start;\n\n    if (limit > 6) limit = 6; //the max length of legacy entities is 6\n\n    while (limit >= 2) {\n        //the min length of legacy entities is 2\n        var entity = this._buffer.substr(start, limit);\n\n        if (legacyMap.hasOwnProperty(entity)) {\n            this._emitPartial(legacyMap[entity]);\n            this._sectionStart += limit + 1;\n            return;\n        } else {\n            limit--;\n        }\n    }\n};\n\nTokenizer.prototype._stateInNamedEntity = function(c) {\n    if (c === \";\") {\n        this._parseNamedEntityStrict();\n        if (this._sectionStart + 1 < this._index && !this._xmlMode) {\n            this._parseLegacyEntity();\n        }\n        this._state = this._baseState;\n    } else if (\n        (c < \"a\" || c > \"z\") &&\n        (c < \"A\" || c > \"Z\") &&\n        (c < \"0\" || c > \"9\")\n    ) {\n        if (this._xmlMode);\n        else if (this._sectionStart + 1 === this._index);\n        else if (this._baseState !== TEXT) {\n            if (c !== \"=\") {\n                this._parseNamedEntityStrict();\n            }\n        } else {\n            this._parseLegacyEntity();\n        }\n\n        this._state = this._baseState;\n        this._index--;\n    }\n};\n\nTokenizer.prototype._decodeNumericEntity = function(offset, base) {\n    var sectionStart = this._sectionStart + offset;\n\n    if (sectionStart !== this._index) {\n        //parse entity\n        var entity = this._buffer.substring(sectionStart, this._index);\n        var parsed = parseInt(entity, base);\n\n        this._emitPartial(decodeCodePoint(parsed));\n        this._sectionStart = this._index;\n    } else {\n        this._sectionStart--;\n    }\n\n    this._state = this._baseState;\n};\n\nTokenizer.prototype._stateInNumericEntity = function(c) {\n    if (c === \";\") {\n        this._decodeNumericEntity(2, 10);\n        this._sectionStart++;\n    } else if (c < \"0\" || c > \"9\") {\n        if (!this._xmlMode) {\n            this._decodeNumericEntity(2, 10);\n        } else {\n            this._state = this._baseState;\n        }\n        this._index--;\n    }\n};\n\nTokenizer.prototype._stateInHexEntity = function(c) {\n    if (c === \";\") {\n        this._decodeNumericEntity(3, 16);\n        this._sectionStart++;\n    } else if (\n        (c < \"a\" || c > \"f\") &&\n        (c < \"A\" || c > \"F\") &&\n        (c < \"0\" || c > \"9\")\n    ) {\n        if (!this._xmlMode) {\n            this._decodeNumericEntity(3, 16);\n        } else {\n            this._state = this._baseState;\n        }\n        this._index--;\n    }\n};\n\nTokenizer.prototype._cleanup = function() {\n    if (this._sectionStart < 0) {\n        this._buffer = \"\";\n        this._bufferOffset += this._index;\n        this._index = 0;\n    } else if (this._running) {\n        if (this._state === TEXT) {\n            if (this._sectionStart !== this._index) {\n                this._cbs.ontext(this._buffer.substr(this._sectionStart));\n            }\n            this._buffer = \"\";\n            this._bufferOffset += this._index;\n            this._index = 0;\n        } else if (this._sectionStart === this._index) {\n            //the section just started\n            this._buffer = \"\";\n            this._bufferOffset += this._index;\n            this._index = 0;\n        } else {\n            //remove everything unnecessary\n            this._buffer = this._buffer.substr(this._sectionStart);\n            this._index -= this._sectionStart;\n            this._bufferOffset += this._sectionStart;\n        }\n\n        this._sectionStart = 0;\n    }\n};\n\n//TODO make events conditional\nTokenizer.prototype.write = function(chunk) {\n    if (this._ended) this._cbs.onerror(Error(\".write() after done!\"));\n\n    this._buffer += chunk;\n    this._parse();\n};\n\nTokenizer.prototype._parse = function() {\n    while (this._index < this._buffer.length && this._running) {\n        var c = this._buffer.charAt(this._index);\n        if (this._state === TEXT) {\n            this._stateText(c);\n        } else if (this._state === BEFORE_TAG_NAME) {\n            this._stateBeforeTagName(c);\n        } else if (this._state === IN_TAG_NAME) {\n            this._stateInTagName(c);\n        } else if (this._state === BEFORE_CLOSING_TAG_NAME) {\n            this._stateBeforeCloseingTagName(c);\n        } else if (this._state === IN_CLOSING_TAG_NAME) {\n            this._stateInCloseingTagName(c);\n        } else if (this._state === AFTER_CLOSING_TAG_NAME) {\n            this._stateAfterCloseingTagName(c);\n        } else if (this._state === IN_SELF_CLOSING_TAG) {\n            this._stateInSelfClosingTag(c);\n        } else if (this._state === BEFORE_ATTRIBUTE_NAME) {\n\n        /*\n\t\t*\tattributes\n\t\t*/\n            this._stateBeforeAttributeName(c);\n        } else if (this._state === IN_ATTRIBUTE_NAME) {\n            this._stateInAttributeName(c);\n        } else if (this._state === AFTER_ATTRIBUTE_NAME) {\n            this._stateAfterAttributeName(c);\n        } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {\n            this._stateBeforeAttributeValue(c);\n        } else if (this._state === IN_ATTRIBUTE_VALUE_DQ) {\n            this._stateInAttributeValueDoubleQuotes(c);\n        } else if (this._state === IN_ATTRIBUTE_VALUE_SQ) {\n            this._stateInAttributeValueSingleQuotes(c);\n        } else if (this._state === IN_ATTRIBUTE_VALUE_NQ) {\n            this._stateInAttributeValueNoQuotes(c);\n        } else if (this._state === BEFORE_DECLARATION) {\n\n        /*\n\t\t*\tdeclarations\n\t\t*/\n            this._stateBeforeDeclaration(c);\n        } else if (this._state === IN_DECLARATION) {\n            this._stateInDeclaration(c);\n        } else if (this._state === IN_PROCESSING_INSTRUCTION) {\n\n        /*\n\t\t*\tprocessing instructions\n\t\t*/\n            this._stateInProcessingInstruction(c);\n        } else if (this._state === BEFORE_COMMENT) {\n\n        /*\n\t\t*\tcomments\n\t\t*/\n            this._stateBeforeComment(c);\n        } else if (this._state === IN_COMMENT) {\n            this._stateInComment(c);\n        } else if (this._state === AFTER_COMMENT_1) {\n            this._stateAfterComment1(c);\n        } else if (this._state === AFTER_COMMENT_2) {\n            this._stateAfterComment2(c);\n        } else if (this._state === BEFORE_CDATA_1) {\n\n        /*\n\t\t*\tcdata\n\t\t*/\n            this._stateBeforeCdata1(c);\n        } else if (this._state === BEFORE_CDATA_2) {\n            this._stateBeforeCdata2(c);\n        } else if (this._state === BEFORE_CDATA_3) {\n            this._stateBeforeCdata3(c);\n        } else if (this._state === BEFORE_CDATA_4) {\n            this._stateBeforeCdata4(c);\n        } else if (this._state === BEFORE_CDATA_5) {\n            this._stateBeforeCdata5(c);\n        } else if (this._state === BEFORE_CDATA_6) {\n            this._stateBeforeCdata6(c);\n        } else if (this._state === IN_CDATA) {\n            this._stateInCdata(c);\n        } else if (this._state === AFTER_CDATA_1) {\n            this._stateAfterCdata1(c);\n        } else if (this._state === AFTER_CDATA_2) {\n            this._stateAfterCdata2(c);\n        } else if (this._state === BEFORE_SPECIAL) {\n\n        /*\n\t\t* special tags\n\t\t*/\n            this._stateBeforeSpecial(c);\n        } else if (this._state === BEFORE_SPECIAL_END) {\n            this._stateBeforeSpecialEnd(c);\n        } else if (this._state === BEFORE_SCRIPT_1) {\n\n        /*\n\t\t* script\n\t\t*/\n            this._stateBeforeScript1(c);\n        } else if (this._state === BEFORE_SCRIPT_2) {\n            this._stateBeforeScript2(c);\n        } else if (this._state === BEFORE_SCRIPT_3) {\n            this._stateBeforeScript3(c);\n        } else if (this._state === BEFORE_SCRIPT_4) {\n            this._stateBeforeScript4(c);\n        } else if (this._state === BEFORE_SCRIPT_5) {\n            this._stateBeforeScript5(c);\n        } else if (this._state === AFTER_SCRIPT_1) {\n            this._stateAfterScript1(c);\n        } else if (this._state === AFTER_SCRIPT_2) {\n            this._stateAfterScript2(c);\n        } else if (this._state === AFTER_SCRIPT_3) {\n            this._stateAfterScript3(c);\n        } else if (this._state === AFTER_SCRIPT_4) {\n            this._stateAfterScript4(c);\n        } else if (this._state === AFTER_SCRIPT_5) {\n            this._stateAfterScript5(c);\n        } else if (this._state === BEFORE_STYLE_1) {\n\n        /*\n\t\t* style\n\t\t*/\n            this._stateBeforeStyle1(c);\n        } else if (this._state === BEFORE_STYLE_2) {\n            this._stateBeforeStyle2(c);\n        } else if (this._state === BEFORE_STYLE_3) {\n            this._stateBeforeStyle3(c);\n        } else if (this._state === BEFORE_STYLE_4) {\n            this._stateBeforeStyle4(c);\n        } else if (this._state === AFTER_STYLE_1) {\n            this._stateAfterStyle1(c);\n        } else if (this._state === AFTER_STYLE_2) {\n            this._stateAfterStyle2(c);\n        } else if (this._state === AFTER_STYLE_3) {\n            this._stateAfterStyle3(c);\n        } else if (this._state === AFTER_STYLE_4) {\n            this._stateAfterStyle4(c);\n        } else if (this._state === BEFORE_ENTITY) {\n\n        /*\n\t\t* entities\n\t\t*/\n            this._stateBeforeEntity(c);\n        } else if (this._state === BEFORE_NUMERIC_ENTITY) {\n            this._stateBeforeNumericEntity(c);\n        } else if (this._state === IN_NAMED_ENTITY) {\n            this._stateInNamedEntity(c);\n        } else if (this._state === IN_NUMERIC_ENTITY) {\n            this._stateInNumericEntity(c);\n        } else if (this._state === IN_HEX_ENTITY) {\n            this._stateInHexEntity(c);\n        } else {\n            this._cbs.onerror(Error(\"unknown _state\"), this._state);\n        }\n\n        this._index++;\n    }\n\n    this._cleanup();\n};\n\nTokenizer.prototype.pause = function() {\n    this._running = false;\n};\nTokenizer.prototype.resume = function() {\n    this._running = true;\n\n    if (this._index < this._buffer.length) {\n        this._parse();\n    }\n    if (this._ended) {\n        this._finish();\n    }\n};\n\nTokenizer.prototype.end = function(chunk) {\n    if (this._ended) this._cbs.onerror(Error(\".end() after done!\"));\n    if (chunk) this.write(chunk);\n\n    this._ended = true;\n\n    if (this._running) this._finish();\n};\n\nTokenizer.prototype._finish = function() {\n    //if there is remaining data, emit it in a reasonable way\n    if (this._sectionStart < this._index) {\n        this._handleTrailingData();\n    }\n\n    this._cbs.onend();\n};\n\nTokenizer.prototype._handleTrailingData = function() {\n    var data = this._buffer.substr(this._sectionStart);\n\n    if (\n        this._state === IN_CDATA ||\n        this._state === AFTER_CDATA_1 ||\n        this._state === AFTER_CDATA_2\n    ) {\n        this._cbs.oncdata(data);\n    } else if (\n        this._state === IN_COMMENT ||\n        this._state === AFTER_COMMENT_1 ||\n        this._state === AFTER_COMMENT_2\n    ) {\n        this._cbs.oncomment(data);\n    } else if (this._state === IN_NAMED_ENTITY && !this._xmlMode) {\n        this._parseLegacyEntity();\n        if (this._sectionStart < this._index) {\n            this._state = this._baseState;\n            this._handleTrailingData();\n        }\n    } else if (this._state === IN_NUMERIC_ENTITY && !this._xmlMode) {\n        this._decodeNumericEntity(2, 10);\n        if (this._sectionStart < this._index) {\n            this._state = this._baseState;\n            this._handleTrailingData();\n        }\n    } else if (this._state === IN_HEX_ENTITY && !this._xmlMode) {\n        this._decodeNumericEntity(3, 16);\n        if (this._sectionStart < this._index) {\n            this._state = this._baseState;\n            this._handleTrailingData();\n        }\n    } else if (\n        this._state !== IN_TAG_NAME &&\n        this._state !== BEFORE_ATTRIBUTE_NAME &&\n        this._state !== BEFORE_ATTRIBUTE_VALUE &&\n        this._state !== AFTER_ATTRIBUTE_NAME &&\n        this._state !== IN_ATTRIBUTE_NAME &&\n        this._state !== IN_ATTRIBUTE_VALUE_SQ &&\n        this._state !== IN_ATTRIBUTE_VALUE_DQ &&\n        this._state !== IN_ATTRIBUTE_VALUE_NQ &&\n        this._state !== IN_CLOSING_TAG_NAME\n    ) {\n        this._cbs.ontext(data);\n    }\n    //else, ignore remaining data\n    //TODO add a way to remove current tag\n};\n\nTokenizer.prototype.reset = function() {\n    Tokenizer.call(\n        this,\n        { xmlMode: this._xmlMode, decodeEntities: this._decodeEntities },\n        this._cbs\n    );\n};\n\nTokenizer.prototype.getAbsoluteIndex = function() {\n    return this._bufferOffset + this._index;\n};\n\nTokenizer.prototype._getSection = function() {\n    return this._buffer.substring(this._sectionStart, this._index);\n};\n\nTokenizer.prototype._emitToken = function(name) {\n    this._cbs[name](this._getSection());\n    this._sectionStart = -1;\n};\n\nTokenizer.prototype._emitPartial = function(value) {\n    if (this._baseState !== TEXT) {\n        this._cbs.onattribdata(value); //TODO implement the new event\n    } else {\n        this._cbs.ontext(value);\n    }\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/Tokenizer.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/WritableStream.js":
/*!********************************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/WritableStream.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = Stream;\n\nvar Parser = __webpack_require__(/*! ./Parser.js */ \"../scratch-vm/node_modules/htmlparser2/lib/Parser.js\");\nvar WritableStream = (__webpack_require__(/*! readable-stream */ \"../scratch-vm/node_modules/readable-stream/readable.js\").Writable);\nvar StringDecoder = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder);\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\n\nfunction Stream(cbs, options) {\n    var parser = (this._parser = new Parser(cbs, options));\n    var decoder = (this._decoder = new StringDecoder());\n\n    WritableStream.call(this, { decodeStrings: false });\n\n    this.once(\"finish\", function() {\n        parser.end(decoder.end());\n    });\n}\n\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Stream, WritableStream);\n\nStream.prototype._write = function(chunk, encoding, cb) {\n    if (chunk instanceof Buffer) chunk = this._decoder.write(chunk);\n    this._parser.write(chunk);\n    cb();\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/WritableStream.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/htmlparser2/lib/index.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/htmlparser2/lib/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Parser = __webpack_require__(/*! ./Parser.js */ \"../scratch-vm/node_modules/htmlparser2/lib/Parser.js\");\nvar DomHandler = __webpack_require__(/*! domhandler */ \"../scratch-vm/node_modules/domhandler/index.js\");\n\nfunction defineProp(name, value) {\n    delete module.exports[name];\n    module.exports[name] = value;\n    return value;\n}\n\nmodule.exports = {\n    Parser: Parser,\n    Tokenizer: __webpack_require__(/*! ./Tokenizer.js */ \"../scratch-vm/node_modules/htmlparser2/lib/Tokenizer.js\"),\n    ElementType: __webpack_require__(/*! domelementtype */ \"../scratch-vm/node_modules/domelementtype/index.js\"),\n    DomHandler: DomHandler,\n    get FeedHandler() {\n        return defineProp(\"FeedHandler\", __webpack_require__(/*! ./FeedHandler.js */ \"../scratch-vm/node_modules/htmlparser2/lib/FeedHandler.js\"));\n    },\n    get Stream() {\n        return defineProp(\"Stream\", __webpack_require__(/*! ./Stream.js */ \"../scratch-vm/node_modules/htmlparser2/lib/Stream.js\"));\n    },\n    get WritableStream() {\n        return defineProp(\"WritableStream\", __webpack_require__(/*! ./WritableStream.js */ \"../scratch-vm/node_modules/htmlparser2/lib/WritableStream.js\"));\n    },\n    get ProxyHandler() {\n        return defineProp(\"ProxyHandler\", __webpack_require__(/*! ./ProxyHandler.js */ \"../scratch-vm/node_modules/htmlparser2/lib/ProxyHandler.js\"));\n    },\n    get DomUtils() {\n        return defineProp(\"DomUtils\", __webpack_require__(/*! domutils */ \"../scratch-vm/node_modules/domutils/index.js\"));\n    },\n    get CollectingHandler() {\n        return defineProp(\n            \"CollectingHandler\",\n            __webpack_require__(/*! ./CollectingHandler.js */ \"../scratch-vm/node_modules/htmlparser2/lib/CollectingHandler.js\")\n        );\n    },\n    // For legacy support\n    DefaultHandler: DomHandler,\n    get RssHandler() {\n        return defineProp(\"RssHandler\", this.FeedHandler);\n    },\n    //helper methods\n    parseDOM: function(data, options) {\n        var handler = new DomHandler(options);\n        new Parser(handler, options).end(data);\n        return handler.dom;\n    },\n    parseFeed: function(feed, options) {\n        var handler = new module.exports.FeedHandler(options);\n        new Parser(handler, options).end(feed);\n        return handler.dom;\n    },\n    createDomStream: function(cb, options, elementCb) {\n        var handler = new DomHandler(cb, options, elementCb);\n        return new Parser(handler, options);\n    },\n    // List of all events that the parser emits\n    EVENTS: {\n        /* Format: eventname: number of arguments */\n        attribute: 2,\n        cdatastart: 0,\n        cdataend: 0,\n        text: 1,\n        processinginstruction: 2,\n        comment: 1,\n        commentend: 0,\n        closetag: 1,\n        opentag: 2,\n        opentagname: 1,\n        error: 1,\n        end: 0\n    }\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/htmlparser2/lib/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/immutable/dist/immutable.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/immutable/dist/immutable.js ***!
  \**************************************************************/
/***/ (function(module) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  0;\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\n\n  function createClass(ctor, superClass) {\n    if (superClass) {\n      ctor.prototype = Object.create(superClass.prototype);\n    }\n    ctor.prototype.constructor = ctor;\n  }\n\n  function Iterable(value) {\n      return isIterable(value) ? value : Seq(value);\n    }\n\n\n  createClass(KeyedIterable, Iterable);\n    function KeyedIterable(value) {\n      return isKeyed(value) ? value : KeyedSeq(value);\n    }\n\n\n  createClass(IndexedIterable, Iterable);\n    function IndexedIterable(value) {\n      return isIndexed(value) ? value : IndexedSeq(value);\n    }\n\n\n  createClass(SetIterable, Iterable);\n    function SetIterable(value) {\n      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);\n    }\n\n\n\n  function isIterable(maybeIterable) {\n    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);\n  }\n\n  function isKeyed(maybeKeyed) {\n    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);\n  }\n\n  function isIndexed(maybeIndexed) {\n    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);\n  }\n\n  function isAssociative(maybeAssociative) {\n    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);\n  }\n\n  function isOrdered(maybeOrdered) {\n    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);\n  }\n\n  Iterable.isIterable = isIterable;\n  Iterable.isKeyed = isKeyed;\n  Iterable.isIndexed = isIndexed;\n  Iterable.isAssociative = isAssociative;\n  Iterable.isOrdered = isOrdered;\n\n  Iterable.Keyed = KeyedIterable;\n  Iterable.Indexed = IndexedIterable;\n  Iterable.Set = SetIterable;\n\n\n  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  // Used for setting prototype methods that IE8 chokes on.\n  var DELETE = 'delete';\n\n  // Constants describing the size of trie nodes.\n  var SHIFT = 5; // Resulted in best performance after ______?\n  var SIZE = 1 << SHIFT;\n  var MASK = SIZE - 1;\n\n  // A consistent shared value representing \"not set\" which equals nothing other\n  // than itself, and nothing that could be provided externally.\n  var NOT_SET = {};\n\n  // Boolean references, Rough equivalent of `bool &`.\n  var CHANGE_LENGTH = { value: false };\n  var DID_ALTER = { value: false };\n\n  function MakeRef(ref) {\n    ref.value = false;\n    return ref;\n  }\n\n  function SetRef(ref) {\n    ref && (ref.value = true);\n  }\n\n  // A function which returns a value representing an \"owner\" for transient writes\n  // to tries. The return value will only ever equal itself, and will not equal\n  // the return of any subsequent call of this function.\n  function OwnerID() {}\n\n  // http://jsperf.com/copy-array-inline\n  function arrCopy(arr, offset) {\n    offset = offset || 0;\n    var len = Math.max(0, arr.length - offset);\n    var newArr = new Array(len);\n    for (var ii = 0; ii < len; ii++) {\n      newArr[ii] = arr[ii + offset];\n    }\n    return newArr;\n  }\n\n  function ensureSize(iter) {\n    if (iter.size === undefined) {\n      iter.size = iter.__iterate(returnTrue);\n    }\n    return iter.size;\n  }\n\n  function wrapIndex(iter, index) {\n    // This implements \"is array index\" which the ECMAString spec defines as:\n    //\n    //     A String property name P is an array index if and only if\n    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal\n    //     to 2^32−1.\n    //\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects\n    if (typeof index !== 'number') {\n      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32\n      if ('' + uint32Index !== index || uint32Index === 4294967295) {\n        return NaN;\n      }\n      index = uint32Index;\n    }\n    return index < 0 ? ensureSize(iter) + index : index;\n  }\n\n  function returnTrue() {\n    return true;\n  }\n\n  function wholeSlice(begin, end, size) {\n    return (begin === 0 || (size !== undefined && begin <= -size)) &&\n      (end === undefined || (size !== undefined && end >= size));\n  }\n\n  function resolveBegin(begin, size) {\n    return resolveIndex(begin, size, 0);\n  }\n\n  function resolveEnd(end, size) {\n    return resolveIndex(end, size, size);\n  }\n\n  function resolveIndex(index, size, defaultIndex) {\n    return index === undefined ?\n      defaultIndex :\n      index < 0 ?\n        Math.max(0, size + index) :\n        size === undefined ?\n          index :\n          Math.min(size, index);\n  }\n\n  /* global Symbol */\n\n  var ITERATE_KEYS = 0;\n  var ITERATE_VALUES = 1;\n  var ITERATE_ENTRIES = 2;\n\n  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\n  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;\n\n\n  function Iterator(next) {\n      this.next = next;\n    }\n\n    Iterator.prototype.toString = function() {\n      return '[Iterator]';\n    };\n\n\n  Iterator.KEYS = ITERATE_KEYS;\n  Iterator.VALUES = ITERATE_VALUES;\n  Iterator.ENTRIES = ITERATE_ENTRIES;\n\n  Iterator.prototype.inspect =\n  Iterator.prototype.toSource = function () { return this.toString(); }\n  Iterator.prototype[ITERATOR_SYMBOL] = function () {\n    return this;\n  };\n\n\n  function iteratorValue(type, k, v, iteratorResult) {\n    var value = type === 0 ? k : type === 1 ? v : [k, v];\n    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {\n      value: value, done: false\n    });\n    return iteratorResult;\n  }\n\n  function iteratorDone() {\n    return { value: undefined, done: true };\n  }\n\n  function hasIterator(maybeIterable) {\n    return !!getIteratorFn(maybeIterable);\n  }\n\n  function isIterator(maybeIterator) {\n    return maybeIterator && typeof maybeIterator.next === 'function';\n  }\n\n  function getIterator(iterable) {\n    var iteratorFn = getIteratorFn(iterable);\n    return iteratorFn && iteratorFn.call(iterable);\n  }\n\n  function getIteratorFn(iterable) {\n    var iteratorFn = iterable && (\n      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||\n      iterable[FAUX_ITERATOR_SYMBOL]\n    );\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  function isArrayLike(value) {\n    return value && typeof value.length === 'number';\n  }\n\n  createClass(Seq, Iterable);\n    function Seq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        isIterable(value) ? value.toSeq() : seqFromValue(value);\n    }\n\n    Seq.of = function(/*...values*/) {\n      return Seq(arguments);\n    };\n\n    Seq.prototype.toSeq = function() {\n      return this;\n    };\n\n    Seq.prototype.toString = function() {\n      return this.__toString('Seq {', '}');\n    };\n\n    Seq.prototype.cacheResult = function() {\n      if (!this._cache && this.__iterateUncached) {\n        this._cache = this.entrySeq().toArray();\n        this.size = this._cache.length;\n      }\n      return this;\n    };\n\n    // abstract __iterateUncached(fn, reverse)\n\n    Seq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, true);\n    };\n\n    // abstract __iteratorUncached(type, reverse)\n\n    Seq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, true);\n    };\n\n\n\n  createClass(KeyedSeq, Seq);\n    function KeyedSeq(value) {\n      return value === null || value === undefined ?\n        emptySequence().toKeyedSeq() :\n        isIterable(value) ?\n          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :\n          keyedSeqFromValue(value);\n    }\n\n    KeyedSeq.prototype.toKeyedSeq = function() {\n      return this;\n    };\n\n\n\n  createClass(IndexedSeq, Seq);\n    function IndexedSeq(value) {\n      return value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();\n    }\n\n    IndexedSeq.of = function(/*...values*/) {\n      return IndexedSeq(arguments);\n    };\n\n    IndexedSeq.prototype.toIndexedSeq = function() {\n      return this;\n    };\n\n    IndexedSeq.prototype.toString = function() {\n      return this.__toString('Seq [', ']');\n    };\n\n    IndexedSeq.prototype.__iterate = function(fn, reverse) {\n      return seqIterate(this, fn, reverse, false);\n    };\n\n    IndexedSeq.prototype.__iterator = function(type, reverse) {\n      return seqIterator(this, type, reverse, false);\n    };\n\n\n\n  createClass(SetSeq, Seq);\n    function SetSeq(value) {\n      return (\n        value === null || value === undefined ? emptySequence() :\n        !isIterable(value) ? indexedSeqFromValue(value) :\n        isKeyed(value) ? value.entrySeq() : value\n      ).toSetSeq();\n    }\n\n    SetSeq.of = function(/*...values*/) {\n      return SetSeq(arguments);\n    };\n\n    SetSeq.prototype.toSetSeq = function() {\n      return this;\n    };\n\n\n\n  Seq.isSeq = isSeq;\n  Seq.Keyed = KeyedSeq;\n  Seq.Set = SetSeq;\n  Seq.Indexed = IndexedSeq;\n\n  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';\n\n  Seq.prototype[IS_SEQ_SENTINEL] = true;\n\n\n\n  createClass(ArraySeq, IndexedSeq);\n    function ArraySeq(array) {\n      this._array = array;\n      this.size = array.length;\n    }\n\n    ArraySeq.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;\n    };\n\n    ArraySeq.prototype.__iterate = function(fn, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ArraySeq.prototype.__iterator = function(type, reverse) {\n      var array = this._array;\n      var maxIndex = array.length - 1;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}\n      );\n    };\n\n\n\n  createClass(ObjectSeq, KeyedSeq);\n    function ObjectSeq(object) {\n      var keys = Object.keys(object);\n      this._object = object;\n      this._keys = keys;\n      this.size = keys.length;\n    }\n\n    ObjectSeq.prototype.get = function(key, notSetValue) {\n      if (notSetValue !== undefined && !this.has(key)) {\n        return notSetValue;\n      }\n      return this._object[key];\n    };\n\n    ObjectSeq.prototype.has = function(key) {\n      return this._object.hasOwnProperty(key);\n    };\n\n    ObjectSeq.prototype.__iterate = function(fn, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        if (fn(object[key], key, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    ObjectSeq.prototype.__iterator = function(type, reverse) {\n      var object = this._object;\n      var keys = this._keys;\n      var maxIndex = keys.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var key = keys[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, key, object[key]);\n      });\n    };\n\n  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(IterableSeq, IndexedSeq);\n    function IterableSeq(iterable) {\n      this._iterable = iterable;\n      this.size = iterable.length || iterable.size;\n    }\n\n    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      var iterations = 0;\n      if (isIterator(iterator)) {\n        var step;\n        while (!(step = iterator.next()).done) {\n          if (fn(step.value, iterations++, this) === false) {\n            break;\n          }\n        }\n      }\n      return iterations;\n    };\n\n    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterable = this._iterable;\n      var iterator = getIterator(iterable);\n      if (!isIterator(iterator)) {\n        return new Iterator(iteratorDone);\n      }\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step : iteratorValue(type, iterations++, step.value);\n      });\n    };\n\n\n\n  createClass(IteratorSeq, IndexedSeq);\n    function IteratorSeq(iterator) {\n      this._iterator = iterator;\n      this._iteratorCache = [];\n    }\n\n    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      while (iterations < cache.length) {\n        if (fn(cache[iterations], iterations++, this) === false) {\n          return iterations;\n        }\n      }\n      var step;\n      while (!(step = iterator.next()).done) {\n        var val = step.value;\n        cache[iterations] = val;\n        if (fn(val, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n\n    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = this._iterator;\n      var cache = this._iteratorCache;\n      var iterations = 0;\n      return new Iterator(function()  {\n        if (iterations >= cache.length) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          cache[iterations] = step.value;\n        }\n        return iteratorValue(type, iterations, cache[iterations++]);\n      });\n    };\n\n\n\n\n  // # pragma Helper functions\n\n  function isSeq(maybeSeq) {\n    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);\n  }\n\n  var EMPTY_SEQ;\n\n  function emptySequence() {\n    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));\n  }\n\n  function keyedSeqFromValue(value) {\n    var seq =\n      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :\n      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :\n      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :\n      typeof value === 'object' ? new ObjectSeq(value) :\n      undefined;\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of [k, v] entries, '+\n        'or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function indexedSeqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value);\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function seqFromValue(value) {\n    var seq = maybeIndexedSeqFromValue(value) ||\n      (typeof value === 'object' && new ObjectSeq(value));\n    if (!seq) {\n      throw new TypeError(\n        'Expected Array or iterable object of values, or keyed object: ' + value\n      );\n    }\n    return seq;\n  }\n\n  function maybeIndexedSeqFromValue(value) {\n    return (\n      isArrayLike(value) ? new ArraySeq(value) :\n      isIterator(value) ? new IteratorSeq(value) :\n      hasIterator(value) ? new IterableSeq(value) :\n      undefined\n    );\n  }\n\n  function seqIterate(seq, fn, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    }\n    return seq.__iterateUncached(fn, reverse);\n  }\n\n  function seqIterator(seq, type, reverse, useKeys) {\n    var cache = seq._cache;\n    if (cache) {\n      var maxIndex = cache.length - 1;\n      var ii = 0;\n      return new Iterator(function()  {\n        var entry = cache[reverse ? maxIndex - ii : ii];\n        return ii++ > maxIndex ?\n          iteratorDone() :\n          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);\n      });\n    }\n    return seq.__iteratorUncached(type, reverse);\n  }\n\n  function fromJS(json, converter) {\n    return converter ?\n      fromJSWith(converter, json, '', {'': json}) :\n      fromJSDefault(json);\n  }\n\n  function fromJSWith(converter, json, key, parentJSON) {\n    if (Array.isArray(json)) {\n      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    if (isPlainObj(json)) {\n      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));\n    }\n    return json;\n  }\n\n  function fromJSDefault(json) {\n    if (Array.isArray(json)) {\n      return IndexedSeq(json).map(fromJSDefault).toList();\n    }\n    if (isPlainObj(json)) {\n      return KeyedSeq(json).map(fromJSDefault).toMap();\n    }\n    return json;\n  }\n\n  function isPlainObj(value) {\n    return value && (value.constructor === Object || value.constructor === undefined);\n  }\n\n  /**\n   * An extension of the \"same-value\" algorithm as [described for use by ES6 Map\n   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)\n   *\n   * NaN is considered the same as NaN, however -0 and 0 are considered the same\n   * value, which is different from the algorithm described by\n   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).\n   *\n   * This is extended further to allow Objects to describe the values they\n   * represent, by way of `valueOf` or `equals` (and `hashCode`).\n   *\n   * Note: because of this extension, the key equality of Immutable.Map and the\n   * value equality of Immutable.Set will differ from ES6 Map and Set.\n   *\n   * ### Defining custom values\n   *\n   * The easiest way to describe the value an object represents is by implementing\n   * `valueOf`. For example, `Date` represents a value by returning a unix\n   * timestamp for `valueOf`:\n   *\n   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...\n   *     var date2 = new Date(1234567890000);\n   *     date1.valueOf(); // 1234567890000\n   *     assert( date1 !== date2 );\n   *     assert( Immutable.is( date1, date2 ) );\n   *\n   * Note: overriding `valueOf` may have other implications if you use this object\n   * where JavaScript expects a primitive, such as implicit string coercion.\n   *\n   * For more complex types, especially collections, implementing `valueOf` may\n   * not be performant. An alternative is to implement `equals` and `hashCode`.\n   *\n   * `equals` takes another object, presumably of similar type, and returns true\n   * if the it is equal. Equality is symmetrical, so the same result should be\n   * returned if this and the argument are flipped.\n   *\n   *     assert( a.equals(b) === b.equals(a) );\n   *\n   * `hashCode` returns a 32bit integer number representing the object which will\n   * be used to determine how to store the value object in a Map or Set. You must\n   * provide both or neither methods, one must not exist without the other.\n   *\n   * Also, an important relationship between these methods must be upheld: if two\n   * values are equal, they *must* return the same hashCode. If the values are not\n   * equal, they might have the same hashCode; this is called a hash collision,\n   * and while undesirable for performance reasons, it is acceptable.\n   *\n   *     if (a.equals(b)) {\n   *       assert( a.hashCode() === b.hashCode() );\n   *     }\n   *\n   * All Immutable collections implement `equals` and `hashCode`.\n   *\n   */\n  function is(valueA, valueB) {\n    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n      return true;\n    }\n    if (!valueA || !valueB) {\n      return false;\n    }\n    if (typeof valueA.valueOf === 'function' &&\n        typeof valueB.valueOf === 'function') {\n      valueA = valueA.valueOf();\n      valueB = valueB.valueOf();\n      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {\n        return true;\n      }\n      if (!valueA || !valueB) {\n        return false;\n      }\n    }\n    if (typeof valueA.equals === 'function' &&\n        typeof valueB.equals === 'function' &&\n        valueA.equals(valueB)) {\n      return true;\n    }\n    return false;\n  }\n\n  function deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n\n    if (\n      !isIterable(b) ||\n      a.size !== undefined && b.size !== undefined && a.size !== b.size ||\n      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||\n      isKeyed(a) !== isKeyed(b) ||\n      isIndexed(a) !== isIndexed(b) ||\n      isOrdered(a) !== isOrdered(b)\n    ) {\n      return false;\n    }\n\n    if (a.size === 0 && b.size === 0) {\n      return true;\n    }\n\n    var notAssociative = !isAssociative(a);\n\n    if (isOrdered(a)) {\n      var entries = a.entries();\n      return b.every(function(v, k)  {\n        var entry = entries.next().value;\n        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));\n      }) && entries.next().done;\n    }\n\n    var flipped = false;\n\n    if (a.size === undefined) {\n      if (b.size === undefined) {\n        if (typeof a.cacheResult === 'function') {\n          a.cacheResult();\n        }\n      } else {\n        flipped = true;\n        var _ = a;\n        a = b;\n        b = _;\n      }\n    }\n\n    var allEqual = true;\n    var bSize = b.__iterate(function(v, k)  {\n      if (notAssociative ? !a.has(v) :\n          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {\n        allEqual = false;\n        return false;\n      }\n    });\n\n    return allEqual && a.size === bSize;\n  }\n\n  createClass(Repeat, IndexedSeq);\n\n    function Repeat(value, times) {\n      if (!(this instanceof Repeat)) {\n        return new Repeat(value, times);\n      }\n      this._value = value;\n      this.size = times === undefined ? Infinity : Math.max(0, times);\n      if (this.size === 0) {\n        if (EMPTY_REPEAT) {\n          return EMPTY_REPEAT;\n        }\n        EMPTY_REPEAT = this;\n      }\n    }\n\n    Repeat.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Repeat []';\n      }\n      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';\n    };\n\n    Repeat.prototype.get = function(index, notSetValue) {\n      return this.has(index) ? this._value : notSetValue;\n    };\n\n    Repeat.prototype.includes = function(searchValue) {\n      return is(this._value, searchValue);\n    };\n\n    Repeat.prototype.slice = function(begin, end) {\n      var size = this.size;\n      return wholeSlice(begin, end, size) ? this :\n        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));\n    };\n\n    Repeat.prototype.reverse = function() {\n      return this;\n    };\n\n    Repeat.prototype.indexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return 0;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.lastIndexOf = function(searchValue) {\n      if (is(this._value, searchValue)) {\n        return this.size;\n      }\n      return -1;\n    };\n\n    Repeat.prototype.__iterate = function(fn, reverse) {\n      for (var ii = 0; ii < this.size; ii++) {\n        if (fn(this._value, ii, this) === false) {\n          return ii + 1;\n        }\n      }\n      return ii;\n    };\n\n    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      var ii = 0;\n      return new Iterator(function() \n        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}\n      );\n    };\n\n    Repeat.prototype.equals = function(other) {\n      return other instanceof Repeat ?\n        is(this._value, other._value) :\n        deepEqual(other);\n    };\n\n\n  var EMPTY_REPEAT;\n\n  function invariant(condition, error) {\n    if (!condition) throw new Error(error);\n  }\n\n  createClass(Range, IndexedSeq);\n\n    function Range(start, end, step) {\n      if (!(this instanceof Range)) {\n        return new Range(start, end, step);\n      }\n      invariant(step !== 0, 'Cannot step a Range by 0');\n      start = start || 0;\n      if (end === undefined) {\n        end = Infinity;\n      }\n      step = step === undefined ? 1 : Math.abs(step);\n      if (end < start) {\n        step = -step;\n      }\n      this._start = start;\n      this._end = end;\n      this._step = step;\n      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);\n      if (this.size === 0) {\n        if (EMPTY_RANGE) {\n          return EMPTY_RANGE;\n        }\n        EMPTY_RANGE = this;\n      }\n    }\n\n    Range.prototype.toString = function() {\n      if (this.size === 0) {\n        return 'Range []';\n      }\n      return 'Range [ ' +\n        this._start + '...' + this._end +\n        (this._step !== 1 ? ' by ' + this._step : '') +\n      ' ]';\n    };\n\n    Range.prototype.get = function(index, notSetValue) {\n      return this.has(index) ?\n        this._start + wrapIndex(this, index) * this._step :\n        notSetValue;\n    };\n\n    Range.prototype.includes = function(searchValue) {\n      var possibleIndex = (searchValue - this._start) / this._step;\n      return possibleIndex >= 0 &&\n        possibleIndex < this.size &&\n        possibleIndex === Math.floor(possibleIndex);\n    };\n\n    Range.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      begin = resolveBegin(begin, this.size);\n      end = resolveEnd(end, this.size);\n      if (end <= begin) {\n        return new Range(0, 0);\n      }\n      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);\n    };\n\n    Range.prototype.indexOf = function(searchValue) {\n      var offsetValue = searchValue - this._start;\n      if (offsetValue % this._step === 0) {\n        var index = offsetValue / this._step;\n        if (index >= 0 && index < this.size) {\n          return index\n        }\n      }\n      return -1;\n    };\n\n    Range.prototype.lastIndexOf = function(searchValue) {\n      return this.indexOf(searchValue);\n    };\n\n    Range.prototype.__iterate = function(fn, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      for (var ii = 0; ii <= maxIndex; ii++) {\n        if (fn(value, ii, this) === false) {\n          return ii + 1;\n        }\n        value += reverse ? -step : step;\n      }\n      return ii;\n    };\n\n    Range.prototype.__iterator = function(type, reverse) {\n      var maxIndex = this.size - 1;\n      var step = this._step;\n      var value = reverse ? this._start + maxIndex * step : this._start;\n      var ii = 0;\n      return new Iterator(function()  {\n        var v = value;\n        value += reverse ? -step : step;\n        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);\n      });\n    };\n\n    Range.prototype.equals = function(other) {\n      return other instanceof Range ?\n        this._start === other._start &&\n        this._end === other._end &&\n        this._step === other._step :\n        deepEqual(this, other);\n    };\n\n\n  var EMPTY_RANGE;\n\n  createClass(Collection, Iterable);\n    function Collection() {\n      throw TypeError('Abstract');\n    }\n\n\n  createClass(KeyedCollection, Collection);function KeyedCollection() {}\n\n  createClass(IndexedCollection, Collection);function IndexedCollection() {}\n\n  createClass(SetCollection, Collection);function SetCollection() {}\n\n\n  Collection.Keyed = KeyedCollection;\n  Collection.Indexed = IndexedCollection;\n  Collection.Set = SetCollection;\n\n  var imul =\n    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?\n    Math.imul :\n    function imul(a, b) {\n      a = a | 0; // int\n      b = b | 0; // int\n      var c = a & 0xffff;\n      var d = b & 0xffff;\n      // Shift by 0 fixes the sign on the high part.\n      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int\n    };\n\n  // v8 has an optimization for storing 31-bit signed numbers.\n  // Values which have either 00 or 11 as the high order bits qualify.\n  // This function drops the highest order bit in a signed number, maintaining\n  // the sign bit.\n  function smi(i32) {\n    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);\n  }\n\n  function hash(o) {\n    if (o === false || o === null || o === undefined) {\n      return 0;\n    }\n    if (typeof o.valueOf === 'function') {\n      o = o.valueOf();\n      if (o === false || o === null || o === undefined) {\n        return 0;\n      }\n    }\n    if (o === true) {\n      return 1;\n    }\n    var type = typeof o;\n    if (type === 'number') {\n      if (o !== o || o === Infinity) {\n        return 0;\n      }\n      var h = o | 0;\n      if (h !== o) {\n        h ^= o * 0xFFFFFFFF;\n      }\n      while (o > 0xFFFFFFFF) {\n        o /= 0xFFFFFFFF;\n        h ^= o;\n      }\n      return smi(h);\n    }\n    if (type === 'string') {\n      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);\n    }\n    if (typeof o.hashCode === 'function') {\n      return o.hashCode();\n    }\n    if (type === 'object') {\n      return hashJSObj(o);\n    }\n    if (typeof o.toString === 'function') {\n      return hashString(o.toString());\n    }\n    throw new Error('Value type ' + type + ' cannot be hashed.');\n  }\n\n  function cachedHashString(string) {\n    var hash = stringHashCache[string];\n    if (hash === undefined) {\n      hash = hashString(string);\n      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {\n        STRING_HASH_CACHE_SIZE = 0;\n        stringHashCache = {};\n      }\n      STRING_HASH_CACHE_SIZE++;\n      stringHashCache[string] = hash;\n    }\n    return hash;\n  }\n\n  // http://jsperf.com/hashing-strings\n  function hashString(string) {\n    // This is the hash from JVM\n    // The hash code for a string is computed as\n    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],\n    // where s[i] is the ith character of the string and n is the length of\n    // the string. We \"mod\" the result to make it between 0 (inclusive) and 2^31\n    // (exclusive) by dropping high bits.\n    var hash = 0;\n    for (var ii = 0; ii < string.length; ii++) {\n      hash = 31 * hash + string.charCodeAt(ii) | 0;\n    }\n    return smi(hash);\n  }\n\n  function hashJSObj(obj) {\n    var hash;\n    if (usingWeakMap) {\n      hash = weakMap.get(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = obj[UID_HASH_KEY];\n    if (hash !== undefined) {\n      return hash;\n    }\n\n    if (!canDefineProperty) {\n      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];\n      if (hash !== undefined) {\n        return hash;\n      }\n\n      hash = getIENodeHash(obj);\n      if (hash !== undefined) {\n        return hash;\n      }\n    }\n\n    hash = ++objHashUID;\n    if (objHashUID & 0x40000000) {\n      objHashUID = 0;\n    }\n\n    if (usingWeakMap) {\n      weakMap.set(obj, hash);\n    } else if (isExtensible !== undefined && isExtensible(obj) === false) {\n      throw new Error('Non-extensible objects are not allowed as keys.');\n    } else if (canDefineProperty) {\n      Object.defineProperty(obj, UID_HASH_KEY, {\n        'enumerable': false,\n        'configurable': false,\n        'writable': false,\n        'value': hash\n      });\n    } else if (obj.propertyIsEnumerable !== undefined &&\n               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {\n      // Since we can't define a non-enumerable property on the object\n      // we'll hijack one of the less-used non-enumerable properties to\n      // save our hash on it. Since this is a function it will not show up in\n      // `JSON.stringify` which is what we want.\n      obj.propertyIsEnumerable = function() {\n        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);\n      };\n      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;\n    } else if (obj.nodeType !== undefined) {\n      // At this point we couldn't get the IE `uniqueID` to use as a hash\n      // and we couldn't use a non-enumerable property to exploit the\n      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node\n      // itself.\n      obj[UID_HASH_KEY] = hash;\n    } else {\n      throw new Error('Unable to set a non-enumerable property on object.');\n    }\n\n    return hash;\n  }\n\n  // Get references to ES5 object methods.\n  var isExtensible = Object.isExtensible;\n\n  // True if Object.defineProperty works as expected. IE8 fails this test.\n  var canDefineProperty = (function() {\n    try {\n      Object.defineProperty({}, '@', {});\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }());\n\n  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it\n  // and avoid memory leaks from the IE cloneNode bug.\n  function getIENodeHash(node) {\n    if (node && node.nodeType > 0) {\n      switch (node.nodeType) {\n        case 1: // Element\n          return node.uniqueID;\n        case 9: // Document\n          return node.documentElement && node.documentElement.uniqueID;\n      }\n    }\n  }\n\n  // If possible, use a WeakMap.\n  var usingWeakMap = typeof WeakMap === 'function';\n  var weakMap;\n  if (usingWeakMap) {\n    weakMap = new WeakMap();\n  }\n\n  var objHashUID = 0;\n\n  var UID_HASH_KEY = '__immutablehash__';\n  if (typeof Symbol === 'function') {\n    UID_HASH_KEY = Symbol(UID_HASH_KEY);\n  }\n\n  var STRING_HASH_CACHE_MIN_STRLEN = 16;\n  var STRING_HASH_CACHE_MAX_SIZE = 255;\n  var STRING_HASH_CACHE_SIZE = 0;\n  var stringHashCache = {};\n\n  function assertNotInfinite(size) {\n    invariant(\n      size !== Infinity,\n      'Cannot perform this action with an infinite size.'\n    );\n  }\n\n  createClass(Map, KeyedCollection);\n\n    // @pragma Construction\n\n    function Map(value) {\n      return value === null || value === undefined ? emptyMap() :\n        isMap(value) && !isOrdered(value) ? value :\n        emptyMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    Map.of = function() {var keyValues = SLICE$0.call(arguments, 0);\n      return emptyMap().withMutations(function(map ) {\n        for (var i = 0; i < keyValues.length; i += 2) {\n          if (i + 1 >= keyValues.length) {\n            throw new Error('Missing value for key: ' + keyValues[i]);\n          }\n          map.set(keyValues[i], keyValues[i + 1]);\n        }\n      });\n    };\n\n    Map.prototype.toString = function() {\n      return this.__toString('Map {', '}');\n    };\n\n    // @pragma Access\n\n    Map.prototype.get = function(k, notSetValue) {\n      return this._root ?\n        this._root.get(0, undefined, k, notSetValue) :\n        notSetValue;\n    };\n\n    // @pragma Modification\n\n    Map.prototype.set = function(k, v) {\n      return updateMap(this, k, v);\n    };\n\n    Map.prototype.setIn = function(keyPath, v) {\n      return this.updateIn(keyPath, NOT_SET, function()  {return v});\n    };\n\n    Map.prototype.remove = function(k) {\n      return updateMap(this, k, NOT_SET);\n    };\n\n    Map.prototype.deleteIn = function(keyPath) {\n      return this.updateIn(keyPath, function()  {return NOT_SET});\n    };\n\n    Map.prototype.update = function(k, notSetValue, updater) {\n      return arguments.length === 1 ?\n        k(this) :\n        this.updateIn([k], notSetValue, updater);\n    };\n\n    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {\n      if (!updater) {\n        updater = notSetValue;\n        notSetValue = undefined;\n      }\n      var updatedValue = updateInDeepMap(\n        this,\n        forceIterator(keyPath),\n        notSetValue,\n        updater\n      );\n      return updatedValue === NOT_SET ? undefined : updatedValue;\n    };\n\n    Map.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._root = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyMap();\n    };\n\n    // @pragma Composition\n\n    Map.prototype.merge = function(/*...iters*/) {\n      return mergeIntoMapWith(this, undefined, arguments);\n    };\n\n    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, merger, iters);\n    };\n\n    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.merge === 'function' ?\n          m.merge.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoMapWith(this, deepMerger, arguments);\n    };\n\n    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoMapWith(this, deepMergerWith(merger), iters);\n    };\n\n    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);\n      return this.updateIn(\n        keyPath,\n        emptyMap(),\n        function(m ) {return typeof m.mergeDeep === 'function' ?\n          m.mergeDeep.apply(m, iters) :\n          iters[iters.length - 1]}\n      );\n    };\n\n    Map.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator));\n    };\n\n    Map.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedMap(sortFactory(this, comparator, mapper));\n    };\n\n    // @pragma Mutability\n\n    Map.prototype.withMutations = function(fn) {\n      var mutable = this.asMutable();\n      fn(mutable);\n      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;\n    };\n\n    Map.prototype.asMutable = function() {\n      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());\n    };\n\n    Map.prototype.asImmutable = function() {\n      return this.__ensureOwner();\n    };\n\n    Map.prototype.wasAltered = function() {\n      return this.__altered;\n    };\n\n    Map.prototype.__iterator = function(type, reverse) {\n      return new MapIterator(this, type, reverse);\n    };\n\n    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      this._root && this._root.iterate(function(entry ) {\n        iterations++;\n        return fn(entry[1], entry[0], this$0);\n      }, reverse);\n      return iterations;\n    };\n\n    Map.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeMap(this.size, this._root, ownerID, this.__hash);\n    };\n\n\n  function isMap(maybeMap) {\n    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);\n  }\n\n  Map.isMap = isMap;\n\n  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';\n\n  var MapPrototype = Map.prototype;\n  MapPrototype[IS_MAP_SENTINEL] = true;\n  MapPrototype[DELETE] = MapPrototype.remove;\n  MapPrototype.removeIn = MapPrototype.deleteIn;\n\n\n  // #pragma Trie Nodes\n\n\n\n    function ArrayMapNode(ownerID, entries) {\n      this.ownerID = ownerID;\n      this.entries = entries;\n    }\n\n    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && entries.length === 1) {\n        return; // undefined\n      }\n\n      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {\n        return createNodes(ownerID, entries, key, value);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new ArrayMapNode(ownerID, newEntries);\n    };\n\n\n\n\n    function BitmapIndexedNode(ownerID, bitmap, nodes) {\n      this.ownerID = ownerID;\n      this.bitmap = bitmap;\n      this.nodes = nodes;\n    }\n\n    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));\n      var bitmap = this.bitmap;\n      return (bitmap & bit) === 0 ? notSetValue :\n        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);\n    };\n\n    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var bit = 1 << keyHashFrag;\n      var bitmap = this.bitmap;\n      var exists = (bitmap & bit) !== 0;\n\n      if (!exists && value === NOT_SET) {\n        return this;\n      }\n\n      var idx = popCount(bitmap & (bit - 1));\n      var nodes = this.nodes;\n      var node = exists ? nodes[idx] : undefined;\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n\n      if (newNode === node) {\n        return this;\n      }\n\n      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {\n        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);\n      }\n\n      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {\n        return nodes[idx ^ 1];\n      }\n\n      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {\n        return newNode;\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;\n      var newNodes = exists ? newNode ?\n        setIn(nodes, idx, newNode, isEditable) :\n        spliceOut(nodes, idx, isEditable) :\n        spliceIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.bitmap = newBitmap;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);\n    };\n\n\n\n\n    function HashArrayMapNode(ownerID, count, nodes) {\n      this.ownerID = ownerID;\n      this.count = count;\n      this.nodes = nodes;\n    }\n\n    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var node = this.nodes[idx];\n      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;\n    };\n\n    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n      var removed = value === NOT_SET;\n      var nodes = this.nodes;\n      var node = nodes[idx];\n\n      if (removed && !node) {\n        return this;\n      }\n\n      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);\n      if (newNode === node) {\n        return this;\n      }\n\n      var newCount = this.count;\n      if (!node) {\n        newCount++;\n      } else if (!newNode) {\n        newCount--;\n        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {\n          return packNodes(ownerID, nodes, newCount, idx);\n        }\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newNodes = setIn(nodes, idx, newNode, isEditable);\n\n      if (isEditable) {\n        this.count = newCount;\n        this.nodes = newNodes;\n        return this;\n      }\n\n      return new HashArrayMapNode(ownerID, newCount, newNodes);\n    };\n\n\n\n\n    function HashCollisionNode(ownerID, keyHash, entries) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entries = entries;\n    }\n\n    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      var entries = this.entries;\n      for (var ii = 0, len = entries.length; ii < len; ii++) {\n        if (is(key, entries[ii][0])) {\n          return entries[ii][1];\n        }\n      }\n      return notSetValue;\n    };\n\n    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      if (keyHash === undefined) {\n        keyHash = hash(key);\n      }\n\n      var removed = value === NOT_SET;\n\n      if (keyHash !== this.keyHash) {\n        if (removed) {\n          return this;\n        }\n        SetRef(didAlter);\n        SetRef(didChangeSize);\n        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);\n      }\n\n      var entries = this.entries;\n      var idx = 0;\n      for (var len = entries.length; idx < len; idx++) {\n        if (is(key, entries[idx][0])) {\n          break;\n        }\n      }\n      var exists = idx < len;\n\n      if (exists ? entries[idx][1] === value : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n      (removed || !exists) && SetRef(didChangeSize);\n\n      if (removed && len === 2) {\n        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);\n      }\n\n      var isEditable = ownerID && ownerID === this.ownerID;\n      var newEntries = isEditable ? entries : arrCopy(entries);\n\n      if (exists) {\n        if (removed) {\n          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());\n        } else {\n          newEntries[idx] = [key, value];\n        }\n      } else {\n        newEntries.push([key, value]);\n      }\n\n      if (isEditable) {\n        this.entries = newEntries;\n        return this;\n      }\n\n      return new HashCollisionNode(ownerID, this.keyHash, newEntries);\n    };\n\n\n\n\n    function ValueNode(ownerID, keyHash, entry) {\n      this.ownerID = ownerID;\n      this.keyHash = keyHash;\n      this.entry = entry;\n    }\n\n    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {\n      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;\n    };\n\n    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n      var removed = value === NOT_SET;\n      var keyMatch = is(key, this.entry[0]);\n      if (keyMatch ? value === this.entry[1] : removed) {\n        return this;\n      }\n\n      SetRef(didAlter);\n\n      if (removed) {\n        SetRef(didChangeSize);\n        return; // undefined\n      }\n\n      if (keyMatch) {\n        if (ownerID && ownerID === this.ownerID) {\n          this.entry[1] = value;\n          return this;\n        }\n        return new ValueNode(ownerID, this.keyHash, [key, value]);\n      }\n\n      SetRef(didChangeSize);\n      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);\n    };\n\n\n\n  // #pragma Iterators\n\n  ArrayMapNode.prototype.iterate =\n  HashCollisionNode.prototype.iterate = function (fn, reverse) {\n    var entries = this.entries;\n    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {\n      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {\n        return false;\n      }\n    }\n  }\n\n  BitmapIndexedNode.prototype.iterate =\n  HashArrayMapNode.prototype.iterate = function (fn, reverse) {\n    var nodes = this.nodes;\n    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {\n      var node = nodes[reverse ? maxIndex - ii : ii];\n      if (node && node.iterate(fn, reverse) === false) {\n        return false;\n      }\n    }\n  }\n\n  ValueNode.prototype.iterate = function (fn, reverse) {\n    return fn(this.entry);\n  }\n\n  createClass(MapIterator, Iterator);\n\n    function MapIterator(map, type, reverse) {\n      this._type = type;\n      this._reverse = reverse;\n      this._stack = map._root && mapIteratorFrame(map._root);\n    }\n\n    MapIterator.prototype.next = function() {\n      var type = this._type;\n      var stack = this._stack;\n      while (stack) {\n        var node = stack.node;\n        var index = stack.index++;\n        var maxIndex;\n        if (node.entry) {\n          if (index === 0) {\n            return mapIteratorValue(type, node.entry);\n          }\n        } else if (node.entries) {\n          maxIndex = node.entries.length - 1;\n          if (index <= maxIndex) {\n            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);\n          }\n        } else {\n          maxIndex = node.nodes.length - 1;\n          if (index <= maxIndex) {\n            var subNode = node.nodes[this._reverse ? maxIndex - index : index];\n            if (subNode) {\n              if (subNode.entry) {\n                return mapIteratorValue(type, subNode.entry);\n              }\n              stack = this._stack = mapIteratorFrame(subNode, stack);\n            }\n            continue;\n          }\n        }\n        stack = this._stack = this._stack.__prev;\n      }\n      return iteratorDone();\n    };\n\n\n  function mapIteratorValue(type, entry) {\n    return iteratorValue(type, entry[0], entry[1]);\n  }\n\n  function mapIteratorFrame(node, prev) {\n    return {\n      node: node,\n      index: 0,\n      __prev: prev\n    };\n  }\n\n  function makeMap(size, root, ownerID, hash) {\n    var map = Object.create(MapPrototype);\n    map.size = size;\n    map._root = root;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_MAP;\n  function emptyMap() {\n    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));\n  }\n\n  function updateMap(map, k, v) {\n    var newRoot;\n    var newSize;\n    if (!map._root) {\n      if (v === NOT_SET) {\n        return map;\n      }\n      newSize = 1;\n      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);\n    } else {\n      var didChangeSize = MakeRef(CHANGE_LENGTH);\n      var didAlter = MakeRef(DID_ALTER);\n      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);\n      if (!didAlter.value) {\n        return map;\n      }\n      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);\n    }\n    if (map.__ownerID) {\n      map.size = newSize;\n      map._root = newRoot;\n      map.__hash = undefined;\n      map.__altered = true;\n      return map;\n    }\n    return newRoot ? makeMap(newSize, newRoot) : emptyMap();\n  }\n\n  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {\n    if (!node) {\n      if (value === NOT_SET) {\n        return node;\n      }\n      SetRef(didAlter);\n      SetRef(didChangeSize);\n      return new ValueNode(ownerID, keyHash, [key, value]);\n    }\n    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);\n  }\n\n  function isLeafNode(node) {\n    return node.constructor === ValueNode || node.constructor === HashCollisionNode;\n  }\n\n  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {\n    if (node.keyHash === keyHash) {\n      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);\n    }\n\n    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;\n    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;\n\n    var newNode;\n    var nodes = idx1 === idx2 ?\n      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :\n      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);\n\n    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);\n  }\n\n  function createNodes(ownerID, entries, key, value) {\n    if (!ownerID) {\n      ownerID = new OwnerID();\n    }\n    var node = new ValueNode(ownerID, hash(key), [key, value]);\n    for (var ii = 0; ii < entries.length; ii++) {\n      var entry = entries[ii];\n      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);\n    }\n    return node;\n  }\n\n  function packNodes(ownerID, nodes, count, excluding) {\n    var bitmap = 0;\n    var packedII = 0;\n    var packedNodes = new Array(count);\n    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {\n      var node = nodes[ii];\n      if (node !== undefined && ii !== excluding) {\n        bitmap |= bit;\n        packedNodes[packedII++] = node;\n      }\n    }\n    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);\n  }\n\n  function expandNodes(ownerID, nodes, bitmap, including, node) {\n    var count = 0;\n    var expandedNodes = new Array(SIZE);\n    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {\n      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;\n    }\n    expandedNodes[including] = node;\n    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);\n  }\n\n  function mergeIntoMapWith(map, merger, iterables) {\n    var iters = [];\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = KeyedIterable(value);\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    return mergeIntoCollectionWith(map, merger, iters);\n  }\n\n  function deepMerger(existing, value, key) {\n    return existing && existing.mergeDeep && isIterable(value) ?\n      existing.mergeDeep(value) :\n      is(existing, value) ? existing : value;\n  }\n\n  function deepMergerWith(merger) {\n    return function(existing, value, key)  {\n      if (existing && existing.mergeDeepWith && isIterable(value)) {\n        return existing.mergeDeepWith(merger, value);\n      }\n      var nextValue = merger(existing, value, key);\n      return is(existing, nextValue) ? existing : nextValue;\n    };\n  }\n\n  function mergeIntoCollectionWith(collection, merger, iters) {\n    iters = iters.filter(function(x ) {return x.size !== 0});\n    if (iters.length === 0) {\n      return collection;\n    }\n    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {\n      return collection.constructor(iters[0]);\n    }\n    return collection.withMutations(function(collection ) {\n      var mergeIntoMap = merger ?\n        function(value, key)  {\n          collection.update(key, NOT_SET, function(existing )\n            {return existing === NOT_SET ? value : merger(existing, value, key)}\n          );\n        } :\n        function(value, key)  {\n          collection.set(key, value);\n        }\n      for (var ii = 0; ii < iters.length; ii++) {\n        iters[ii].forEach(mergeIntoMap);\n      }\n    });\n  }\n\n  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {\n    var isNotSet = existing === NOT_SET;\n    var step = keyPathIter.next();\n    if (step.done) {\n      var existingValue = isNotSet ? notSetValue : existing;\n      var newValue = updater(existingValue);\n      return newValue === existingValue ? existing : newValue;\n    }\n    invariant(\n      isNotSet || (existing && existing.set),\n      'invalid keyPath'\n    );\n    var key = step.value;\n    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);\n    var nextUpdated = updateInDeepMap(\n      nextExisting,\n      keyPathIter,\n      notSetValue,\n      updater\n    );\n    return nextUpdated === nextExisting ? existing :\n      nextUpdated === NOT_SET ? existing.remove(key) :\n      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);\n  }\n\n  function popCount(x) {\n    x = x - ((x >> 1) & 0x55555555);\n    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n    x = (x + (x >> 4)) & 0x0f0f0f0f;\n    x = x + (x >> 8);\n    x = x + (x >> 16);\n    return x & 0x7f;\n  }\n\n  function setIn(array, idx, val, canEdit) {\n    var newArray = canEdit ? array : arrCopy(array);\n    newArray[idx] = val;\n    return newArray;\n  }\n\n  function spliceIn(array, idx, val, canEdit) {\n    var newLen = array.length + 1;\n    if (canEdit && idx + 1 === newLen) {\n      array[idx] = val;\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        newArray[ii] = val;\n        after = -1;\n      } else {\n        newArray[ii] = array[ii + after];\n      }\n    }\n    return newArray;\n  }\n\n  function spliceOut(array, idx, canEdit) {\n    var newLen = array.length - 1;\n    if (canEdit && idx === newLen) {\n      array.pop();\n      return array;\n    }\n    var newArray = new Array(newLen);\n    var after = 0;\n    for (var ii = 0; ii < newLen; ii++) {\n      if (ii === idx) {\n        after = 1;\n      }\n      newArray[ii] = array[ii + after];\n    }\n    return newArray;\n  }\n\n  var MAX_ARRAY_MAP_SIZE = SIZE / 4;\n  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;\n  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;\n\n  createClass(List, IndexedCollection);\n\n    // @pragma Construction\n\n    function List(value) {\n      var empty = emptyList();\n      if (value === null || value === undefined) {\n        return empty;\n      }\n      if (isList(value)) {\n        return value;\n      }\n      var iter = IndexedIterable(value);\n      var size = iter.size;\n      if (size === 0) {\n        return empty;\n      }\n      assertNotInfinite(size);\n      if (size > 0 && size < SIZE) {\n        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));\n      }\n      return empty.withMutations(function(list ) {\n        list.setSize(size);\n        iter.forEach(function(v, i)  {return list.set(i, v)});\n      });\n    }\n\n    List.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    List.prototype.toString = function() {\n      return this.__toString('List [', ']');\n    };\n\n    // @pragma Access\n\n    List.prototype.get = function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      if (index >= 0 && index < this.size) {\n        index += this._origin;\n        var node = listNodeFor(this, index);\n        return node && node.array[index & MASK];\n      }\n      return notSetValue;\n    };\n\n    // @pragma Modification\n\n    List.prototype.set = function(index, value) {\n      return updateList(this, index, value);\n    };\n\n    List.prototype.remove = function(index) {\n      return !this.has(index) ? this :\n        index === 0 ? this.shift() :\n        index === this.size - 1 ? this.pop() :\n        this.splice(index, 1);\n    };\n\n    List.prototype.insert = function(index, value) {\n      return this.splice(index, 0, value);\n    };\n\n    List.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = this._origin = this._capacity = 0;\n        this._level = SHIFT;\n        this._root = this._tail = null;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyList();\n    };\n\n    List.prototype.push = function(/*...values*/) {\n      var values = arguments;\n      var oldSize = this.size;\n      return this.withMutations(function(list ) {\n        setListBounds(list, 0, oldSize + values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(oldSize + ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.pop = function() {\n      return setListBounds(this, 0, -1);\n    };\n\n    List.prototype.unshift = function(/*...values*/) {\n      var values = arguments;\n      return this.withMutations(function(list ) {\n        setListBounds(list, -values.length);\n        for (var ii = 0; ii < values.length; ii++) {\n          list.set(ii, values[ii]);\n        }\n      });\n    };\n\n    List.prototype.shift = function() {\n      return setListBounds(this, 1);\n    };\n\n    // @pragma Composition\n\n    List.prototype.merge = function(/*...iters*/) {\n      return mergeIntoListWith(this, undefined, arguments);\n    };\n\n    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, merger, iters);\n    };\n\n    List.prototype.mergeDeep = function(/*...iters*/) {\n      return mergeIntoListWith(this, deepMerger, arguments);\n    };\n\n    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return mergeIntoListWith(this, deepMergerWith(merger), iters);\n    };\n\n    List.prototype.setSize = function(size) {\n      return setListBounds(this, 0, size);\n    };\n\n    // @pragma Iteration\n\n    List.prototype.slice = function(begin, end) {\n      var size = this.size;\n      if (wholeSlice(begin, end, size)) {\n        return this;\n      }\n      return setListBounds(\n        this,\n        resolveBegin(begin, size),\n        resolveEnd(end, size)\n      );\n    };\n\n    List.prototype.__iterator = function(type, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      return new Iterator(function()  {\n        var value = values();\n        return value === DONE ?\n          iteratorDone() :\n          iteratorValue(type, index++, value);\n      });\n    };\n\n    List.prototype.__iterate = function(fn, reverse) {\n      var index = 0;\n      var values = iterateList(this, reverse);\n      var value;\n      while ((value = values()) !== DONE) {\n        if (fn(value, index++, this) === false) {\n          break;\n        }\n      }\n      return index;\n    };\n\n    List.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        return this;\n      }\n      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);\n    };\n\n\n  function isList(maybeList) {\n    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);\n  }\n\n  List.isList = isList;\n\n  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';\n\n  var ListPrototype = List.prototype;\n  ListPrototype[IS_LIST_SENTINEL] = true;\n  ListPrototype[DELETE] = ListPrototype.remove;\n  ListPrototype.setIn = MapPrototype.setIn;\n  ListPrototype.deleteIn =\n  ListPrototype.removeIn = MapPrototype.removeIn;\n  ListPrototype.update = MapPrototype.update;\n  ListPrototype.updateIn = MapPrototype.updateIn;\n  ListPrototype.mergeIn = MapPrototype.mergeIn;\n  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  ListPrototype.withMutations = MapPrototype.withMutations;\n  ListPrototype.asMutable = MapPrototype.asMutable;\n  ListPrototype.asImmutable = MapPrototype.asImmutable;\n  ListPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n\n    function VNode(array, ownerID) {\n      this.array = array;\n      this.ownerID = ownerID;\n    }\n\n    // TODO: seems like these methods are very similar\n\n    VNode.prototype.removeBefore = function(ownerID, level, index) {\n      if (index === level ? 1 << level :  false || this.array.length === 0) {\n        return this;\n      }\n      var originIndex = (index >>> level) & MASK;\n      if (originIndex >= this.array.length) {\n        return new VNode([], ownerID);\n      }\n      var removingFirst = originIndex === 0;\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[originIndex];\n        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && removingFirst) {\n          return this;\n        }\n      }\n      if (removingFirst && !newChild) {\n        return this;\n      }\n      var editable = editableVNode(this, ownerID);\n      if (!removingFirst) {\n        for (var ii = 0; ii < originIndex; ii++) {\n          editable.array[ii] = undefined;\n        }\n      }\n      if (newChild) {\n        editable.array[originIndex] = newChild;\n      }\n      return editable;\n    };\n\n    VNode.prototype.removeAfter = function(ownerID, level, index) {\n      if (index === (level ? 1 << level : 0) || this.array.length === 0) {\n        return this;\n      }\n      var sizeIndex = ((index - 1) >>> level) & MASK;\n      if (sizeIndex >= this.array.length) {\n        return this;\n      }\n\n      var newChild;\n      if (level > 0) {\n        var oldChild = this.array[sizeIndex];\n        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);\n        if (newChild === oldChild && sizeIndex === this.array.length - 1) {\n          return this;\n        }\n      }\n\n      var editable = editableVNode(this, ownerID);\n      editable.array.splice(sizeIndex + 1);\n      if (newChild) {\n        editable.array[sizeIndex] = newChild;\n      }\n      return editable;\n    };\n\n\n\n  var DONE = {};\n\n  function iterateList(list, reverse) {\n    var left = list._origin;\n    var right = list._capacity;\n    var tailPos = getTailOffset(right);\n    var tail = list._tail;\n\n    return iterateNodeOrLeaf(list._root, list._level, 0);\n\n    function iterateNodeOrLeaf(node, level, offset) {\n      return level === 0 ?\n        iterateLeaf(node, offset) :\n        iterateNode(node, level, offset);\n    }\n\n    function iterateLeaf(node, offset) {\n      var array = offset === tailPos ? tail && tail.array : node && node.array;\n      var from = offset > left ? 0 : left - offset;\n      var to = right - offset;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        if (from === to) {\n          return DONE;\n        }\n        var idx = reverse ? --to : from++;\n        return array && array[idx];\n      };\n    }\n\n    function iterateNode(node, level, offset) {\n      var values;\n      var array = node && node.array;\n      var from = offset > left ? 0 : (left - offset) >> level;\n      var to = ((right - offset) >> level) + 1;\n      if (to > SIZE) {\n        to = SIZE;\n      }\n      return function()  {\n        do {\n          if (values) {\n            var value = values();\n            if (value !== DONE) {\n              return value;\n            }\n            values = null;\n          }\n          if (from === to) {\n            return DONE;\n          }\n          var idx = reverse ? --to : from++;\n          values = iterateNodeOrLeaf(\n            array && array[idx], level - SHIFT, offset + (idx << level)\n          );\n        } while (true);\n      };\n    }\n  }\n\n  function makeList(origin, capacity, level, root, tail, ownerID, hash) {\n    var list = Object.create(ListPrototype);\n    list.size = capacity - origin;\n    list._origin = origin;\n    list._capacity = capacity;\n    list._level = level;\n    list._root = root;\n    list._tail = tail;\n    list.__ownerID = ownerID;\n    list.__hash = hash;\n    list.__altered = false;\n    return list;\n  }\n\n  var EMPTY_LIST;\n  function emptyList() {\n    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));\n  }\n\n  function updateList(list, index, value) {\n    index = wrapIndex(list, index);\n\n    if (index !== index) {\n      return list;\n    }\n\n    if (index >= list.size || index < 0) {\n      return list.withMutations(function(list ) {\n        index < 0 ?\n          setListBounds(list, index).set(0, value) :\n          setListBounds(list, 0, index + 1).set(index, value)\n      });\n    }\n\n    index += list._origin;\n\n    var newTail = list._tail;\n    var newRoot = list._root;\n    var didAlter = MakeRef(DID_ALTER);\n    if (index >= getTailOffset(list._capacity)) {\n      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);\n    } else {\n      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);\n    }\n\n    if (!didAlter.value) {\n      return list;\n    }\n\n    if (list.__ownerID) {\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);\n  }\n\n  function updateVNode(node, ownerID, level, index, value, didAlter) {\n    var idx = (index >>> level) & MASK;\n    var nodeHas = node && idx < node.array.length;\n    if (!nodeHas && value === undefined) {\n      return node;\n    }\n\n    var newNode;\n\n    if (level > 0) {\n      var lowerNode = node && node.array[idx];\n      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);\n      if (newLowerNode === lowerNode) {\n        return node;\n      }\n      newNode = editableVNode(node, ownerID);\n      newNode.array[idx] = newLowerNode;\n      return newNode;\n    }\n\n    if (nodeHas && node.array[idx] === value) {\n      return node;\n    }\n\n    SetRef(didAlter);\n\n    newNode = editableVNode(node, ownerID);\n    if (value === undefined && idx === newNode.array.length - 1) {\n      newNode.array.pop();\n    } else {\n      newNode.array[idx] = value;\n    }\n    return newNode;\n  }\n\n  function editableVNode(node, ownerID) {\n    if (ownerID && node && ownerID === node.ownerID) {\n      return node;\n    }\n    return new VNode(node ? node.array.slice() : [], ownerID);\n  }\n\n  function listNodeFor(list, rawIndex) {\n    if (rawIndex >= getTailOffset(list._capacity)) {\n      return list._tail;\n    }\n    if (rawIndex < 1 << (list._level + SHIFT)) {\n      var node = list._root;\n      var level = list._level;\n      while (node && level > 0) {\n        node = node.array[(rawIndex >>> level) & MASK];\n        level -= SHIFT;\n      }\n      return node;\n    }\n  }\n\n  function setListBounds(list, begin, end) {\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      end = end | 0;\n    }\n    var owner = list.__ownerID || new OwnerID();\n    var oldOrigin = list._origin;\n    var oldCapacity = list._capacity;\n    var newOrigin = oldOrigin + begin;\n    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;\n    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {\n      return list;\n    }\n\n    // If it's going to end after it starts, it's empty.\n    if (newOrigin >= newCapacity) {\n      return list.clear();\n    }\n\n    var newLevel = list._level;\n    var newRoot = list._root;\n\n    // New origin might need creating a higher root.\n    var offsetShift = 0;\n    while (newOrigin + offsetShift < 0) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);\n      newLevel += SHIFT;\n      offsetShift += 1 << newLevel;\n    }\n    if (offsetShift) {\n      newOrigin += offsetShift;\n      oldOrigin += offsetShift;\n      newCapacity += offsetShift;\n      oldCapacity += offsetShift;\n    }\n\n    var oldTailOffset = getTailOffset(oldCapacity);\n    var newTailOffset = getTailOffset(newCapacity);\n\n    // New size might need creating a higher root.\n    while (newTailOffset >= 1 << (newLevel + SHIFT)) {\n      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);\n      newLevel += SHIFT;\n    }\n\n    // Locate or create the new tail.\n    var oldTail = list._tail;\n    var newTail = newTailOffset < oldTailOffset ?\n      listNodeFor(list, newCapacity - 1) :\n      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;\n\n    // Merge Tail into tree.\n    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {\n      newRoot = editableVNode(newRoot, owner);\n      var node = newRoot;\n      for (var level = newLevel; level > SHIFT; level -= SHIFT) {\n        var idx = (oldTailOffset >>> level) & MASK;\n        node = node.array[idx] = editableVNode(node.array[idx], owner);\n      }\n      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;\n    }\n\n    // If the size has been reduced, there's a chance the tail needs to be trimmed.\n    if (newCapacity < oldCapacity) {\n      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);\n    }\n\n    // If the new origin is within the tail, then we do not need a root.\n    if (newOrigin >= newTailOffset) {\n      newOrigin -= newTailOffset;\n      newCapacity -= newTailOffset;\n      newLevel = SHIFT;\n      newRoot = null;\n      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);\n\n    // Otherwise, if the root has been trimmed, garbage collect.\n    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {\n      offsetShift = 0;\n\n      // Identify the new top root node of the subtree of the old root.\n      while (newRoot) {\n        var beginIndex = (newOrigin >>> newLevel) & MASK;\n        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {\n          break;\n        }\n        if (beginIndex) {\n          offsetShift += (1 << newLevel) * beginIndex;\n        }\n        newLevel -= SHIFT;\n        newRoot = newRoot.array[beginIndex];\n      }\n\n      // Trim the new sides of the new root.\n      if (newRoot && newOrigin > oldOrigin) {\n        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);\n      }\n      if (newRoot && newTailOffset < oldTailOffset) {\n        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);\n      }\n      if (offsetShift) {\n        newOrigin -= offsetShift;\n        newCapacity -= offsetShift;\n      }\n    }\n\n    if (list.__ownerID) {\n      list.size = newCapacity - newOrigin;\n      list._origin = newOrigin;\n      list._capacity = newCapacity;\n      list._level = newLevel;\n      list._root = newRoot;\n      list._tail = newTail;\n      list.__hash = undefined;\n      list.__altered = true;\n      return list;\n    }\n    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);\n  }\n\n  function mergeIntoListWith(list, merger, iterables) {\n    var iters = [];\n    var maxSize = 0;\n    for (var ii = 0; ii < iterables.length; ii++) {\n      var value = iterables[ii];\n      var iter = IndexedIterable(value);\n      if (iter.size > maxSize) {\n        maxSize = iter.size;\n      }\n      if (!isIterable(value)) {\n        iter = iter.map(function(v ) {return fromJS(v)});\n      }\n      iters.push(iter);\n    }\n    if (maxSize > list.size) {\n      list = list.setSize(maxSize);\n    }\n    return mergeIntoCollectionWith(list, merger, iters);\n  }\n\n  function getTailOffset(size) {\n    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);\n  }\n\n  createClass(OrderedMap, Map);\n\n    // @pragma Construction\n\n    function OrderedMap(value) {\n      return value === null || value === undefined ? emptyOrderedMap() :\n        isOrderedMap(value) ? value :\n        emptyOrderedMap().withMutations(function(map ) {\n          var iter = KeyedIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v, k)  {return map.set(k, v)});\n        });\n    }\n\n    OrderedMap.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedMap.prototype.toString = function() {\n      return this.__toString('OrderedMap {', '}');\n    };\n\n    // @pragma Access\n\n    OrderedMap.prototype.get = function(k, notSetValue) {\n      var index = this._map.get(k);\n      return index !== undefined ? this._list.get(index)[1] : notSetValue;\n    };\n\n    // @pragma Modification\n\n    OrderedMap.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._map.clear();\n        this._list.clear();\n        return this;\n      }\n      return emptyOrderedMap();\n    };\n\n    OrderedMap.prototype.set = function(k, v) {\n      return updateOrderedMap(this, k, v);\n    };\n\n    OrderedMap.prototype.remove = function(k) {\n      return updateOrderedMap(this, k, NOT_SET);\n    };\n\n    OrderedMap.prototype.wasAltered = function() {\n      return this._map.wasAltered() || this._list.wasAltered();\n    };\n\n    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._list.__iterate(\n        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},\n        reverse\n      );\n    };\n\n    OrderedMap.prototype.__iterator = function(type, reverse) {\n      return this._list.fromEntrySeq().__iterator(type, reverse);\n    };\n\n    OrderedMap.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      var newList = this._list.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        this._list = newList;\n        return this;\n      }\n      return makeOrderedMap(newMap, newList, ownerID, this.__hash);\n    };\n\n\n  function isOrderedMap(maybeOrderedMap) {\n    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);\n  }\n\n  OrderedMap.isOrderedMap = isOrderedMap;\n\n  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;\n  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;\n\n\n\n  function makeOrderedMap(map, list, ownerID, hash) {\n    var omap = Object.create(OrderedMap.prototype);\n    omap.size = map ? map.size : 0;\n    omap._map = map;\n    omap._list = list;\n    omap.__ownerID = ownerID;\n    omap.__hash = hash;\n    return omap;\n  }\n\n  var EMPTY_ORDERED_MAP;\n  function emptyOrderedMap() {\n    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));\n  }\n\n  function updateOrderedMap(omap, k, v) {\n    var map = omap._map;\n    var list = omap._list;\n    var i = map.get(k);\n    var has = i !== undefined;\n    var newMap;\n    var newList;\n    if (v === NOT_SET) { // removed\n      if (!has) {\n        return omap;\n      }\n      if (list.size >= SIZE && list.size >= map.size * 2) {\n        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});\n        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();\n        if (omap.__ownerID) {\n          newMap.__ownerID = newList.__ownerID = omap.__ownerID;\n        }\n      } else {\n        newMap = map.remove(k);\n        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);\n      }\n    } else {\n      if (has) {\n        if (v === list.get(i)[1]) {\n          return omap;\n        }\n        newMap = map;\n        newList = list.set(i, [k, v]);\n      } else {\n        newMap = map.set(k, list.size);\n        newList = list.set(list.size, [k, v]);\n      }\n    }\n    if (omap.__ownerID) {\n      omap.size = newMap.size;\n      omap._map = newMap;\n      omap._list = newList;\n      omap.__hash = undefined;\n      return omap;\n    }\n    return makeOrderedMap(newMap, newList);\n  }\n\n  createClass(ToKeyedSequence, KeyedSeq);\n    function ToKeyedSequence(indexed, useKeys) {\n      this._iter = indexed;\n      this._useKeys = useKeys;\n      this.size = indexed.size;\n    }\n\n    ToKeyedSequence.prototype.get = function(key, notSetValue) {\n      return this._iter.get(key, notSetValue);\n    };\n\n    ToKeyedSequence.prototype.has = function(key) {\n      return this._iter.has(key);\n    };\n\n    ToKeyedSequence.prototype.valueSeq = function() {\n      return this._iter.valueSeq();\n    };\n\n    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;\n      var reversedSequence = reverseFactory(this, true);\n      if (!this._useKeys) {\n        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};\n      }\n      return reversedSequence;\n    };\n\n    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;\n      var mappedSequence = mapFactory(this, mapper, context);\n      if (!this._useKeys) {\n        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};\n      }\n      return mappedSequence;\n    };\n\n    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var ii;\n      return this._iter.__iterate(\n        this._useKeys ?\n          function(v, k)  {return fn(v, k, this$0)} :\n          ((ii = reverse ? resolveSize(this) : 0),\n            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),\n        reverse\n      );\n    };\n\n    ToKeyedSequence.prototype.__iterator = function(type, reverse) {\n      if (this._useKeys) {\n        return this._iter.__iterator(type, reverse);\n      }\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var ii = reverse ? resolveSize(this) : 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, reverse ? --ii : ii++, step.value, step);\n      });\n    };\n\n  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n  createClass(ToIndexedSequence, IndexedSeq);\n    function ToIndexedSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToIndexedSequence.prototype.includes = function(value) {\n      return this._iter.includes(value);\n    };\n\n    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);\n    };\n\n    ToIndexedSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, iterations++, step.value, step)\n      });\n    };\n\n\n\n  createClass(ToSetSequence, SetSeq);\n    function ToSetSequence(iter) {\n      this._iter = iter;\n      this.size = iter.size;\n    }\n\n    ToSetSequence.prototype.has = function(key) {\n      return this._iter.includes(key);\n    };\n\n    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);\n    };\n\n    ToSetSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        return step.done ? step :\n          iteratorValue(type, step.value, step.value, step);\n      });\n    };\n\n\n\n  createClass(FromEntriesSequence, KeyedSeq);\n    function FromEntriesSequence(entries) {\n      this._iter = entries;\n      this.size = entries.size;\n    }\n\n    FromEntriesSequence.prototype.entrySeq = function() {\n      return this._iter.toSeq();\n    };\n\n    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._iter.__iterate(function(entry ) {\n        // Check if entry exists first so array access doesn't throw for holes\n        // in the parent iteration.\n        if (entry) {\n          validateEntry(entry);\n          var indexedIterable = isIterable(entry);\n          return fn(\n            indexedIterable ? entry.get(1) : entry[1],\n            indexedIterable ? entry.get(0) : entry[0],\n            this$0\n          );\n        }\n      }, reverse);\n    };\n\n    FromEntriesSequence.prototype.__iterator = function(type, reverse) {\n      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          // Check if entry exists first so array access doesn't throw for holes\n          // in the parent iteration.\n          if (entry) {\n            validateEntry(entry);\n            var indexedIterable = isIterable(entry);\n            return iteratorValue(\n              type,\n              indexedIterable ? entry.get(0) : entry[0],\n              indexedIterable ? entry.get(1) : entry[1],\n              step\n            );\n          }\n        }\n      });\n    };\n\n\n  ToIndexedSequence.prototype.cacheResult =\n  ToKeyedSequence.prototype.cacheResult =\n  ToSetSequence.prototype.cacheResult =\n  FromEntriesSequence.prototype.cacheResult =\n    cacheResultThrough;\n\n\n  function flipFactory(iterable) {\n    var flipSequence = makeSequence(iterable);\n    flipSequence._iter = iterable;\n    flipSequence.size = iterable.size;\n    flipSequence.flip = function()  {return iterable};\n    flipSequence.reverse = function () {\n      var reversedSequence = iterable.reverse.apply(this); // super.reverse()\n      reversedSequence.flip = function()  {return iterable.reverse()};\n      return reversedSequence;\n    };\n    flipSequence.has = function(key ) {return iterable.includes(key)};\n    flipSequence.includes = function(key ) {return iterable.has(key)};\n    flipSequence.cacheResult = cacheResultThrough;\n    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);\n    }\n    flipSequence.__iteratorUncached = function(type, reverse) {\n      if (type === ITERATE_ENTRIES) {\n        var iterator = iterable.__iterator(type, reverse);\n        return new Iterator(function()  {\n          var step = iterator.next();\n          if (!step.done) {\n            var k = step.value[0];\n            step.value[0] = step.value[1];\n            step.value[1] = k;\n          }\n          return step;\n        });\n      }\n      return iterable.__iterator(\n        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,\n        reverse\n      );\n    }\n    return flipSequence;\n  }\n\n\n  function mapFactory(iterable, mapper, context) {\n    var mappedSequence = makeSequence(iterable);\n    mappedSequence.size = iterable.size;\n    mappedSequence.has = function(key ) {return iterable.has(key)};\n    mappedSequence.get = function(key, notSetValue)  {\n      var v = iterable.get(key, NOT_SET);\n      return v === NOT_SET ?\n        notSetValue :\n        mapper.call(context, v, key, iterable);\n    };\n    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(\n        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},\n        reverse\n      );\n    }\n    mappedSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      return new Iterator(function()  {\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var key = entry[0];\n        return iteratorValue(\n          type,\n          key,\n          mapper.call(context, entry[1], key, iterable),\n          step\n        );\n      });\n    }\n    return mappedSequence;\n  }\n\n\n  function reverseFactory(iterable, useKeys) {\n    var reversedSequence = makeSequence(iterable);\n    reversedSequence._iter = iterable;\n    reversedSequence.size = iterable.size;\n    reversedSequence.reverse = function()  {return iterable};\n    if (iterable.flip) {\n      reversedSequence.flip = function () {\n        var flipSequence = flipFactory(iterable);\n        flipSequence.reverse = function()  {return iterable.flip()};\n        return flipSequence;\n      };\n    }\n    reversedSequence.get = function(key, notSetValue) \n      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};\n    reversedSequence.has = function(key )\n      {return iterable.has(useKeys ? key : -1 - key)};\n    reversedSequence.includes = function(value ) {return iterable.includes(value)};\n    reversedSequence.cacheResult = cacheResultThrough;\n    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;\n      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);\n    };\n    reversedSequence.__iterator =\n      function(type, reverse)  {return iterable.__iterator(type, !reverse)};\n    return reversedSequence;\n  }\n\n\n  function filterFactory(iterable, predicate, context, useKeys) {\n    var filterSequence = makeSequence(iterable);\n    if (useKeys) {\n      filterSequence.has = function(key ) {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);\n      };\n      filterSequence.get = function(key, notSetValue)  {\n        var v = iterable.get(key, NOT_SET);\n        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?\n          v : notSetValue;\n      };\n    }\n    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      }, reverse);\n      return iterations;\n    };\n    filterSequence.__iteratorUncached = function (type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (true) {\n          var step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n          var entry = step.value;\n          var key = entry[0];\n          var value = entry[1];\n          if (predicate.call(context, value, key, iterable)) {\n            return iteratorValue(type, useKeys ? key : iterations++, value, step);\n          }\n        }\n      });\n    }\n    return filterSequence;\n  }\n\n\n  function countByFactory(iterable, grouper, context) {\n    var groups = Map().asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        0,\n        function(a ) {return a + 1}\n      );\n    });\n    return groups.asImmutable();\n  }\n\n\n  function groupByFactory(iterable, grouper, context) {\n    var isKeyedIter = isKeyed(iterable);\n    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();\n    iterable.__iterate(function(v, k)  {\n      groups.update(\n        grouper.call(context, v, k, iterable),\n        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}\n      );\n    });\n    var coerce = iterableClass(iterable);\n    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});\n  }\n\n\n  function sliceFactory(iterable, begin, end, useKeys) {\n    var originalSize = iterable.size;\n\n    // Sanitize begin & end using this shorthand for ToInt32(argument)\n    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32\n    if (begin !== undefined) {\n      begin = begin | 0;\n    }\n    if (end !== undefined) {\n      if (end === Infinity) {\n        end = originalSize;\n      } else {\n        end = end | 0;\n      }\n    }\n\n    if (wholeSlice(begin, end, originalSize)) {\n      return iterable;\n    }\n\n    var resolvedBegin = resolveBegin(begin, originalSize);\n    var resolvedEnd = resolveEnd(end, originalSize);\n\n    // begin or end will be NaN if they were provided as negative numbers and\n    // this iterable's size is unknown. In that case, cache first so there is\n    // a known size and these do not resolve to NaN.\n    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {\n      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);\n    }\n\n    // Note: resolvedEnd is undefined when the original sequence's length is\n    // unknown and this slice did not supply an end and should contain all\n    // elements after resolvedBegin.\n    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.\n    var resolvedSize = resolvedEnd - resolvedBegin;\n    var sliceSize;\n    if (resolvedSize === resolvedSize) {\n      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;\n    }\n\n    var sliceSeq = makeSequence(iterable);\n\n    // If iterable.size is undefined, the size of the realized sliceSeq is\n    // unknown at this point unless the number of items to slice is 0\n    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;\n\n    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {\n      sliceSeq.get = function (index, notSetValue) {\n        index = wrapIndex(this, index);\n        return index >= 0 && index < sliceSize ?\n          iterable.get(index + resolvedBegin, notSetValue) :\n          notSetValue;\n      }\n    }\n\n    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (sliceSize === 0) {\n        return 0;\n      }\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var skipped = 0;\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k)  {\n        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&\n                 iterations !== sliceSize;\n        }\n      });\n      return iterations;\n    };\n\n    sliceSeq.__iteratorUncached = function(type, reverse) {\n      if (sliceSize !== 0 && reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      // Don't bother instantiating parent iterator if taking 0.\n      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);\n      var skipped = 0;\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (skipped++ < resolvedBegin) {\n          iterator.next();\n        }\n        if (++iterations > sliceSize) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (useKeys || type === ITERATE_VALUES) {\n          return step;\n        } else if (type === ITERATE_KEYS) {\n          return iteratorValue(type, iterations - 1, undefined, step);\n        } else {\n          return iteratorValue(type, iterations - 1, step.value[1], step);\n        }\n      });\n    }\n\n    return sliceSeq;\n  }\n\n\n  function takeWhileFactory(iterable, predicate, context) {\n    var takeSequence = makeSequence(iterable);\n    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c) \n        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}\n      );\n      return iterations;\n    };\n    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var iterating = true;\n      return new Iterator(function()  {\n        if (!iterating) {\n          return iteratorDone();\n        }\n        var step = iterator.next();\n        if (step.done) {\n          return step;\n        }\n        var entry = step.value;\n        var k = entry[0];\n        var v = entry[1];\n        if (!predicate.call(context, v, k, this$0)) {\n          iterating = false;\n          return iteratorDone();\n        }\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return takeSequence;\n  }\n\n\n  function skipWhileFactory(iterable, predicate, context, useKeys) {\n    var skipSequence = makeSequence(iterable);\n    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterate(fn, reverse);\n      }\n      var isSkipping = true;\n      var iterations = 0;\n      iterable.__iterate(function(v, k, c)  {\n        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {\n          iterations++;\n          return fn(v, useKeys ? k : iterations - 1, this$0);\n        }\n      });\n      return iterations;\n    };\n    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;\n      if (reverse) {\n        return this.cacheResult().__iterator(type, reverse);\n      }\n      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);\n      var skipping = true;\n      var iterations = 0;\n      return new Iterator(function()  {\n        var step, k, v;\n        do {\n          step = iterator.next();\n          if (step.done) {\n            if (useKeys || type === ITERATE_VALUES) {\n              return step;\n            } else if (type === ITERATE_KEYS) {\n              return iteratorValue(type, iterations++, undefined, step);\n            } else {\n              return iteratorValue(type, iterations++, step.value[1], step);\n            }\n          }\n          var entry = step.value;\n          k = entry[0];\n          v = entry[1];\n          skipping && (skipping = predicate.call(context, v, k, this$0));\n        } while (skipping);\n        return type === ITERATE_ENTRIES ? step :\n          iteratorValue(type, k, v, step);\n      });\n    };\n    return skipSequence;\n  }\n\n\n  function concatFactory(iterable, values) {\n    var isKeyedIterable = isKeyed(iterable);\n    var iters = [iterable].concat(values).map(function(v ) {\n      if (!isIterable(v)) {\n        v = isKeyedIterable ?\n          keyedSeqFromValue(v) :\n          indexedSeqFromValue(Array.isArray(v) ? v : [v]);\n      } else if (isKeyedIterable) {\n        v = KeyedIterable(v);\n      }\n      return v;\n    }).filter(function(v ) {return v.size !== 0});\n\n    if (iters.length === 0) {\n      return iterable;\n    }\n\n    if (iters.length === 1) {\n      var singleton = iters[0];\n      if (singleton === iterable ||\n          isKeyedIterable && isKeyed(singleton) ||\n          isIndexed(iterable) && isIndexed(singleton)) {\n        return singleton;\n      }\n    }\n\n    var concatSeq = new ArraySeq(iters);\n    if (isKeyedIterable) {\n      concatSeq = concatSeq.toKeyedSeq();\n    } else if (!isIndexed(iterable)) {\n      concatSeq = concatSeq.toSetSeq();\n    }\n    concatSeq = concatSeq.flatten(true);\n    concatSeq.size = iters.reduce(\n      function(sum, seq)  {\n        if (sum !== undefined) {\n          var size = seq.size;\n          if (size !== undefined) {\n            return sum + size;\n          }\n        }\n      },\n      0\n    );\n    return concatSeq;\n  }\n\n\n  function flattenFactory(iterable, depth, useKeys) {\n    var flatSequence = makeSequence(iterable);\n    flatSequence.__iterateUncached = function(fn, reverse) {\n      var iterations = 0;\n      var stopped = false;\n      function flatDeep(iter, currentDepth) {var this$0 = this;\n        iter.__iterate(function(v, k)  {\n          if ((!depth || currentDepth < depth) && isIterable(v)) {\n            flatDeep(v, currentDepth + 1);\n          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {\n            stopped = true;\n          }\n          return !stopped;\n        }, reverse);\n      }\n      flatDeep(iterable, 0);\n      return iterations;\n    }\n    flatSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(type, reverse);\n      var stack = [];\n      var iterations = 0;\n      return new Iterator(function()  {\n        while (iterator) {\n          var step = iterator.next();\n          if (step.done !== false) {\n            iterator = stack.pop();\n            continue;\n          }\n          var v = step.value;\n          if (type === ITERATE_ENTRIES) {\n            v = v[1];\n          }\n          if ((!depth || stack.length < depth) && isIterable(v)) {\n            stack.push(iterator);\n            iterator = v.__iterator(type, reverse);\n          } else {\n            return useKeys ? step : iteratorValue(type, iterations++, v, step);\n          }\n        }\n        return iteratorDone();\n      });\n    }\n    return flatSequence;\n  }\n\n\n  function flatMapFactory(iterable, mapper, context) {\n    var coerce = iterableClass(iterable);\n    return iterable.toSeq().map(\n      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}\n    ).flatten(true);\n  }\n\n\n  function interposeFactory(iterable, separator) {\n    var interposedSequence = makeSequence(iterable);\n    interposedSequence.size = iterable.size && iterable.size * 2 -1;\n    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;\n      var iterations = 0;\n      iterable.__iterate(function(v, k) \n        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&\n        fn(v, iterations++, this$0) !== false},\n        reverse\n      );\n      return iterations;\n    };\n    interposedSequence.__iteratorUncached = function(type, reverse) {\n      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);\n      var iterations = 0;\n      var step;\n      return new Iterator(function()  {\n        if (!step || iterations % 2) {\n          step = iterator.next();\n          if (step.done) {\n            return step;\n          }\n        }\n        return iterations % 2 ?\n          iteratorValue(type, iterations++, separator) :\n          iteratorValue(type, iterations++, step.value, step);\n      });\n    };\n    return interposedSequence;\n  }\n\n\n  function sortFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    var isKeyedIterable = isKeyed(iterable);\n    var index = 0;\n    var entries = iterable.toSeq().map(\n      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}\n    ).toArray();\n    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(\n      isKeyedIterable ?\n      function(v, i)  { entries[i].length = 2; } :\n      function(v, i)  { entries[i] = v[1]; }\n    );\n    return isKeyedIterable ? KeyedSeq(entries) :\n      isIndexed(iterable) ? IndexedSeq(entries) :\n      SetSeq(entries);\n  }\n\n\n  function maxFactory(iterable, comparator, mapper) {\n    if (!comparator) {\n      comparator = defaultComparator;\n    }\n    if (mapper) {\n      var entry = iterable.toSeq()\n        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})\n        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});\n      return entry && entry[0];\n    } else {\n      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});\n    }\n  }\n\n  function maxCompare(comparator, a, b) {\n    var comp = comparator(b, a);\n    // b is considered the new max if the comparator declares them equal, but\n    // they are not equal and b is in fact a nullish value.\n    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;\n  }\n\n\n  function zipWithFactory(keyIter, zipper, iters) {\n    var zipSequence = makeSequence(keyIter);\n    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();\n    // Note: this a generic base implementation of __iterate in terms of\n    // __iterator which may be more generically useful in the future.\n    zipSequence.__iterate = function(fn, reverse) {\n      /* generic:\n      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        iterations++;\n        if (fn(step.value[1], step.value[0], this) === false) {\n          break;\n        }\n      }\n      return iterations;\n      */\n      // indexed:\n      var iterator = this.__iterator(ITERATE_VALUES, reverse);\n      var step;\n      var iterations = 0;\n      while (!(step = iterator.next()).done) {\n        if (fn(step.value, iterations++, this) === false) {\n          break;\n        }\n      }\n      return iterations;\n    };\n    zipSequence.__iteratorUncached = function(type, reverse) {\n      var iterators = iters.map(function(i )\n        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}\n      );\n      var iterations = 0;\n      var isDone = false;\n      return new Iterator(function()  {\n        var steps;\n        if (!isDone) {\n          steps = iterators.map(function(i ) {return i.next()});\n          isDone = steps.some(function(s ) {return s.done});\n        }\n        if (isDone) {\n          return iteratorDone();\n        }\n        return iteratorValue(\n          type,\n          iterations++,\n          zipper.apply(null, steps.map(function(s ) {return s.value}))\n        );\n      });\n    };\n    return zipSequence\n  }\n\n\n  // #pragma Helper Functions\n\n  function reify(iter, seq) {\n    return isSeq(iter) ? seq : iter.constructor(seq);\n  }\n\n  function validateEntry(entry) {\n    if (entry !== Object(entry)) {\n      throw new TypeError('Expected [K, V] tuple: ' + entry);\n    }\n  }\n\n  function resolveSize(iter) {\n    assertNotInfinite(iter.size);\n    return ensureSize(iter);\n  }\n\n  function iterableClass(iterable) {\n    return isKeyed(iterable) ? KeyedIterable :\n      isIndexed(iterable) ? IndexedIterable :\n      SetIterable;\n  }\n\n  function makeSequence(iterable) {\n    return Object.create(\n      (\n        isKeyed(iterable) ? KeyedSeq :\n        isIndexed(iterable) ? IndexedSeq :\n        SetSeq\n      ).prototype\n    );\n  }\n\n  function cacheResultThrough() {\n    if (this._iter.cacheResult) {\n      this._iter.cacheResult();\n      this.size = this._iter.size;\n      return this;\n    } else {\n      return Seq.prototype.cacheResult.call(this);\n    }\n  }\n\n  function defaultComparator(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  function forceIterator(keyPath) {\n    var iter = getIterator(keyPath);\n    if (!iter) {\n      // Array might not be iterable in this environment, so we need a fallback\n      // to our wrapped type.\n      if (!isArrayLike(keyPath)) {\n        throw new TypeError('Expected iterable or array-like: ' + keyPath);\n      }\n      iter = getIterator(Iterable(keyPath));\n    }\n    return iter;\n  }\n\n  createClass(Record, KeyedCollection);\n\n    function Record(defaultValues, name) {\n      var hasInitialized;\n\n      var RecordType = function Record(values) {\n        if (values instanceof RecordType) {\n          return values;\n        }\n        if (!(this instanceof RecordType)) {\n          return new RecordType(values);\n        }\n        if (!hasInitialized) {\n          hasInitialized = true;\n          var keys = Object.keys(defaultValues);\n          setProps(RecordTypePrototype, keys);\n          RecordTypePrototype.size = keys.length;\n          RecordTypePrototype._name = name;\n          RecordTypePrototype._keys = keys;\n          RecordTypePrototype._defaultValues = defaultValues;\n        }\n        this._map = Map(values);\n      };\n\n      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);\n      RecordTypePrototype.constructor = RecordType;\n\n      return RecordType;\n    }\n\n    Record.prototype.toString = function() {\n      return this.__toString(recordName(this) + ' {', '}');\n    };\n\n    // @pragma Access\n\n    Record.prototype.has = function(k) {\n      return this._defaultValues.hasOwnProperty(k);\n    };\n\n    Record.prototype.get = function(k, notSetValue) {\n      if (!this.has(k)) {\n        return notSetValue;\n      }\n      var defaultVal = this._defaultValues[k];\n      return this._map ? this._map.get(k, defaultVal) : defaultVal;\n    };\n\n    // @pragma Modification\n\n    Record.prototype.clear = function() {\n      if (this.__ownerID) {\n        this._map && this._map.clear();\n        return this;\n      }\n      var RecordType = this.constructor;\n      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));\n    };\n\n    Record.prototype.set = function(k, v) {\n      if (!this.has(k)) {\n        throw new Error('Cannot set unknown key \"' + k + '\" on ' + recordName(this));\n      }\n      if (this._map && !this._map.has(k)) {\n        var defaultVal = this._defaultValues[k];\n        if (v === defaultVal) {\n          return this;\n        }\n      }\n      var newMap = this._map && this._map.set(k, v);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.remove = function(k) {\n      if (!this.has(k)) {\n        return this;\n      }\n      var newMap = this._map && this._map.remove(k);\n      if (this.__ownerID || newMap === this._map) {\n        return this;\n      }\n      return makeRecord(this, newMap);\n    };\n\n    Record.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);\n    };\n\n    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);\n    };\n\n    Record.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map && this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return makeRecord(this, newMap, ownerID);\n    };\n\n\n  var RecordPrototype = Record.prototype;\n  RecordPrototype[DELETE] = RecordPrototype.remove;\n  RecordPrototype.deleteIn =\n  RecordPrototype.removeIn = MapPrototype.removeIn;\n  RecordPrototype.merge = MapPrototype.merge;\n  RecordPrototype.mergeWith = MapPrototype.mergeWith;\n  RecordPrototype.mergeIn = MapPrototype.mergeIn;\n  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;\n  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;\n  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;\n  RecordPrototype.setIn = MapPrototype.setIn;\n  RecordPrototype.update = MapPrototype.update;\n  RecordPrototype.updateIn = MapPrototype.updateIn;\n  RecordPrototype.withMutations = MapPrototype.withMutations;\n  RecordPrototype.asMutable = MapPrototype.asMutable;\n  RecordPrototype.asImmutable = MapPrototype.asImmutable;\n\n\n  function makeRecord(likeRecord, map, ownerID) {\n    var record = Object.create(Object.getPrototypeOf(likeRecord));\n    record._map = map;\n    record.__ownerID = ownerID;\n    return record;\n  }\n\n  function recordName(record) {\n    return record._name || record.constructor.name || 'Record';\n  }\n\n  function setProps(prototype, names) {\n    try {\n      names.forEach(setProp.bind(undefined, prototype));\n    } catch (error) {\n      // Object.defineProperty failed. Probably IE8.\n    }\n  }\n\n  function setProp(prototype, name) {\n    Object.defineProperty(prototype, name, {\n      get: function() {\n        return this.get(name);\n      },\n      set: function(value) {\n        invariant(this.__ownerID, 'Cannot set on an immutable record.');\n        this.set(name, value);\n      }\n    });\n  }\n\n  createClass(Set, SetCollection);\n\n    // @pragma Construction\n\n    function Set(value) {\n      return value === null || value === undefined ? emptySet() :\n        isSet(value) && !isOrdered(value) ? value :\n        emptySet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    Set.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Set.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    Set.prototype.toString = function() {\n      return this.__toString('Set {', '}');\n    };\n\n    // @pragma Access\n\n    Set.prototype.has = function(value) {\n      return this._map.has(value);\n    };\n\n    // @pragma Modification\n\n    Set.prototype.add = function(value) {\n      return updateSet(this, this._map.set(value, true));\n    };\n\n    Set.prototype.remove = function(value) {\n      return updateSet(this, this._map.remove(value));\n    };\n\n    Set.prototype.clear = function() {\n      return updateSet(this, this._map.clear());\n    };\n\n    // @pragma Composition\n\n    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);\n      iters = iters.filter(function(x ) {return x.size !== 0});\n      if (iters.length === 0) {\n        return this;\n      }\n      if (this.size === 0 && !this.__ownerID && iters.length === 1) {\n        return this.constructor(iters[0]);\n      }\n      return this.withMutations(function(set ) {\n        for (var ii = 0; ii < iters.length; ii++) {\n          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});\n        }\n      });\n    };\n\n    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (!iters.every(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);\n      if (iters.length === 0) {\n        return this;\n      }\n      iters = iters.map(function(iter ) {return SetIterable(iter)});\n      var originalSet = this;\n      return this.withMutations(function(set ) {\n        originalSet.forEach(function(value ) {\n          if (iters.some(function(iter ) {return iter.includes(value)})) {\n            set.remove(value);\n          }\n        });\n      });\n    };\n\n    Set.prototype.merge = function() {\n      return this.union.apply(this, arguments);\n    };\n\n    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);\n      return this.union.apply(this, iters);\n    };\n\n    Set.prototype.sort = function(comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator));\n    };\n\n    Set.prototype.sortBy = function(mapper, comparator) {\n      // Late binding\n      return OrderedSet(sortFactory(this, comparator, mapper));\n    };\n\n    Set.prototype.wasAltered = function() {\n      return this._map.wasAltered();\n    };\n\n    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;\n      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);\n    };\n\n    Set.prototype.__iterator = function(type, reverse) {\n      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);\n    };\n\n    Set.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      var newMap = this._map.__ensureOwner(ownerID);\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this._map = newMap;\n        return this;\n      }\n      return this.__make(newMap, ownerID);\n    };\n\n\n  function isSet(maybeSet) {\n    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);\n  }\n\n  Set.isSet = isSet;\n\n  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';\n\n  var SetPrototype = Set.prototype;\n  SetPrototype[IS_SET_SENTINEL] = true;\n  SetPrototype[DELETE] = SetPrototype.remove;\n  SetPrototype.mergeDeep = SetPrototype.merge;\n  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;\n  SetPrototype.withMutations = MapPrototype.withMutations;\n  SetPrototype.asMutable = MapPrototype.asMutable;\n  SetPrototype.asImmutable = MapPrototype.asImmutable;\n\n  SetPrototype.__empty = emptySet;\n  SetPrototype.__make = makeSet;\n\n  function updateSet(set, newMap) {\n    if (set.__ownerID) {\n      set.size = newMap.size;\n      set._map = newMap;\n      return set;\n    }\n    return newMap === set._map ? set :\n      newMap.size === 0 ? set.__empty() :\n      set.__make(newMap);\n  }\n\n  function makeSet(map, ownerID) {\n    var set = Object.create(SetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_SET;\n  function emptySet() {\n    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));\n  }\n\n  createClass(OrderedSet, Set);\n\n    // @pragma Construction\n\n    function OrderedSet(value) {\n      return value === null || value === undefined ? emptyOrderedSet() :\n        isOrderedSet(value) ? value :\n        emptyOrderedSet().withMutations(function(set ) {\n          var iter = SetIterable(value);\n          assertNotInfinite(iter.size);\n          iter.forEach(function(v ) {return set.add(v)});\n        });\n    }\n\n    OrderedSet.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    OrderedSet.fromKeys = function(value) {\n      return this(KeyedIterable(value).keySeq());\n    };\n\n    OrderedSet.prototype.toString = function() {\n      return this.__toString('OrderedSet {', '}');\n    };\n\n\n  function isOrderedSet(maybeOrderedSet) {\n    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);\n  }\n\n  OrderedSet.isOrderedSet = isOrderedSet;\n\n  var OrderedSetPrototype = OrderedSet.prototype;\n  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;\n\n  OrderedSetPrototype.__empty = emptyOrderedSet;\n  OrderedSetPrototype.__make = makeOrderedSet;\n\n  function makeOrderedSet(map, ownerID) {\n    var set = Object.create(OrderedSetPrototype);\n    set.size = map ? map.size : 0;\n    set._map = map;\n    set.__ownerID = ownerID;\n    return set;\n  }\n\n  var EMPTY_ORDERED_SET;\n  function emptyOrderedSet() {\n    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));\n  }\n\n  createClass(Stack, IndexedCollection);\n\n    // @pragma Construction\n\n    function Stack(value) {\n      return value === null || value === undefined ? emptyStack() :\n        isStack(value) ? value :\n        emptyStack().unshiftAll(value);\n    }\n\n    Stack.of = function(/*...values*/) {\n      return this(arguments);\n    };\n\n    Stack.prototype.toString = function() {\n      return this.__toString('Stack [', ']');\n    };\n\n    // @pragma Access\n\n    Stack.prototype.get = function(index, notSetValue) {\n      var head = this._head;\n      index = wrapIndex(this, index);\n      while (head && index--) {\n        head = head.next;\n      }\n      return head ? head.value : notSetValue;\n    };\n\n    Stack.prototype.peek = function() {\n      return this._head && this._head.value;\n    };\n\n    // @pragma Modification\n\n    Stack.prototype.push = function(/*...values*/) {\n      if (arguments.length === 0) {\n        return this;\n      }\n      var newSize = this.size + arguments.length;\n      var head = this._head;\n      for (var ii = arguments.length - 1; ii >= 0; ii--) {\n        head = {\n          value: arguments[ii],\n          next: head\n        };\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pushAll = function(iter) {\n      iter = IndexedIterable(iter);\n      if (iter.size === 0) {\n        return this;\n      }\n      assertNotInfinite(iter.size);\n      var newSize = this.size;\n      var head = this._head;\n      iter.reverse().forEach(function(value ) {\n        newSize++;\n        head = {\n          value: value,\n          next: head\n        };\n      });\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    Stack.prototype.pop = function() {\n      return this.slice(1);\n    };\n\n    Stack.prototype.unshift = function(/*...values*/) {\n      return this.push.apply(this, arguments);\n    };\n\n    Stack.prototype.unshiftAll = function(iter) {\n      return this.pushAll(iter);\n    };\n\n    Stack.prototype.shift = function() {\n      return this.pop.apply(this, arguments);\n    };\n\n    Stack.prototype.clear = function() {\n      if (this.size === 0) {\n        return this;\n      }\n      if (this.__ownerID) {\n        this.size = 0;\n        this._head = undefined;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return emptyStack();\n    };\n\n    Stack.prototype.slice = function(begin, end) {\n      if (wholeSlice(begin, end, this.size)) {\n        return this;\n      }\n      var resolvedBegin = resolveBegin(begin, this.size);\n      var resolvedEnd = resolveEnd(end, this.size);\n      if (resolvedEnd !== this.size) {\n        // super.slice(begin, end);\n        return IndexedCollection.prototype.slice.call(this, begin, end);\n      }\n      var newSize = this.size - resolvedBegin;\n      var head = this._head;\n      while (resolvedBegin--) {\n        head = head.next;\n      }\n      if (this.__ownerID) {\n        this.size = newSize;\n        this._head = head;\n        this.__hash = undefined;\n        this.__altered = true;\n        return this;\n      }\n      return makeStack(newSize, head);\n    };\n\n    // @pragma Mutability\n\n    Stack.prototype.__ensureOwner = function(ownerID) {\n      if (ownerID === this.__ownerID) {\n        return this;\n      }\n      if (!ownerID) {\n        this.__ownerID = ownerID;\n        this.__altered = false;\n        return this;\n      }\n      return makeStack(this.size, this._head, ownerID, this.__hash);\n    };\n\n    // @pragma Iteration\n\n    Stack.prototype.__iterate = function(fn, reverse) {\n      if (reverse) {\n        return this.reverse().__iterate(fn);\n      }\n      var iterations = 0;\n      var node = this._head;\n      while (node) {\n        if (fn(node.value, iterations++, this) === false) {\n          break;\n        }\n        node = node.next;\n      }\n      return iterations;\n    };\n\n    Stack.prototype.__iterator = function(type, reverse) {\n      if (reverse) {\n        return this.reverse().__iterator(type);\n      }\n      var iterations = 0;\n      var node = this._head;\n      return new Iterator(function()  {\n        if (node) {\n          var value = node.value;\n          node = node.next;\n          return iteratorValue(type, iterations++, value);\n        }\n        return iteratorDone();\n      });\n    };\n\n\n  function isStack(maybeStack) {\n    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);\n  }\n\n  Stack.isStack = isStack;\n\n  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';\n\n  var StackPrototype = Stack.prototype;\n  StackPrototype[IS_STACK_SENTINEL] = true;\n  StackPrototype.withMutations = MapPrototype.withMutations;\n  StackPrototype.asMutable = MapPrototype.asMutable;\n  StackPrototype.asImmutable = MapPrototype.asImmutable;\n  StackPrototype.wasAltered = MapPrototype.wasAltered;\n\n\n  function makeStack(size, head, ownerID, hash) {\n    var map = Object.create(StackPrototype);\n    map.size = size;\n    map._head = head;\n    map.__ownerID = ownerID;\n    map.__hash = hash;\n    map.__altered = false;\n    return map;\n  }\n\n  var EMPTY_STACK;\n  function emptyStack() {\n    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));\n  }\n\n  /**\n   * Contributes additional methods to a constructor\n   */\n  function mixin(ctor, methods) {\n    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };\n    Object.keys(methods).forEach(keyCopier);\n    Object.getOwnPropertySymbols &&\n      Object.getOwnPropertySymbols(methods).forEach(keyCopier);\n    return ctor;\n  }\n\n  Iterable.Iterator = Iterator;\n\n  mixin(Iterable, {\n\n    // ### Conversion to other types\n\n    toArray: function() {\n      assertNotInfinite(this.size);\n      var array = new Array(this.size || 0);\n      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });\n      return array;\n    },\n\n    toIndexedSeq: function() {\n      return new ToIndexedSequence(this);\n    },\n\n    toJS: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}\n      ).__toJS();\n    },\n\n    toJSON: function() {\n      return this.toSeq().map(\n        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}\n      ).__toJS();\n    },\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, true);\n    },\n\n    toMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Map(this.toKeyedSeq());\n    },\n\n    toObject: function() {\n      assertNotInfinite(this.size);\n      var object = {};\n      this.__iterate(function(v, k)  { object[k] = v; });\n      return object;\n    },\n\n    toOrderedMap: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedMap(this.toKeyedSeq());\n    },\n\n    toOrderedSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSet: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Set(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toSetSeq: function() {\n      return new ToSetSequence(this);\n    },\n\n    toSeq: function() {\n      return isIndexed(this) ? this.toIndexedSeq() :\n        isKeyed(this) ? this.toKeyedSeq() :\n        this.toSetSeq();\n    },\n\n    toStack: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return Stack(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n    toList: function() {\n      // Use Late Binding here to solve the circular dependency.\n      return List(isKeyed(this) ? this.valueSeq() : this);\n    },\n\n\n    // ### Common JavaScript methods and properties\n\n    toString: function() {\n      return '[Iterable]';\n    },\n\n    __toString: function(head, tail) {\n      if (this.size === 0) {\n        return head + tail;\n      }\n      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    concat: function() {var values = SLICE$0.call(arguments, 0);\n      return reify(this, concatFactory(this, values));\n    },\n\n    includes: function(searchValue) {\n      return this.some(function(value ) {return is(value, searchValue)});\n    },\n\n    entries: function() {\n      return this.__iterator(ITERATE_ENTRIES);\n    },\n\n    every: function(predicate, context) {\n      assertNotInfinite(this.size);\n      var returnValue = true;\n      this.__iterate(function(v, k, c)  {\n        if (!predicate.call(context, v, k, c)) {\n          returnValue = false;\n          return false;\n        }\n      });\n      return returnValue;\n    },\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, true));\n    },\n\n    find: function(predicate, context, notSetValue) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[1] : notSetValue;\n    },\n\n    forEach: function(sideEffect, context) {\n      assertNotInfinite(this.size);\n      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);\n    },\n\n    join: function(separator) {\n      assertNotInfinite(this.size);\n      separator = separator !== undefined ? '' + separator : ',';\n      var joined = '';\n      var isFirst = true;\n      this.__iterate(function(v ) {\n        isFirst ? (isFirst = false) : (joined += separator);\n        joined += v !== null && v !== undefined ? v.toString() : '';\n      });\n      return joined;\n    },\n\n    keys: function() {\n      return this.__iterator(ITERATE_KEYS);\n    },\n\n    map: function(mapper, context) {\n      return reify(this, mapFactory(this, mapper, context));\n    },\n\n    reduce: function(reducer, initialReduction, context) {\n      assertNotInfinite(this.size);\n      var reduction;\n      var useFirst;\n      if (arguments.length < 2) {\n        useFirst = true;\n      } else {\n        reduction = initialReduction;\n      }\n      this.__iterate(function(v, k, c)  {\n        if (useFirst) {\n          useFirst = false;\n          reduction = v;\n        } else {\n          reduction = reducer.call(context, reduction, v, k, c);\n        }\n      });\n      return reduction;\n    },\n\n    reduceRight: function(reducer, initialReduction, context) {\n      var reversed = this.toKeyedSeq().reverse();\n      return reversed.reduce.apply(reversed, arguments);\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, true));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, true));\n    },\n\n    some: function(predicate, context) {\n      return !this.every(not(predicate), context);\n    },\n\n    sort: function(comparator) {\n      return reify(this, sortFactory(this, comparator));\n    },\n\n    values: function() {\n      return this.__iterator(ITERATE_VALUES);\n    },\n\n\n    // ### More sequential methods\n\n    butLast: function() {\n      return this.slice(0, -1);\n    },\n\n    isEmpty: function() {\n      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});\n    },\n\n    count: function(predicate, context) {\n      return ensureSize(\n        predicate ? this.toSeq().filter(predicate, context) : this\n      );\n    },\n\n    countBy: function(grouper, context) {\n      return countByFactory(this, grouper, context);\n    },\n\n    equals: function(other) {\n      return deepEqual(this, other);\n    },\n\n    entrySeq: function() {\n      var iterable = this;\n      if (iterable._cache) {\n        // We cache as an entries array, so we can just return the cache!\n        return new ArraySeq(iterable._cache);\n      }\n      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();\n      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};\n      return entriesSequence;\n    },\n\n    filterNot: function(predicate, context) {\n      return this.filter(not(predicate), context);\n    },\n\n    findEntry: function(predicate, context, notSetValue) {\n      var found = notSetValue;\n      this.__iterate(function(v, k, c)  {\n        if (predicate.call(context, v, k, c)) {\n          found = [k, v];\n          return false;\n        }\n      });\n      return found;\n    },\n\n    findKey: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry && entry[0];\n    },\n\n    findLast: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);\n    },\n\n    findLastEntry: function(predicate, context, notSetValue) {\n      return this.toKeyedSeq().reverse().findEntry(predicate, context, notSetValue);\n    },\n\n    findLastKey: function(predicate, context) {\n      return this.toKeyedSeq().reverse().findKey(predicate, context);\n    },\n\n    first: function() {\n      return this.find(returnTrue);\n    },\n\n    flatMap: function(mapper, context) {\n      return reify(this, flatMapFactory(this, mapper, context));\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, true));\n    },\n\n    fromEntrySeq: function() {\n      return new FromEntriesSequence(this);\n    },\n\n    get: function(searchKey, notSetValue) {\n      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);\n    },\n\n    getIn: function(searchKeyPath, notSetValue) {\n      var nested = this;\n      // Note: in an ES6 environment, we would prefer:\n      // for (var key of searchKeyPath) {\n      var iter = forceIterator(searchKeyPath);\n      var step;\n      while (!(step = iter.next()).done) {\n        var key = step.value;\n        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;\n        if (nested === NOT_SET) {\n          return notSetValue;\n        }\n      }\n      return nested;\n    },\n\n    groupBy: function(grouper, context) {\n      return groupByFactory(this, grouper, context);\n    },\n\n    has: function(searchKey) {\n      return this.get(searchKey, NOT_SET) !== NOT_SET;\n    },\n\n    hasIn: function(searchKeyPath) {\n      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;\n    },\n\n    isSubset: function(iter) {\n      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);\n      return this.every(function(value ) {return iter.includes(value)});\n    },\n\n    isSuperset: function(iter) {\n      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);\n      return iter.isSubset(this);\n    },\n\n    keyOf: function(searchValue) {\n      return this.findKey(function(value ) {return is(value, searchValue)});\n    },\n\n    keySeq: function() {\n      return this.toSeq().map(keyMapper).toIndexedSeq();\n    },\n\n    last: function() {\n      return this.toSeq().reverse().first();\n    },\n\n    lastKeyOf: function(searchValue) {\n      return this.toKeyedSeq().reverse().keyOf(searchValue);\n    },\n\n    max: function(comparator) {\n      return maxFactory(this, comparator);\n    },\n\n    maxBy: function(mapper, comparator) {\n      return maxFactory(this, comparator, mapper);\n    },\n\n    min: function(comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);\n    },\n\n    minBy: function(mapper, comparator) {\n      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);\n    },\n\n    rest: function() {\n      return this.slice(1);\n    },\n\n    skip: function(amount) {\n      return this.slice(Math.max(0, amount));\n    },\n\n    skipLast: function(amount) {\n      return reify(this, this.toSeq().reverse().skip(amount).reverse());\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, true));\n    },\n\n    skipUntil: function(predicate, context) {\n      return this.skipWhile(not(predicate), context);\n    },\n\n    sortBy: function(mapper, comparator) {\n      return reify(this, sortFactory(this, comparator, mapper));\n    },\n\n    take: function(amount) {\n      return this.slice(0, Math.max(0, amount));\n    },\n\n    takeLast: function(amount) {\n      return reify(this, this.toSeq().reverse().take(amount).reverse());\n    },\n\n    takeWhile: function(predicate, context) {\n      return reify(this, takeWhileFactory(this, predicate, context));\n    },\n\n    takeUntil: function(predicate, context) {\n      return this.takeWhile(not(predicate), context);\n    },\n\n    valueSeq: function() {\n      return this.toIndexedSeq();\n    },\n\n\n    // ### Hashable Object\n\n    hashCode: function() {\n      return this.__hash || (this.__hash = hashIterable(this));\n    }\n\n\n    // ### Internal\n\n    // abstract __iterate(fn, reverse)\n\n    // abstract __iterator(type, reverse)\n  });\n\n  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';\n  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';\n  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';\n  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';\n\n  var IterablePrototype = Iterable.prototype;\n  IterablePrototype[IS_ITERABLE_SENTINEL] = true;\n  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;\n  IterablePrototype.__toJS = IterablePrototype.toArray;\n  IterablePrototype.__toStringMapper = quoteString;\n  IterablePrototype.inspect =\n  IterablePrototype.toSource = function() { return this.toString(); };\n  IterablePrototype.chain = IterablePrototype.flatMap;\n  IterablePrototype.contains = IterablePrototype.includes;\n\n  mixin(KeyedIterable, {\n\n    // ### More sequential methods\n\n    flip: function() {\n      return reify(this, flipFactory(this));\n    },\n\n    mapEntries: function(mapper, context) {var this$0 = this;\n      var iterations = 0;\n      return reify(this,\n        this.toSeq().map(\n          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}\n        ).fromEntrySeq()\n      );\n    },\n\n    mapKeys: function(mapper, context) {var this$0 = this;\n      return reify(this,\n        this.toSeq().flip().map(\n          function(k, v)  {return mapper.call(context, k, v, this$0)}\n        ).flip()\n      );\n    }\n\n  });\n\n  var KeyedIterablePrototype = KeyedIterable.prototype;\n  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;\n  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;\n  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;\n  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};\n\n\n\n  mixin(IndexedIterable, {\n\n    // ### Conversion to other types\n\n    toKeyedSeq: function() {\n      return new ToKeyedSequence(this, false);\n    },\n\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    filter: function(predicate, context) {\n      return reify(this, filterFactory(this, predicate, context, false));\n    },\n\n    findIndex: function(predicate, context) {\n      var entry = this.findEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    indexOf: function(searchValue) {\n      var key = this.keyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    lastIndexOf: function(searchValue) {\n      var key = this.lastKeyOf(searchValue);\n      return key === undefined ? -1 : key;\n    },\n\n    reverse: function() {\n      return reify(this, reverseFactory(this, false));\n    },\n\n    slice: function(begin, end) {\n      return reify(this, sliceFactory(this, begin, end, false));\n    },\n\n    splice: function(index, removeNum /*, ...values*/) {\n      var numArgs = arguments.length;\n      removeNum = Math.max(removeNum | 0, 0);\n      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {\n        return this;\n      }\n      // If index is negative, it should resolve relative to the size of the\n      // collection. However size may be expensive to compute if not cached, so\n      // only call count() if the number is in fact negative.\n      index = resolveBegin(index, index < 0 ? this.count() : this.size);\n      var spliced = this.slice(0, index);\n      return reify(\n        this,\n        numArgs === 1 ?\n          spliced :\n          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))\n      );\n    },\n\n\n    // ### More collection methods\n\n    findLastIndex: function(predicate, context) {\n      var entry = this.findLastEntry(predicate, context);\n      return entry ? entry[0] : -1;\n    },\n\n    first: function() {\n      return this.get(0);\n    },\n\n    flatten: function(depth) {\n      return reify(this, flattenFactory(this, depth, false));\n    },\n\n    get: function(index, notSetValue) {\n      index = wrapIndex(this, index);\n      return (index < 0 || (this.size === Infinity ||\n          (this.size !== undefined && index > this.size))) ?\n        notSetValue :\n        this.find(function(_, key)  {return key === index}, undefined, notSetValue);\n    },\n\n    has: function(index) {\n      index = wrapIndex(this, index);\n      return index >= 0 && (this.size !== undefined ?\n        this.size === Infinity || index < this.size :\n        this.indexOf(index) !== -1\n      );\n    },\n\n    interpose: function(separator) {\n      return reify(this, interposeFactory(this, separator));\n    },\n\n    interleave: function(/*...iterables*/) {\n      var iterables = [this].concat(arrCopy(arguments));\n      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);\n      var interleaved = zipped.flatten(true);\n      if (zipped.size) {\n        interleaved.size = zipped.size * iterables.length;\n      }\n      return reify(this, interleaved);\n    },\n\n    keySeq: function() {\n      return Range(0, this.size);\n    },\n\n    last: function() {\n      return this.get(-1);\n    },\n\n    skipWhile: function(predicate, context) {\n      return reify(this, skipWhileFactory(this, predicate, context, false));\n    },\n\n    zip: function(/*, ...iterables */) {\n      var iterables = [this].concat(arrCopy(arguments));\n      return reify(this, zipWithFactory(this, defaultZipper, iterables));\n    },\n\n    zipWith: function(zipper/*, ...iterables */) {\n      var iterables = arrCopy(arguments);\n      iterables[0] = this;\n      return reify(this, zipWithFactory(this, zipper, iterables));\n    }\n\n  });\n\n  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;\n  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;\n\n\n\n  mixin(SetIterable, {\n\n    // ### ES6 Collection methods (ES6 Array and Map)\n\n    get: function(value, notSetValue) {\n      return this.has(value) ? value : notSetValue;\n    },\n\n    includes: function(value) {\n      return this.has(value);\n    },\n\n\n    // ### More sequential methods\n\n    keySeq: function() {\n      return this.valueSeq();\n    }\n\n  });\n\n  SetIterable.prototype.has = IterablePrototype.includes;\n  SetIterable.prototype.contains = SetIterable.prototype.includes;\n\n\n  // Mixin subclasses\n\n  mixin(KeyedSeq, KeyedIterable.prototype);\n  mixin(IndexedSeq, IndexedIterable.prototype);\n  mixin(SetSeq, SetIterable.prototype);\n\n  mixin(KeyedCollection, KeyedIterable.prototype);\n  mixin(IndexedCollection, IndexedIterable.prototype);\n  mixin(SetCollection, SetIterable.prototype);\n\n\n  // #pragma Helper functions\n\n  function keyMapper(v, k) {\n    return k;\n  }\n\n  function entryMapper(v, k) {\n    return [k, v];\n  }\n\n  function not(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    }\n  }\n\n  function neg(predicate) {\n    return function() {\n      return -predicate.apply(this, arguments);\n    }\n  }\n\n  function quoteString(value) {\n    return typeof value === 'string' ? JSON.stringify(value) : String(value);\n  }\n\n  function defaultZipper() {\n    return arrCopy(arguments);\n  }\n\n  function defaultNegComparator(a, b) {\n    return a < b ? 1 : a > b ? -1 : 0;\n  }\n\n  function hashIterable(iterable) {\n    if (iterable.size === Infinity) {\n      return 0;\n    }\n    var ordered = isOrdered(iterable);\n    var keyed = isKeyed(iterable);\n    var h = ordered ? 1 : 0;\n    var size = iterable.__iterate(\n      keyed ?\n        ordered ?\n          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :\n          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :\n        ordered ?\n          function(v ) { h = 31 * h + hash(v) | 0; } :\n          function(v ) { h = h + hash(v) | 0; }\n    );\n    return murmurHashOfSize(size, h);\n  }\n\n  function murmurHashOfSize(size, h) {\n    h = imul(h, 0xCC9E2D51);\n    h = imul(h << 15 | h >>> -15, 0x1B873593);\n    h = imul(h << 13 | h >>> -13, 5);\n    h = (h + 0xE6546B64 | 0) ^ size;\n    h = imul(h ^ h >>> 16, 0x85EBCA6B);\n    h = imul(h ^ h >>> 13, 0xC2B2AE35);\n    h = smi(h ^ h >>> 16);\n    return h;\n  }\n\n  function hashMerge(a, b) {\n    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int\n  }\n\n  var Immutable = {\n\n    Iterable: Iterable,\n\n    Seq: Seq,\n    Collection: Collection,\n    Map: Map,\n    OrderedMap: OrderedMap,\n    List: List,\n    Stack: Stack,\n    Set: Set,\n    OrderedSet: OrderedSet,\n\n    Record: Record,\n    Range: Range,\n    Repeat: Repeat,\n\n    is: is,\n    fromJS: fromJS\n\n  };\n\n  return Immutable;\n\n}));\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/immutable/dist/immutable.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/inherits/inherits.js":
/*!*******************************************************!*\
  !*** ../scratch-vm/node_modules/inherits/inherits.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("try {\n  var util = __webpack_require__(/*! util */ \"util\");\n  /* istanbul ignore next */\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  /* istanbul ignore next */\n  module.exports = __webpack_require__(/*! ./inherits_browser.js */ \"../scratch-vm/node_modules/inherits/inherits_browser.js\");\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/inherits/inherits.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/inherits/inherits_browser.js":
/*!***************************************************************!*\
  !*** ../scratch-vm/node_modules/inherits/inherits_browser.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/lookup-closest-locale/index.js":
/*!*****************************************************************!*\
  !*** ../scratch-vm/node_modules/lookup-closest-locale/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("// @flow\n// \"lookup\" algorithm http://tools.ietf.org/html/rfc4647#section-3.4\n// assumes normalized language tags, and matches in a case sensitive manner\nmodule.exports = function lookupClosestLocale (locale/*: string | string[] | void */, available/*: { [string]: any } */)/*: ?string */ {\n  if (typeof locale === 'string' && available[locale]) return locale\n  var locales = [].concat(locale || [])\n  for (var l = 0, ll = locales.length; l < ll; ++l) {\n    var current = locales[l].split('-')\n    while (current.length) {\n      var candidate = current.join('-')\n      if (available[candidate]) return candidate\n      current.pop()\n    }\n  }\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/lookup-closest-locale/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/microee/index.js":
/*!***************************************************!*\
  !*** ../scratch-vm/node_modules/microee/index.js ***!
  \***************************************************/
/***/ ((module) => {

eval("function M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/microee/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/common/filter.js":
/*!***************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/common/filter.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// default filter\nvar Transform = __webpack_require__(/*! ./transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nvar levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nfunction Filter() {\n  this.enabled = true;\n  this.defaultResult = true;\n  this.clear();\n}\n\nTransform.mixin(Filter);\n\n// allow all matching, with level >= given level\nFilter.prototype.allow = function(name, level) {\n  this._white.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\n// deny all matching, with level <= given level\nFilter.prototype.deny = function(name, level) {\n  this._black.push({ n: name, l: levelMap[level] });\n  return this;\n};\n\nFilter.prototype.clear = function() {\n  this._white = [];\n  this._black = [];\n  return this;\n};\n\nfunction test(rule, name) {\n  // use .test for RegExps\n  return (rule.n.test ? rule.n.test(name) : rule.n == name);\n};\n\nFilter.prototype.test = function(name, level) {\n  var i, len = Math.max(this._white.length, this._black.length);\n  for(i = 0; i < len; i++) {\n    if(this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {\n      return true;\n    }\n    if(this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {\n      return false;\n    }\n  }\n  return this.defaultResult;\n};\n\nFilter.prototype.write = function(name, level, args) {\n  if(!this.enabled || this.test(name, level)) {\n    return this.emit('item', name, level, args);\n  }\n};\n\nmodule.exports = Filter;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/common/filter.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/common/minilog.js":
/*!****************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/common/minilog.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ./transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    Filter = __webpack_require__(/*! ./filter.js */ \"../scratch-vm/node_modules/minilog/lib/common/filter.js\");\n\nvar log = new Transform(),\n    slice = Array.prototype.slice;\n\nexports = module.exports = function create(name) {\n  var o   = function() { log.write(name, undefined, slice.call(arguments)); return o; };\n  o.debug = function() { log.write(name, 'debug', slice.call(arguments)); return o; };\n  o.info  = function() { log.write(name, 'info',  slice.call(arguments)); return o; };\n  o.warn  = function() { log.write(name, 'warn',  slice.call(arguments)); return o; };\n  o.error = function() { log.write(name, 'error', slice.call(arguments)); return o; };\n  o.log   = o.debug; // for interface compliance with Node and browser consoles\n  o.suggest = exports.suggest;\n  o.format = log.format;\n  return o;\n};\n\n// filled in separately\nexports.defaultBackend = exports.defaultFormatter = null;\n\nexports.pipe = function(dest) {\n  return log.pipe(dest);\n};\n\nexports.end = exports.unpipe = exports.disable = function(from) {\n  return log.unpipe(from);\n};\n\nexports.Transform = Transform;\nexports.Filter = Filter;\n// this is the default filter that's applied when .enable() is called normally\n// you can bypass it completely and set up your own pipes\nexports.suggest = new Filter();\n\nexports.enable = function() {\n  if(exports.defaultFormatter) {\n    return log.pipe(exports.suggest) // filter\n              .pipe(exports.defaultFormatter) // formatter\n              .pipe(exports.defaultBackend); // backend\n  }\n  return log.pipe(exports.suggest) // filter\n            .pipe(exports.defaultBackend); // formatter\n};\n\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/common/minilog.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/common/transform.js":
/*!******************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/common/transform.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var microee = __webpack_require__(/*! microee */ \"../scratch-vm/node_modules/microee/index.js\");\n\n// Implements a subset of Node's stream.Transform - in a cross-platform manner.\nfunction Transform() {}\n\nmicroee.mixin(Transform);\n\n// The write() signature is different from Node's\n// --> makes it much easier to work with objects in logs.\n// One of the lessons from v1 was that it's better to target\n// a good browser rather than the lowest common denominator\n// internally.\n// If you want to use external streams, pipe() to ./stringify.js first.\nTransform.prototype.write = function(name, level, args) {\n  this.emit('item', name, level, args);\n};\n\nTransform.prototype.end = function() {\n  this.emit('end');\n  this.removeAllListeners();\n};\n\nTransform.prototype.pipe = function(dest) {\n  var s = this;\n  // prevent double piping\n  s.emit('unpipe', dest);\n  // tell the dest that it's being piped to\n  dest.emit('pipe', s);\n\n  function onItem() {\n    dest.write.apply(dest, Array.prototype.slice.call(arguments));\n  }\n  function onEnd() { !dest._isStdio && dest.end(); }\n\n  s.on('item', onItem);\n  s.on('end', onEnd);\n\n  s.when('unpipe', function(from) {\n    var match = (from === dest) || typeof from == 'undefined';\n    if(match) {\n      s.removeListener('item', onItem);\n      s.removeListener('end', onEnd);\n      dest.emit('unpipe');\n    }\n    return match;\n  });\n\n  return dest;\n};\n\nTransform.prototype.unpipe = function(from) {\n  this.emit('unpipe', from);\n  return this;\n};\n\nTransform.prototype.format = function(dest) {\n  throw new Error([\n    'Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:',\n    'var Minilog = require(\\'minilog\\');',\n    'Minilog',\n    '  .pipe(Minilog.backends.console.formatClean)',\n    '  .pipe(Minilog.backends.console);'].join('\\n'));\n};\n\nTransform.mixin = function(dest) {\n  var o = Transform.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\n\nmodule.exports = Transform;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/common/transform.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/index.js":
/*!*******************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./common/minilog.js */ \"../scratch-vm/node_modules/minilog/lib/common/minilog.js\");\n\nvar consoleLogger = __webpack_require__(/*! ./node/console.js */ \"../scratch-vm/node_modules/minilog/lib/node/console.js\");\n\n// if we are running inside Electron then use the web version of console.js\nvar isElectron = (typeof window !== 'undefined' && window.process && window.process.type === 'renderer');\nif (isElectron) {\n  consoleLogger = (__webpack_require__(/*! ./web/console.js */ \"../scratch-vm/node_modules/minilog/lib/web/console.js\").minilog);\n}\n\n// intercept the pipe method and transparently wrap the stringifier, if the\n// destination is a Node core stream\n\nmodule.exports.Stringifier = __webpack_require__(/*! ./node/stringify.js */ \"../scratch-vm/node_modules/minilog/lib/node/stringify.js\");\n\nvar oldPipe = module.exports.pipe;\nmodule.exports.pipe = function(dest) {\n  if(dest instanceof __webpack_require__(/*! stream */ \"stream\")) {\n    return oldPipe.call(module.exports, new (module.exports.Stringifier)).pipe(dest);\n  } else {\n    return oldPipe.call(module.exports, dest);\n  }\n};\n\nmodule.exports.defaultBackend = consoleLogger;\nmodule.exports.defaultFormatter = consoleLogger.formatMinilog;\n\nmodule.exports.backends = {\n  redis: __webpack_require__(/*! ./node/redis.js */ \"../scratch-vm/node_modules/minilog/lib/node/redis.js\"),\n  nodeConsole: consoleLogger,\n  console: consoleLogger\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/console.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/console.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nfunction ConsoleBackend() { }\n\nTransform.mixin(ConsoleBackend);\n\nConsoleBackend.prototype.write = function() {\n  console.log.apply(console, arguments);\n};\n\nvar e = new ConsoleBackend();\n\nvar levelMap = (__webpack_require__(/*! ./formatters/util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").levelMap);\n\ne.filterEnv = function() {\n  console.error('Minilog.backends.console.filterEnv is deprecated in Minilog v2.');\n  // return the instance of Minilog\n  return __webpack_require__(/*! ../common/minilog.js */ \"../scratch-vm/node_modules/minilog/lib/common/minilog.js\");\n};\n\ne.formatters = [\n    'formatClean', 'formatColor', 'formatNpm',\n    'formatLearnboost', 'formatMinilog', 'formatWithStack', 'formatTime'\n];\n\ne.formatClean = new (__webpack_require__(/*! ./formatters/clean.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/clean.js\"));\ne.formatColor = new (__webpack_require__(/*! ./formatters/color.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/color.js\"));\ne.formatNpm = new (__webpack_require__(/*! ./formatters/npm.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/npm.js\"));\ne.formatLearnboost = new (__webpack_require__(/*! ./formatters/learnboost.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/learnboost.js\"));\ne.formatMinilog = new (__webpack_require__(/*! ./formatters/minilog.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/minilog.js\"));\ne.formatWithStack = new (__webpack_require__(/*! ./formatters/withstack.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/withstack.js\"));\ne.formatTime = new (__webpack_require__(/*! ./formatters/time.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/time.js\"));\n\nmodule.exports = e;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/console.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/clean.js":
/*!***********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/clean.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nfunction FormatClean() {}\n\nTransform.mixin(FormatClean);\n\nFormatClean.prototype.write = function(name, level, args) {\n  function pad(s) { return (s.toString().length == 1? '0'+s : s); }\n  this.emit('item', (name ? name + ' ' : '') + (level ? level + ' ' : '') + args.join(' '));\n};\n\nmodule.exports = FormatClean;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/clean.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/color.js":
/*!***********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/color.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    style = (__webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").style);\n\nfunction FormatColor() {}\n\nTransform.mixin(FormatColor);\n\nFormatColor.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style('- ' + pad(level.toUpperCase()) + ' -', colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatColor;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/color.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/learnboost.js":
/*!****************************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/learnboost.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    style = (__webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").style);\n\nfunction FormatLearnboost() {}\n\nTransform.mixin(FormatLearnboost);\n\nFormatLearnboost.prototype.write = function(name, level, args) {\n  var colors = { debug: 'grey', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n          + (level ? style(level, colors[level]) + ' ' : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatLearnboost;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/learnboost.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/minilog.js":
/*!*************************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/minilog.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    style = (__webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").style),\n    util = __webpack_require__(/*! util */ \"util\");\n\nfunction FormatMinilog() {}\n\nTransform.mixin(FormatMinilog);\n\nFormatMinilog.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatMinilog;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/minilog.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/npm.js":
/*!*********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/npm.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var out = {\n        debug: '\\033[34;40m' + 'debug' + '\\033[39m ',\n        info: '\\033[32m' + 'info'  + '\\033[39m  ',\n        warn: '\\033[30;41m' + 'WARN' + '\\033[0m  ',\n        error: '\\033[31;40m' + 'ERR!' + '\\033[0m  '\n      };\n  this.emit('item', (name ? '\\033[37;40m'+ name +'\\033[0m ' : '')\n          + (level && out[level]? out[level] : '')\n          + args.join(' '));\n};\n\nmodule.exports = FormatNpm;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/npm.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/time.js":
/*!**********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/time.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    style = (__webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").style),\n    util = __webpack_require__(/*! util */ \"util\");\n\nfunction FormatTime() {}\n\nfunction timestamp() {\n  var d = new Date();\n  return ('0' + d.getDate()).slice(-2) + '-' +\n    ('0' + (d.getMonth() + 1)).slice(-2) + '-' +\n    d.getFullYear() + ' ' +\n    ('0' + d.getHours()).slice(-2) + ':' +\n    ('0' + d.getMinutes()).slice(-2) + ':' +\n    ('0' + d.getSeconds()).slice(-2) + '.' +\n    ('00' + d.getMilliseconds()).slice(-3);\n}\n\nTransform.mixin(FormatTime);\n\nFormatTime.prototype.write = function(name, level, args) {\n  var colors = { debug: 'blue', info: 'cyan', warn: 'yellow', error: 'red' };\n  this.emit('item', style(timestamp() +' ', 'grey')\n            + (name ? style(name +' ', 'grey') : '')\n            + (level ? style(level, colors[level]) + ' ' : '')\n            + args.map(function(item) {\n              return (typeof item == 'string' ? item : util.inspect(item, null, 3, true));\n            }).join(' '));\n};\n\nmodule.exports = FormatTime;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/time.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/util.js":
/*!**********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/util.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var styles = {\n    //styles\n    'bold'      : ['\\033[1m',  '\\033[22m'],\n    'italic'    : ['\\033[3m',  '\\033[23m'],\n    'underline' : ['\\033[4m',  '\\033[24m'],\n    'inverse'   : ['\\033[7m',  '\\033[27m'],\n    //grayscale\n    'white'     : ['\\033[37m', '\\033[39m'],\n    'grey'      : ['\\033[90m', '\\033[39m'],\n    'black'     : ['\\033[30m', '\\033[39m'],\n    //colors\n    'blue'      : ['\\033[34m', '\\033[39m'],\n    'cyan'      : ['\\033[36m', '\\033[39m'],\n    'green'     : ['\\033[32m', '\\033[39m'],\n    'magenta'   : ['\\033[35m', '\\033[39m'],\n    'red'       : ['\\033[31m', '\\033[39m'],\n    'yellow'    : ['\\033[33m', '\\033[39m']\n  };\n\nexports.levelMap = { debug: 1, info: 2, warn: 3, error: 4 };\n\nexports.style = function(str, style) {\n  return styles[style][0] + str + styles[style][1];\n}\n\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/util.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/formatters/withstack.js":
/*!***************************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/formatters/withstack.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    style = (__webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/node/formatters/util.js\").style);\n\nfunction FormatNpm() {}\n\nTransform.mixin(FormatNpm);\n\nfunction noop(a){\n  return a;\n}\n\nvar types = {\n  string: noop,\n  number: noop,\n  default: JSON.stringify.bind(JSON)\n};\n\nfunction stringify(args) {\n  return args.map(function(arg) {\n    return (types[typeof arg] || types.default)(arg);\n  });\n}\n\nFormatNpm.prototype.write = function(name, level, args) {\n  var colors = { debug: 'magenta', info: 'cyan', warn: 'yellow', error: 'red' };\n  function pad(s) { return (s.toString().length == 4? ' '+s : s); }\n  function getStack() {\n    var orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (err, stack) {\n      return stack;\n    };\n    var err = new Error;\n    Error.captureStackTrace(err, arguments.callee);\n    var stack = err.stack;\n    Error.prepareStackTrace = orig;\n    return stack;\n  }\n\n  var frame = getStack()[5],\n      fileName = FormatNpm.fullPath ? frame.getFileName() : frame.getFileName().replace(/^.*\\/(.+)$/, '/$1');\n\n  this.emit('item', (name ? name + ' ' : '')\n          + (level ? style(pad(level), colors[level]) + ' ' : '')\n          + style(fileName + \":\" + frame.getLineNumber(), 'grey')\n          + ' '\n          + stringify(args).join(' '));\n};\n\nFormatNpm.fullPath = true;\n\nmodule.exports = FormatNpm;\n\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/formatters/withstack.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/redis.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/redis.js ***!
  \************************************************************/
/***/ ((module) => {

eval("function RedisBackend(options) {\n  this.client = options.client;\n  this.key = options.key;\n}\n\nRedisBackend.prototype.write = function(str) {\n  this.client.rpush(this.key, str);\n};\n\nRedisBackend.prototype.end = function() {};\n\nRedisBackend.prototype.clear = function(cb) {\n  this.client.del(this.key, cb);\n};\n\nmodule.exports = RedisBackend;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/redis.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/node/stringify.js":
/*!****************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/node/stringify.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nfunction Stringify() {}\n\nTransform.mixin(Stringify);\n\nStringify.prototype.write = function(name, level, args) {\n  var result = [];\n  if(name) result.push(name);\n  if(level) result.push(level);\n  result = result.concat(args);\n  for(var i = 0; i < result.length; i++) {\n    if(result[i] && typeof result[i] == 'object') {\n      // Buffers in Node.js look bad when stringified\n      if(result[i].constructor && result[i].constructor.isBuffer) {\n        result[i] = result[i].toString();\n      } else {\n        try {\n          result[i] = JSON.stringify(result[i]);\n        } catch(stringifyError) {\n          // happens when an object has a circular structure\n          // do not throw an error, when printing, the toString() method of the object will be used\n        }\n      }\n    } else {\n      result[i] = result[i];\n    }\n  }\n  this.emit('item',  result.join(' ') + '\\n');\n};\n\nmodule.exports = Stringify;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/node/stringify.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/web/console.js":
/*!*************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/web/console.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\");\n\nvar newlines = /\\n+$/,\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var i = args.length-1;\n  if (typeof console === 'undefined' || !console.log) {\n    return;\n  }\n  if(console.log.apply) {\n    return console.log.apply(console, [name, level].concat(args));\n  } else if(JSON && JSON.stringify) {\n    // console.log.apply is undefined in IE8 and IE9\n    // for IE8/9: make console.log at least a bit less awful\n    if(args[i] && typeof args[i] == 'string') {\n      args[i] = args[i].replace(newlines, '');\n    }\n    try {\n      for(i = 0; i < args.length; i++) {\n        args[i] = JSON.stringify(args[i]);\n      }\n    } catch(e) {}\n    console.log(args.join(' '));\n  }\n};\n\nlogger.formatters = ['color', 'minilog'];\nlogger.color = __webpack_require__(/*! ./formatters/color.js */ \"../scratch-vm/node_modules/minilog/lib/web/formatters/color.js\");\nlogger.minilog = __webpack_require__(/*! ./formatters/minilog.js */ \"../scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js\");\n\nmodule.exports = logger;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/web/console.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/web/formatters/color.js":
/*!**********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/web/formatters/color.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    color = __webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/web/formatters/util.js\");\n\nvar colors = { debug: ['cyan'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(console[level] && console[level].apply) {\n    fn = console[level];\n    fn.apply(console, [ '%c'+name+' %c'+level, color('gray'), color.apply(color, colors[level])].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/web/formatters/color.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js":
/*!************************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var Transform = __webpack_require__(/*! ../../common/transform.js */ \"../scratch-vm/node_modules/minilog/lib/common/transform.js\"),\n    color = __webpack_require__(/*! ./util.js */ \"../scratch-vm/node_modules/minilog/lib/web/formatters/util.js\"),\n    colors = { debug: ['gray'], info: ['purple' ], warn: [ 'yellow', true ], error: [ 'red', true ] },\n    logger = new Transform();\n\nlogger.write = function(name, level, args) {\n  var fn = console.log;\n  if(level != 'debug' && console[level]) {\n    fn = console[level];\n  }\n\n  var subset = [], i = 0;\n  if(level != 'info') {\n    for(; i < args.length; i++) {\n      if(typeof args[i] != 'string') break;\n    }\n    fn.apply(console, [ '%c'+name +' '+ args.slice(0, i).join(' '), color.apply(color, colors[level]) ].concat(args.slice(i)));\n  } else {\n    fn.apply(console, [ '%c'+name, color.apply(color, colors[level]) ].concat(args));\n  }\n};\n\n// NOP, because piping the formatted logs can only cause trouble.\nlogger.pipe = function() { };\n\nmodule.exports = logger;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/web/formatters/minilog.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/minilog/lib/web/formatters/util.js":
/*!*********************************************************************!*\
  !*** ../scratch-vm/node_modules/minilog/lib/web/formatters/util.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("var hex = {\n  black: '#000',\n  red: '#c23621',\n  green: '#25bc26',\n  yellow: '#bbbb00',\n  blue:  '#492ee1',\n  magenta: '#d338d3',\n  cyan: '#33bbc8',\n  gray: '#808080',\n  purple: '#708'\n};\nfunction color(fg, isInverse) {\n  if(isInverse) {\n    return 'color: #fff; background: '+hex[fg]+';';\n  } else {\n    return 'color: '+hex[fg]+';';\n  }\n}\n\nmodule.exports = color;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/minilog/lib/web/formatters/util.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/errors.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/errors.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst codes = {};\n\nfunction createErrorType(code, message, Base) {\n  if (!Base) {\n    Base = Error\n  }\n\n  function getMessage (arg1, arg2, arg3) {\n    if (typeof message === 'string') {\n      return message\n    } else {\n      return message(arg1, arg2, arg3)\n    }\n  }\n\n  class NodeError extends Base {\n    constructor (arg1, arg2, arg3) {\n      super(getMessage(arg1, arg2, arg3));\n    }\n  }\n\n  NodeError.prototype.name = Base.name;\n  NodeError.prototype.code = code;\n\n  codes[code] = NodeError;\n}\n\n// https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\nfunction oneOf(expected, thing) {\n  if (Array.isArray(expected)) {\n    const len = expected.length;\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or ` +\n             expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\nfunction startsWith(str, search, pos) {\n\treturn str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\nfunction endsWith(str, search, this_len) {\n\tif (this_len === undefined || this_len > str.length) {\n\t\tthis_len = str.length;\n\t}\n\treturn str.substring(this_len - search.length, this_len) === search;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\nfunction includes(str, search, start) {\n  if (typeof start !== 'number') {\n    start = 0;\n  }\n\n  if (start + search.length > str.length) {\n    return false;\n  } else {\n    return str.indexOf(search, start) !== -1;\n  }\n}\n\ncreateErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n  return 'The value \"' + value + '\" is invalid for option \"' + name + '\"'\n}, TypeError);\ncreateErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n  // determiner: 'must be' or 'must not be'\n  let determiner;\n  if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n    determiner = 'must not be';\n    expected = expected.replace(/^not /, '');\n  } else {\n    determiner = 'must be';\n  }\n\n  let msg;\n  if (endsWith(name, ' argument')) {\n    // For cases like 'first argument'\n    msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n  } else {\n    const type = includes(name, '.') ? 'property' : 'argument';\n    msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n  }\n\n  msg += `. Received type ${typeof actual}`;\n  return msg;\n}, TypeError);\ncreateErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\ncreateErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n  return 'The ' + name + ' method is not implemented'\n});\ncreateErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\ncreateErrorType('ERR_STREAM_DESTROYED', function (name) {\n  return 'Cannot call ' + name + ' after a stream was destroyed';\n});\ncreateErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\ncreateErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\ncreateErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\ncreateErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\ncreateErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n  return 'Unknown encoding: ' + arg\n}, TypeError);\ncreateErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n\nmodule.exports.codes = codes;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/errors.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_writable.js\");\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Duplex, Readable);\n{\n  // Allow the keys array to be GC'ed.\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n  Readable.call(this, options);\n  Writable.call(this, options);\n  this.allowHalfOpen = true;\n  if (options) {\n    if (options.readable === false) this.readable = false;\n    if (options.writable === false) this.writable = false;\n    if (options.allowHalfOpen === false) {\n      this.allowHalfOpen = false;\n      this.once('end', onend);\n    }\n  }\n}\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nObject.defineProperty(Duplex.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // If the writable side ended, then we're ok.\n  if (this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(onEndNT, this);\n}\nfunction onEndNT(self) {\n  self.end();\n}\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_transform.js\");\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(PassThrough, Transform);\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n  Transform.call(this, options);\n}\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar EElistenerCount = function EElistenerCount(emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ \"util\");\nvar debug;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function debug() {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/buffer_list.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/state.js\"),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes),\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n\n// Lazy loaded to improve the startup performance.\nvar StringDecoder;\nvar createReadableStreamAsyncIterator;\nvar from;\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Readable, Stream);\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\nfunction ReadableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this.paused = true;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"../scratch-vm/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  this._readableState = new ReadableState(options, this, isDuplex);\n\n  // legacy\n  this.readable = true;\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n  Stream.call(this);\n}\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  debug('readableAddChunk', chunk);\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      errorOrDestroy(stream, er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n      if (addToFront) {\n        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n      } else if (state.destroyed) {\n        return false;\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n      maybeReadMore(stream, state);\n    }\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also, if we have no data yet, we can stand some more bytes.\n  // This is to work around cases where hwm=0, such as the repl.\n  return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n}\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    state.awaitDrain = 0;\n    stream.emit('data', chunk);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n  }\n  return er;\n}\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ \"../scratch-vm/node_modules/string_decoder/lib/string_decoder.js\").StringDecoder);\n  var decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null), decoder.encoding equals utf8\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  // Iterate over current buffer to convert already stored Buffers:\n  var p = this._readableState.buffer.head;\n  var content = '';\n  while (p !== null) {\n    content += decoder.write(p.data);\n    p = p.next;\n  }\n  this._readableState.buffer.clear();\n  if (content !== '') this._readableState.buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB\nvar MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    state.awaitDrain = 0;\n  }\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n  if (ret !== null) this.emit('data', ret);\n  return ret;\n};\nfunction onEofChunk(stream, state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n  if (state.sync) {\n    // if we are sync, wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call\n    emitReadable(stream);\n  } else {\n    // emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    if (!state.emittedReadable) {\n      state.emittedReadable = true;\n      emitReadable_(stream);\n    }\n  }\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  debug('emitReadable', state.needReadable, state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_, stream);\n  }\n}\nfunction emitReadable_(stream) {\n  var state = stream._readableState;\n  debug('emitReadable_', state.destroyed, state.length, state.ended);\n  if (!state.destroyed && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if\n  // 1. It is not flowing, as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark, so we can schedule\n  //    another readable later.\n  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_, stream, state);\n  }\n}\nfunction maybeReadMore_(stream, state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer, and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data, the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the the stream has called the implementation defined _read()\n  //   method, but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n    var len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n};\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    debug('dest.write', ret);\n    if (ret === false) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', state.awaitDrain);\n        state.awaitDrain++;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n  return dest;\n};\nfunction pipeOnDrain(src) {\n  return function pipeOnDrainFunctionResult() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = {\n    hasUnpiped: false\n  };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {\n      hasUnpiped: false\n    });\n    return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n  dest.emit('unpipe', this, unpipeInfo);\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n  var state = this._readableState;\n  if (ev === 'data') {\n    // update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused\n    if (state.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable', state.length, state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick, this);\n      }\n    }\n  }\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\nReadable.prototype.removeListener = function (ev, fn) {\n  var res = Stream.prototype.removeListener.call(this, ev, fn);\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nReadable.prototype.removeAllListeners = function (ev) {\n  var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable', fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening, this);\n  }\n  return res;\n};\nfunction updateReadableListening(self) {\n  var state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n  if (state.resumeScheduled && !state.paused) {\n    // flowing needs to be set to true now, otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // crude way to check if we should resume\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  }\n}\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // we flow only if there is no one listening\n    // for readable, but we still have to call\n    // resume()\n    state.flowing = !state.readableListening;\n    resume(this, state);\n  }\n  state.paused = false;\n  return this;\n};\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_, stream, state);\n  }\n}\nfunction resume_(stream, state) {\n  debug('resume', state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState.paused = true;\n  return this;\n};\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n  var state = this._readableState;\n  var paused = false;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n    _this.push(null);\n  });\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function methodWrap(method) {\n        return function methodWrapReturnFunction() {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n  return this;\n};\nif (typeof Symbol === 'function') {\n  Readable.prototype[Symbol.asyncIterator] = function () {\n    if (createReadableStreamAsyncIterator === undefined) {\n      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/async_iterator.js\");\n    }\n    return createReadableStreamAsyncIterator(this);\n  };\n}\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.highWaterMark;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState && this._readableState.buffer;\n  }\n});\nObject.defineProperty(Readable.prototype, 'readableFlowing', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.flowing;\n  },\n  set: function set(state) {\n    if (this._readableState) {\n      this._readableState.flowing = state;\n    }\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\nObject.defineProperty(Readable.prototype, 'readableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._readableState.length;\n  }\n});\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = state.buffer.consume(n, state.decoder);\n  }\n  return ret;\n}\nfunction endReadable(stream) {\n  var state = stream._readableState;\n  debug('endReadable', state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT, state, stream);\n  }\n}\nfunction endReadableNT(state, stream) {\n  debug('endReadableNT', state.endEmitted, state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n    if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well\n      var wState = stream._writableState;\n      if (!wState || wState.autoDestroy && wState.finished) {\n        stream.destroy();\n      }\n    }\n  }\n}\nif (typeof Symbol === 'function') {\n  Readable.from = function (iterable, opts) {\n    if (from === undefined) {\n      from = __webpack_require__(/*! ./internal/streams/from */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/from.js\");\n    }\n    return from(Readable, iterable, opts);\n  };\n}\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes),\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Transform, Duplex);\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n  var cb = ts.writecb;\n  if (cb === null) {\n    return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n  }\n  ts.writechunk = null;\n  ts.writecb = null;\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    this.push(data);\n  cb(er);\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n  Duplex.call(this, options);\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\nfunction prefinish() {\n  var _this = this;\n  if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n};\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n  if (ts.writechunk !== null && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\nTransform.prototype._destroy = function (err, cb) {\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n  });\n};\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n  if (data != null)\n    // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // TODO(BridgeAR): Write a test for these two error cases\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"../scratch-vm/node_modules/util-deprecate/node.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/stream.js\");\n/*</replacement>*/\n\nvar Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer);\nvar OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar _require = __webpack_require__(/*! ./internal/streams/state */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/state.js\"),\n  getHighWaterMark = _require.getHighWaterMark;\nvar _require$codes = (__webpack_require__(/*! ../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes),\n  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\nvar errorOrDestroy = destroyImpl.errorOrDestroy;\n__webpack_require__(/*! inherits */ \"../scratch-vm/node_modules/inherits/inherits.js\")(Writable, Stream);\nfunction nop() {}\nfunction WritableState(options, stream, isDuplex) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream,\n  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end')\n  this.autoDestroy = !!options.autoDestroy;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function writableStateBufferGetter() {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function value(object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function realHasInstance(object) {\n    return object instanceof this;\n  };\n}\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor, at least with V8 6.5\n  var isDuplex = this instanceof Duplex;\n  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n  this._writableState = new WritableState(options, this, isDuplex);\n\n  // legacy.\n  this.writable = true;\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n};\nfunction writeAfterEnd(stream, cb) {\n  var er = new ERR_STREAM_WRITE_AFTER_END();\n  // TODO: defer error events consistently everywhere, not just the cb\n  errorOrDestroy(stream, er);\n  process.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var er;\n  if (chunk === null) {\n    er = new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk !== 'string' && !state.objectMode) {\n    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n  }\n  if (er) {\n    errorOrDestroy(stream, er);\n    process.nextTick(cb, er);\n    return false;\n  }\n  return true;\n}\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n  return ret;\n};\nWritable.prototype.cork = function () {\n  this._writableState.corked++;\n};\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableBuffer', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState && this._writableState.getBuffer();\n  }\n});\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n  return ret;\n}\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    process.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    process.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    errorOrDestroy(stream, er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state) || stream.destroyed;\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n    if (sync) {\n      process.nextTick(afterWrite, stream, state, finished, cb);\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n};\nWritable.prototype._writev = null;\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending) endWritable(this, state, cb);\n  return this;\n};\nObject.defineProperty(Writable.prototype, 'writableLength', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    return this._writableState.length;\n  }\n});\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      errorOrDestroy(stream, err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.pendingcb++;\n      state.finalCalled = true;\n      process.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n      if (state.autoDestroy) {\n        // In case of duplex streams we need a way to detect\n        // if the readable side is ready for autoDestroy as well\n        var rState = stream._readableState;\n        if (!rState || rState.autoDestroy && rState.endEmitted) {\n          stream.destroy();\n        }\n      }\n    }\n  }\n  return need;\n}\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n\n  // reuse the free corkReq.\n  state.corkedRequestsFree.next = corkReq;\n}\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function get() {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function set(value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  cb(err);\n};\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar _Object$setPrototypeO;\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar finished = __webpack_require__(/*! ./end-of-stream */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\nvar kLastResolve = Symbol('lastResolve');\nvar kLastReject = Symbol('lastReject');\nvar kError = Symbol('error');\nvar kEnded = Symbol('ended');\nvar kLastPromise = Symbol('lastPromise');\nvar kHandlePromise = Symbol('handlePromise');\nvar kStream = Symbol('stream');\nfunction createIterResult(value, done) {\n  return {\n    value: value,\n    done: done\n  };\n}\nfunction readAndResolve(iter) {\n  var resolve = iter[kLastResolve];\n  if (resolve !== null) {\n    var data = iter[kStream].read();\n    // we defer if data is null\n    // we can be expecting either 'end' or\n    // 'error'\n    if (data !== null) {\n      iter[kLastPromise] = null;\n      iter[kLastResolve] = null;\n      iter[kLastReject] = null;\n      resolve(createIterResult(data, false));\n    }\n  }\n}\nfunction onReadable(iter) {\n  // we wait for the next tick, because it might\n  // emit an error with process.nextTick\n  process.nextTick(readAndResolve, iter);\n}\nfunction wrapForNext(lastPromise, iter) {\n  return function (resolve, reject) {\n    lastPromise.then(function () {\n      if (iter[kEnded]) {\n        resolve(createIterResult(undefined, true));\n        return;\n      }\n      iter[kHandlePromise](resolve, reject);\n    }, reject);\n  };\n}\nvar AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\nvar ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n  get stream() {\n    return this[kStream];\n  },\n  next: function next() {\n    var _this = this;\n    // if we have detected an error in the meanwhile\n    // reject straight away\n    var error = this[kError];\n    if (error !== null) {\n      return Promise.reject(error);\n    }\n    if (this[kEnded]) {\n      return Promise.resolve(createIterResult(undefined, true));\n    }\n    if (this[kStream].destroyed) {\n      // We need to defer via nextTick because if .destroy(err) is\n      // called, the error will be emitted via nextTick, and\n      // we cannot guarantee that there is no error lingering around\n      // waiting to be emitted.\n      return new Promise(function (resolve, reject) {\n        process.nextTick(function () {\n          if (_this[kError]) {\n            reject(_this[kError]);\n          } else {\n            resolve(createIterResult(undefined, true));\n          }\n        });\n      });\n    }\n\n    // if we have multiple next() calls\n    // we will wait for the previous Promise to finish\n    // this logic is optimized to support for await loops,\n    // where next() is only called once at a time\n    var lastPromise = this[kLastPromise];\n    var promise;\n    if (lastPromise) {\n      promise = new Promise(wrapForNext(lastPromise, this));\n    } else {\n      // fast path needed to support multiple this.push()\n      // without triggering the next() queue\n      var data = this[kStream].read();\n      if (data !== null) {\n        return Promise.resolve(createIterResult(data, false));\n      }\n      promise = new Promise(this[kHandlePromise]);\n    }\n    this[kLastPromise] = promise;\n    return promise;\n  }\n}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n  return this;\n}), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n  var _this2 = this;\n  // destroy(err, cb) is a private API\n  // we can guarantee we have that here, because we control the\n  // Readable class this is attached to\n  return new Promise(function (resolve, reject) {\n    _this2[kStream].destroy(null, function (err) {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve(createIterResult(undefined, true));\n    });\n  });\n}), _Object$setPrototypeO), AsyncIteratorPrototype);\nvar createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n  var _Object$create;\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n    value: stream,\n    writable: true\n  }), _defineProperty(_Object$create, kLastResolve, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kLastReject, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kError, {\n    value: null,\n    writable: true\n  }), _defineProperty(_Object$create, kEnded, {\n    value: stream._readableState.endEmitted,\n    writable: true\n  }), _defineProperty(_Object$create, kHandlePromise, {\n    value: function value(resolve, reject) {\n      var data = iterator[kStream].read();\n      if (data) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        resolve(createIterResult(data, false));\n      } else {\n        iterator[kLastResolve] = resolve;\n        iterator[kLastReject] = reject;\n      }\n    },\n    writable: true\n  }), _Object$create));\n  iterator[kLastPromise] = null;\n  finished(stream, function (err) {\n    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n      var reject = iterator[kLastReject];\n      // reject if we are waiting for data in the Promise\n      // returned by next() and store the error\n      if (reject !== null) {\n        iterator[kLastPromise] = null;\n        iterator[kLastResolve] = null;\n        iterator[kLastReject] = null;\n        reject(err);\n      }\n      iterator[kError] = err;\n      return;\n    }\n    var resolve = iterator[kLastResolve];\n    if (resolve !== null) {\n      iterator[kLastPromise] = null;\n      iterator[kLastResolve] = null;\n      iterator[kLastReject] = null;\n      resolve(createIterResult(undefined, true));\n    }\n    iterator[kEnded] = true;\n  });\n  stream.on('readable', onReadable.bind(null, iterator));\n  return iterator;\n};\nmodule.exports = createReadableStreamAsyncIterator;\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/async_iterator.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = __webpack_require__(/*! buffer */ \"buffer\"),\n  Buffer = _require.Buffer;\nvar _require2 = __webpack_require__(/*! util */ \"util\"),\n  inspect = _require2.inspect;\nvar custom = inspect && inspect.custom || 'inspect';\nfunction copyBuffer(src, target, offset) {\n  Buffer.prototype.copy.call(src, target, offset);\n}\nmodule.exports = /*#__PURE__*/function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while (p = p.next) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        copyBuffer(p.data, ret, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var ret;\n      if (n < this.head.data.length) {\n        // `slice` is the same for buffers and strings.\n        ret = this.head.data.slice(0, n);\n        this.head.data = this.head.data.slice(n);\n      } else if (n === this.head.data.length) {\n        // First chunk is a perfect match.\n        ret = this.shift();\n      } else {\n        // Result spans more than one buffer.\n        ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n      }\n      return ret;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n\n    // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var p = this.head;\n      var c = 1;\n      var ret = p.data;\n      n -= ret.length;\n      while (p = p.next) {\n        var str = p.data;\n        var nb = n > str.length ? str.length : n;\n        if (nb === str.length) ret += str;else ret += str.slice(0, n);\n        n -= nb;\n        if (n === 0) {\n          if (nb === str.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = str.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var p = this.head;\n      var c = 1;\n      p.data.copy(ret);\n      n -= p.data.length;\n      while (p = p.next) {\n        var buf = p.data;\n        var nb = n > buf.length ? buf.length : n;\n        buf.copy(ret, ret.length - n, 0, nb);\n        n -= nb;\n        if (n === 0) {\n          if (nb === buf.length) {\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            this.head = p;\n            p.data = buf.slice(nb);\n          }\n          break;\n        }\n        ++c;\n      }\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: custom,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}();\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/buffer_list.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      if (!_this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else if (!_this._writableState.errorEmitted) {\n        _this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, _this, err);\n      } else {\n        process.nextTick(emitCloseNT, _this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, _this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, _this);\n    }\n  });\n  return this;\n}\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose) return;\n  if (self._readableState && !self._readableState.emitClose) return;\n  self.emit('close');\n}\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finalCalled = false;\n    this._writableState.prefinished = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\nfunction errorOrDestroy(stream, err) {\n  // We have tests that rely on errors being emitted\n  // in the same tick, so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  var rState = stream._readableState;\n  var wState = stream._writableState;\n  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n}\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy,\n  errorOrDestroy: errorOrDestroy\n};\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\n\nvar ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes).ERR_STREAM_PREMATURE_CLOSE;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    callback.apply(this, args);\n  };\n}\nfunction noop() {}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction eos(stream, opts, callback) {\n  if (typeof opts === 'function') return eos(stream, null, opts);\n  if (!opts) opts = {};\n  callback = once(callback || noop);\n  var readable = opts.readable || opts.readable !== false && stream.readable;\n  var writable = opts.writable || opts.writable !== false && stream.writable;\n  var onlegacyfinish = function onlegacyfinish() {\n    if (!stream.writable) onfinish();\n  };\n  var writableEnded = stream._writableState && stream._writableState.finished;\n  var onfinish = function onfinish() {\n    writable = false;\n    writableEnded = true;\n    if (!readable) callback.call(stream);\n  };\n  var readableEnded = stream._readableState && stream._readableState.endEmitted;\n  var onend = function onend() {\n    readable = false;\n    readableEnded = true;\n    if (!writable) callback.call(stream);\n  };\n  var onerror = function onerror(err) {\n    callback.call(stream, err);\n  };\n  var onclose = function onclose() {\n    var err;\n    if (readable && !readableEnded) {\n      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n    if (writable && !writableEnded) {\n      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n      return callback.call(stream, err);\n    }\n  };\n  var onrequest = function onrequest() {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    stream.on('abort', onclose);\n    if (stream.req) onrequest();else stream.on('request', onrequest);\n  } else if (writable && !stream._writableState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (opts.error !== false) stream.on('error', onerror);\n  stream.on('close', onclose);\n  return function () {\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n}\nmodule.exports = eos;\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/from.js":
/*!*******************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/from.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar ERR_INVALID_ARG_TYPE = (__webpack_require__(/*! ../../../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes).ERR_INVALID_ARG_TYPE;\nfunction from(Readable, iterable, opts) {\n  var iterator;\n  if (iterable && typeof iterable.next === 'function') {\n    iterator = iterable;\n  } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();else throw new ERR_INVALID_ARG_TYPE('iterable', ['Iterable'], iterable);\n  var readable = new Readable(_objectSpread({\n    objectMode: true\n  }, opts));\n  // Reading boolean to protect against _read\n  // being called before last iteration completion.\n  var reading = false;\n  readable._read = function () {\n    if (!reading) {\n      reading = true;\n      next();\n    }\n  };\n  function next() {\n    return _next2.apply(this, arguments);\n  }\n  function _next2() {\n    _next2 = _asyncToGenerator(function* () {\n      try {\n        var _yield$iterator$next = yield iterator.next(),\n          value = _yield$iterator$next.value,\n          done = _yield$iterator$next.done;\n        if (done) {\n          readable.push(null);\n        } else if (readable.push(yield value)) {\n          next();\n        } else {\n          reading = false;\n        }\n      } catch (err) {\n        readable.destroy(err);\n      }\n    });\n    return _next2.apply(this, arguments);\n  }\n  return readable;\n}\nmodule.exports = from;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/from.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n\n\nvar eos;\nfunction once(callback) {\n  var called = false;\n  return function () {\n    if (called) return;\n    called = true;\n    callback.apply(void 0, arguments);\n  };\n}\nvar _require$codes = (__webpack_require__(/*! ../../../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes),\n  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\nfunction noop(err) {\n  // Rethrow the error if it exists to avoid swallowing it\n  if (err) throw err;\n}\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nfunction destroyer(stream, reading, writing, callback) {\n  callback = once(callback);\n  var closed = false;\n  stream.on('close', function () {\n    closed = true;\n  });\n  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    if (err) return callback(err);\n    closed = true;\n    callback();\n  });\n  var destroyed = false;\n  return function (err) {\n    if (closed) return;\n    if (destroyed) return;\n    destroyed = true;\n\n    // request.destroy just do .end - .abort is what we want\n    if (isRequest(stream)) return stream.abort();\n    if (typeof stream.destroy === 'function') return stream.destroy();\n    callback(err || new ERR_STREAM_DESTROYED('pipe'));\n  };\n}\nfunction call(fn) {\n  fn();\n}\nfunction pipe(from, to) {\n  return from.pipe(to);\n}\nfunction popCallback(streams) {\n  if (!streams.length) return noop;\n  if (typeof streams[streams.length - 1] !== 'function') return noop;\n  return streams.pop();\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  var callback = popCallback(streams);\n  if (Array.isArray(streams[0])) streams = streams[0];\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var error;\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err;\n      if (err) destroys.forEach(call);\n      if (reading) return;\n      destroys.forEach(call);\n      callback(error);\n    });\n  });\n  return streams.reduce(pipe);\n}\nmodule.exports = pipeline;\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/pipeline.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ \"../scratch-vm/node_modules/readable-stream/errors.js\").codes).ERR_INVALID_OPT_VALUE;\nfunction highWaterMarkFrom(options, isDuplex, duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n}\nfunction getHighWaterMark(state, options, duplexKey, isDuplex) {\n  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n  if (hwm != null) {\n    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n      var name = isDuplex ? duplexKey : 'highWaterMark';\n      throw new ERR_INVALID_OPT_VALUE(name, hwm);\n    }\n    return Math.floor(hwm);\n  }\n\n  // Default value\n  return state.objectMode ? 16 : 16 * 1024;\n}\nmodule.exports = {\n  getHighWaterMark: getHighWaterMark\n};\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/state.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/lib/internal/streams/stream.js":
/*!*********************************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/lib/internal/streams/stream.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! stream */ \"stream\");\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/lib/internal/streams/stream.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/readable-stream/readable.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/readable-stream/readable.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var Stream = __webpack_require__(/*! stream */ \"stream\");\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream.Readable;\n  Object.assign(module.exports, Stream);\n  module.exports.Stream = Stream;\n} else {\n  exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_readable.js\");\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_writable.js\");\n  exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_duplex.js\");\n  exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_transform.js\");\n  exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"../scratch-vm/node_modules/readable-stream/lib/_stream_passthrough.js\");\n  exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/end-of-stream.js\");\n  exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ \"../scratch-vm/node_modules/readable-stream/lib/internal/streams/pipeline.js\");\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/readable-stream/readable.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/safe-buffer/index.js":
/*!*******************************************************!*\
  !*** ../scratch-vm/node_modules/safe-buffer/index.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"buffer\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************************!*\
  !*** ../scratch-vm/node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"../scratch-vm/node_modules/safe-buffer/index.js\").Buffer);\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/util-deprecate/node.js":
/*!*********************************************************!*\
  !*** ../scratch-vm/node_modules/util-deprecate/node.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = __webpack_require__(/*! util */ \"util\").deprecate;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/util-deprecate/node.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/index.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/index.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/md5.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/md5.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('md5').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/md5.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/nil.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/nil.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/nil.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/parse.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/parse.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/parse.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/regex.js":
/*!**************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/regex.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/regex.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/rng.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/rng.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto__WEBPACK_IMPORTED_MODULE_0___default().randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/rng.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/sha1.js":
/*!*************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/sha1.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return crypto__WEBPACK_IMPORTED_MODULE_0___default().createHash('sha1').update(bytes).digest();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/sha1.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js":
/*!******************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/v1.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/v1.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/v1.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/v3.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/v3.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/v3.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/v35.js":
/*!************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/v35.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/v35.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/v4.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/v4.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/v4.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/v5.js":
/*!***********************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/v5.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/v5.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/validate.js":
/*!*****************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/validate.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/validate.js?");

/***/ }),

/***/ "../scratch-vm/node_modules/uuid/dist/esm-node/version.js":
/*!****************************************************************!*\
  !*** ../scratch-vm/node_modules/uuid/dist/esm-node/version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"../scratch-vm/node_modules/uuid/dist/esm-node/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/node_modules/uuid/dist/esm-node/version.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_control.js":
/*!****************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_control.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\n\nclass Scratch3ControlBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n\n        /**\n         * The \"counter\" block value. For compatibility with 2.0.\n         * @type {number}\n         */\n        this._counter = 0;\n\n        this.runtime.on('RUNTIME_DISPOSED', this.clearCounter.bind(this));\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            control_repeat: this.repeat,\n            control_repeat_until: this.repeatUntil,\n            control_while: this.repeatWhile,\n            control_for_each: this.forEach,\n            control_forever: this.forever,\n            control_wait: this.wait,\n            control_wait_until: this.waitUntil,\n            control_if: this.if,\n            control_if_else: this.ifElse,\n            control_stop: this.stop,\n            control_create_clone_of: this.createClone,\n            control_delete_this_clone: this.deleteClone,\n            control_get_counter: this.getCounter,\n            control_incr_counter: this.incrCounter,\n            control_clear_counter: this.clearCounter,\n            control_all_at_once: this.allAtOnce\n        };\n    }\n\n    getHats () {\n        return {\n            control_start_as_clone: {\n                restartExistingThreads: false\n            }\n        };\n    }\n\n    repeat (args, util) {\n        const times = Math.round(Cast.toNumber(args.TIMES));\n        // Initialize loop\n        if (typeof util.stackFrame.loopCounter === 'undefined') {\n            util.stackFrame.loopCounter = times;\n        }\n        // Only execute once per frame.\n        // When the branch finishes, `repeat` will be executed again and\n        // the second branch will be taken, yielding for the rest of the frame.\n        // Decrease counter\n        util.stackFrame.loopCounter--;\n        // If we still have some left, start the branch.\n        if (util.stackFrame.loopCounter >= 0) {\n            util.startBranch(1, true);\n        }\n    }\n\n    repeatUntil (args, util) {\n        const condition = Cast.toBoolean(args.CONDITION);\n        // If the condition is false (repeat UNTIL), start the branch.\n        if (!condition) {\n            util.startBranch(1, true);\n        }\n    }\n\n    repeatWhile (args, util) {\n        const condition = Cast.toBoolean(args.CONDITION);\n        // If the condition is true (repeat WHILE), start the branch.\n        if (condition) {\n            util.startBranch(1, true);\n        }\n    }\n\n    forEach (args, util) {\n        const variable = util.target.lookupOrCreateVariable(\n            args.VARIABLE.id, args.VARIABLE.name);\n\n        if (typeof util.stackFrame.index === 'undefined') {\n            util.stackFrame.index = 0;\n        }\n\n        if (util.stackFrame.index < Number(args.VALUE)) {\n            util.stackFrame.index++;\n            variable.value = util.stackFrame.index;\n            util.startBranch(1, true);\n        }\n    }\n\n    waitUntil (args, util) {\n        const condition = Cast.toBoolean(args.CONDITION);\n        if (!condition) {\n            util.yield();\n        }\n    }\n\n    forever (args, util) {\n        util.startBranch(1, true);\n    }\n\n    wait (args, util) {\n        if (util.stackTimerNeedsInit()) {\n            const duration = Math.max(0, 1000 * Cast.toNumber(args.DURATION));\n\n            util.startStackTimer(duration);\n            this.runtime.requestRedraw();\n            util.yield();\n        } else if (!util.stackTimerFinished()) {\n            util.yield();\n        }\n    }\n\n    if (args, util) {\n        const condition = Cast.toBoolean(args.CONDITION);\n        if (condition) {\n            util.startBranch(1, false);\n        }\n    }\n\n    ifElse (args, util) {\n        const condition = Cast.toBoolean(args.CONDITION);\n        if (condition) {\n            util.startBranch(1, false);\n        } else {\n            util.startBranch(2, false);\n        }\n    }\n\n    stop (args, util) {\n        const option = args.STOP_OPTION;\n        if (option === 'all') {\n            util.stopAll();\n        } else if (option === 'other scripts in sprite' ||\n            option === 'other scripts in stage') {\n            util.stopOtherTargetThreads();\n        } else if (option === 'this script') {\n            util.stopThisScript();\n        }\n    }\n\n    createClone (args, util) {\n        // Cast argument to string\n        args.CLONE_OPTION = Cast.toString(args.CLONE_OPTION);\n\n        // Set clone target\n        let cloneTarget;\n        if (args.CLONE_OPTION === '_myself_') {\n            cloneTarget = util.target;\n        } else {\n            cloneTarget = this.runtime.getSpriteTargetByName(args.CLONE_OPTION);\n        }\n\n        // If clone target is not found, return\n        if (!cloneTarget) return;\n\n        // Create clone\n        const newClone = cloneTarget.makeClone();\n        if (newClone) {\n            this.runtime.addTarget(newClone);\n\n            // Place behind the original target.\n            newClone.goBehindOther(cloneTarget);\n        }\n    }\n\n    deleteClone (args, util) {\n        if (util.target.isOriginal) return;\n        this.runtime.disposeTarget(util.target);\n        this.runtime.stopForTarget(util.target);\n    }\n\n    getCounter () {\n        return this._counter;\n    }\n\n    clearCounter () {\n        this._counter = 0;\n    }\n\n    incrCounter () {\n        this._counter++;\n    }\n\n    allAtOnce (args, util) {\n        // Since the \"all at once\" block is implemented for compatiblity with\n        // Scratch 2.0 projects, it behaves the same way it did in 2.0, which\n        // is to simply run the contained script (like \"if 1 = 1\").\n        // (In early versions of Scratch 2.0, it would work the same way as\n        // \"run without screen refresh\" custom blocks do now, but this was\n        // removed before the release of 2.0.)\n        util.startBranch(1, false);\n    }\n}\n\nmodule.exports = Scratch3ControlBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_control.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_data.js":
/*!*************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\n\nclass Scratch3DataBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            data_variable: this.getVariable,\n            data_setvariableto: this.setVariableTo,\n            data_changevariableby: this.changeVariableBy,\n            data_hidevariable: this.hideVariable,\n            data_showvariable: this.showVariable,\n            data_listcontents: this.getListContents,\n            data_addtolist: this.addToList,\n            data_deleteoflist: this.deleteOfList,\n            data_deletealloflist: this.deleteAllOfList,\n            data_insertatlist: this.insertAtList,\n            data_replaceitemoflist: this.replaceItemOfList,\n            data_itemoflist: this.getItemOfList,\n            data_itemnumoflist: this.getItemNumOfList,\n            data_lengthoflist: this.lengthOfList,\n            data_listcontainsitem: this.listContainsItem,\n            data_hidelist: this.hideList,\n            data_showlist: this.showList\n        };\n    }\n\n    getVariable (args, util) {\n        const variable = util.target.lookupOrCreateVariable(\n            args.VARIABLE.id, args.VARIABLE.name);\n        return variable.value;\n    }\n\n    setVariableTo (args, util) {\n        const variable = util.target.lookupOrCreateVariable(\n            args.VARIABLE.id, args.VARIABLE.name);\n        variable.value = args.VALUE;\n\n        if (variable.isCloud) {\n            util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, args.VALUE]);\n        }\n    }\n\n    changeVariableBy (args, util) {\n        const variable = util.target.lookupOrCreateVariable(\n            args.VARIABLE.id, args.VARIABLE.name);\n        const castedValue = Cast.toNumber(variable.value);\n        const dValue = Cast.toNumber(args.VALUE);\n        const newValue = castedValue + dValue;\n        variable.value = newValue;\n\n        if (variable.isCloud) {\n            util.ioQuery('cloud', 'requestUpdateVariable', [variable.name, newValue]);\n        }\n    }\n\n    changeMonitorVisibility (id, visible) {\n        // Send the monitor blocks an event like the flyout checkbox event.\n        // This both updates the monitor state and changes the isMonitored block flag.\n        this.runtime.monitorBlocks.changeBlock({\n            id: id, // Monitor blocks for variables are the variable ID.\n            element: 'checkbox', // Mimic checkbox event from flyout.\n            value: visible\n        }, this.runtime);\n    }\n\n    showVariable (args) {\n        this.changeMonitorVisibility(args.VARIABLE.id, true);\n    }\n\n    hideVariable (args) {\n        this.changeMonitorVisibility(args.VARIABLE.id, false);\n    }\n\n    showList (args) {\n        this.changeMonitorVisibility(args.LIST.id, true);\n    }\n\n    hideList (args) {\n        this.changeMonitorVisibility(args.LIST.id, false);\n    }\n\n    getListContents (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n\n        // If block is running for monitors, return copy of list as an array if changed.\n        if (util.thread.updateMonitor) {\n            // Return original list value if up-to-date, which doesn't trigger monitor update.\n            if (list._monitorUpToDate) return list.value;\n            // If value changed, reset the flag and return a copy to trigger monitor update.\n            // Because monitors use Immutable data structures, only new objects trigger updates.\n            list._monitorUpToDate = true;\n            return list.value.slice();\n        }\n\n        // Determine if the list is all single letters.\n        // If it is, report contents joined together with no separator.\n        // If it's not, report contents joined together with a space.\n        let allSingleLetters = true;\n        for (let i = 0; i < list.value.length; i++) {\n            const listItem = list.value[i];\n            if (!((typeof listItem === 'string') &&\n                  (listItem.length === 1))) {\n                allSingleLetters = false;\n                break;\n            }\n        }\n        if (allSingleLetters) {\n            return list.value.join('');\n        }\n        return list.value.join(' ');\n\n    }\n\n    addToList (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        if (list.value.length < Scratch3DataBlocks.LIST_ITEM_LIMIT) {\n            list.value.push(args.ITEM);\n            list._monitorUpToDate = false;\n        }\n    }\n\n    deleteOfList (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        const index = Cast.toListIndex(args.INDEX, list.value.length, true);\n        if (index === Cast.LIST_INVALID) {\n            return;\n        } else if (index === Cast.LIST_ALL) {\n            list.value = [];\n            return;\n        }\n        list.value.splice(index - 1, 1);\n        list._monitorUpToDate = false;\n    }\n\n    deleteAllOfList (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        list.value = [];\n        return;\n    }\n\n    insertAtList (args, util) {\n        const item = args.ITEM;\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        const index = Cast.toListIndex(args.INDEX, list.value.length + 1, false);\n        if (index === Cast.LIST_INVALID) {\n            return;\n        }\n        const listLimit = Scratch3DataBlocks.LIST_ITEM_LIMIT;\n        if (index > listLimit) return;\n        list.value.splice(index - 1, 0, item);\n        if (list.value.length > listLimit) {\n            // If inserting caused the list to grow larger than the limit,\n            // remove the last element in the list\n            list.value.pop();\n        }\n        list._monitorUpToDate = false;\n    }\n\n    replaceItemOfList (args, util) {\n        const item = args.ITEM;\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        const index = Cast.toListIndex(args.INDEX, list.value.length, false);\n        if (index === Cast.LIST_INVALID) {\n            return;\n        }\n        list.value[index - 1] = item;\n        list._monitorUpToDate = false;\n    }\n\n    getItemOfList (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        const index = Cast.toListIndex(args.INDEX, list.value.length, false);\n        if (index === Cast.LIST_INVALID) {\n            return '';\n        }\n        return list.value[index - 1];\n    }\n\n    getItemNumOfList (args, util) {\n        const item = args.ITEM;\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n\n        // Go through the list items one-by-one using Cast.compare. This is for\n        // cases like checking if 123 is contained in a list [4, 7, '123'] --\n        // Scratch considers 123 and '123' to be equal.\n        for (let i = 0; i < list.value.length; i++) {\n            if (Cast.compare(list.value[i], item) === 0) {\n                return i + 1;\n            }\n        }\n\n        // We don't bother using .indexOf() at all, because it would end up with\n        // edge cases such as the index of '123' in [4, 7, 123, '123', 9].\n        // If we use indexOf(), this block would return 4 instead of 3, because\n        // indexOf() sees the first occurence of the string 123 as the fourth\n        // item in the list. With Scratch, this would be confusing -- after all,\n        // '123' and 123 look the same, so one would expect the block to say\n        // that the first occurrence of '123' (or 123) to be the third item.\n\n        // Default to 0 if there's no match. Since Scratch lists are 1-indexed,\n        // we don't have to worry about this conflicting with the \"this item is\n        // the first value\" number (in JS that is 0, but in Scratch it's 1).\n        return 0;\n    }\n\n    lengthOfList (args, util) {\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        return list.value.length;\n    }\n\n    listContainsItem (args, util) {\n        const item = args.ITEM;\n        const list = util.target.lookupOrCreateList(\n            args.LIST.id, args.LIST.name);\n        if (list.value.indexOf(item) >= 0) {\n            return true;\n        }\n        // Try using Scratch comparison operator on each item.\n        // (Scratch considers the string '123' equal to the number 123).\n        for (let i = 0; i < list.value.length; i++) {\n            if (Cast.compare(list.value[i], item) === 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Type representation for list variables.\n     * @const {number}\n     */\n    static get LIST_ITEM_LIMIT () {\n        return 200000;\n    }\n}\n\nmodule.exports = Scratch3DataBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_data.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_event.js":
/*!**************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_event.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\n\nclass Scratch3EventBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n\n        this.runtime.on('KEY_PRESSED', key => {\n            this.runtime.startHats('event_whenkeypressed', {\n                KEY_OPTION: key\n            });\n            this.runtime.startHats('event_whenkeypressed', {\n                KEY_OPTION: 'any'\n            });\n        });\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            event_whentouchingobject: this.touchingObject,\n            event_broadcast: this.broadcast,\n            event_broadcastandwait: this.broadcastAndWait,\n            event_whengreaterthan: this.hatGreaterThanPredicate\n        };\n    }\n\n    getHats () {\n        return {\n            event_whenflagclicked: {\n                restartExistingThreads: true\n            },\n            event_whenkeypressed: {\n                restartExistingThreads: false\n            },\n            event_whenthisspriteclicked: {\n                restartExistingThreads: true\n            },\n            event_whentouchingobject: {\n                restartExistingThreads: false,\n                edgeActivated: true\n            },\n            event_whenstageclicked: {\n                restartExistingThreads: true\n            },\n            event_whenbackdropswitchesto: {\n                restartExistingThreads: true\n            },\n            event_whengreaterthan: {\n                restartExistingThreads: false,\n                edgeActivated: true\n            },\n            event_whenbroadcastreceived: {\n                restartExistingThreads: true\n            }\n        };\n    }\n\n    touchingObject (args, util) {\n        return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);\n    }\n\n    hatGreaterThanPredicate (args, util) {\n        const option = Cast.toString(args.WHENGREATERTHANMENU).toLowerCase();\n        const value = Cast.toNumber(args.VALUE);\n        switch (option) {\n        case 'timer':\n            return util.ioQuery('clock', 'projectTimer') > value;\n        case 'loudness':\n            return this.runtime.audioEngine && this.runtime.audioEngine.getLoudness() > value;\n        }\n        return false;\n    }\n\n    broadcast (args, util) {\n        const broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(\n            args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);\n        if (broadcastVar) {\n            const broadcastOption = broadcastVar.name;\n            util.startHats('event_whenbroadcastreceived', {\n                BROADCAST_OPTION: broadcastOption\n            });\n        }\n    }\n\n    broadcastAndWait (args, util) {\n        if (!util.stackFrame.broadcastVar) {\n            util.stackFrame.broadcastVar = util.runtime.getTargetForStage().lookupBroadcastMsg(\n                args.BROADCAST_OPTION.id, args.BROADCAST_OPTION.name);\n        }\n        if (util.stackFrame.broadcastVar) {\n            const broadcastOption = util.stackFrame.broadcastVar.name;\n            // Have we run before, starting threads?\n            if (!util.stackFrame.startedThreads) {\n                // No - start hats for this broadcast.\n                util.stackFrame.startedThreads = util.startHats(\n                    'event_whenbroadcastreceived', {\n                        BROADCAST_OPTION: broadcastOption\n                    }\n                );\n                if (util.stackFrame.startedThreads.length === 0) {\n                    // Nothing was started.\n                    return;\n                }\n            }\n            // We've run before; check if the wait is still going on.\n            const instance = this;\n            // Scratch 2 considers threads to be waiting if they are still in\n            // runtime.threads. Threads that have run all their blocks, or are\n            // marked done but still in runtime.threads are still considered to\n            // be waiting.\n            const waiting = util.stackFrame.startedThreads\n                .some(thread => instance.runtime.threads.indexOf(thread) !== -1);\n            if (waiting) {\n                // If all threads are waiting for the next tick or later yield\n                // for a tick as well. Otherwise yield until the next loop of\n                // the threads.\n                if (\n                    util.stackFrame.startedThreads\n                        .every(thread => instance.runtime.isWaitingThread(thread))\n                ) {\n                    util.yieldTick();\n                } else {\n                    util.yield();\n                }\n            }\n        }\n    }\n}\n\nmodule.exports = Scratch3EventBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_event.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_looks.js":
/*!**************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_looks.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\nconst Clone = __webpack_require__(/*! ../util/clone */ \"../scratch-vm/src/util/clone.js\");\nconst RenderedTarget = __webpack_require__(/*! ../sprites/rendered-target */ \"../scratch-vm/src/sprites/rendered-target.js\");\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\nconst StageLayering = __webpack_require__(/*! ../engine/stage-layering */ \"../scratch-vm/src/engine/stage-layering.js\");\nconst getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ \"../scratch-vm/src/util/get-monitor-id.js\");\nconst MathUtil = __webpack_require__(/*! ../util/math-util */ \"../scratch-vm/src/util/math-util.js\");\n\n/**\n * @typedef {object} BubbleState - the bubble state associated with a particular target.\n * @property {Boolean} onSpriteRight - tracks whether the bubble is right or left of the sprite.\n * @property {?int} drawableId - the ID of the associated bubble Drawable, null if none.\n * @property {string} text - the text of the bubble.\n * @property {string} type - the type of the bubble, \"say\" or \"think\"\n * @property {?string} usageId - ID indicating the most recent usage of the say/think bubble.\n *      Used for comparison when determining whether to clear a say/think bubble.\n */\n\nclass Scratch3LooksBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n\n        this._onTargetChanged = this._onTargetChanged.bind(this);\n        this._onResetBubbles = this._onResetBubbles.bind(this);\n        this._onTargetWillExit = this._onTargetWillExit.bind(this);\n        this._updateBubble = this._updateBubble.bind(this);\n\n        // Reset all bubbles on start/stop\n        this.runtime.on('PROJECT_STOP_ALL', this._onResetBubbles);\n        this.runtime.on('targetWasRemoved', this._onTargetWillExit);\n\n        // Enable other blocks to use bubbles like ask/answer\n        this.runtime.on(Scratch3LooksBlocks.SAY_OR_THINK, this._updateBubble);\n    }\n\n    /**\n     * The default bubble state, to be used when a target has no existing bubble state.\n     * @type {BubbleState}\n     */\n    static get DEFAULT_BUBBLE_STATE () {\n        return {\n            drawableId: null,\n            onSpriteRight: true,\n            skinId: null,\n            text: '',\n            type: 'say',\n            usageId: null\n        };\n    }\n\n    /**\n     * The key to load & store a target's bubble-related state.\n     * @type {string}\n     */\n    static get STATE_KEY () {\n        return 'Scratch.looks';\n    }\n\n    /**\n     * Event name for a text bubble being created or updated.\n     * @const {string}\n     */\n    static get SAY_OR_THINK () {\n        // There are currently many places in the codebase which explicitly refer to this event by the string 'SAY',\n        // so keep this as the string 'SAY' for now rather than changing it to 'SAY_OR_THINK' and breaking things.\n        return 'SAY';\n    }\n\n    /**\n     * Limit for say bubble string.\n     * @const {string}\n     */\n    static get SAY_BUBBLE_LIMIT () {\n        return 330;\n    }\n\n    /**\n     * Limit for ghost effect\n     * @const {object}\n     */\n    static get EFFECT_GHOST_LIMIT (){\n        return {min: 0, max: 100};\n    }\n\n    /**\n     * Limit for brightness effect\n     * @const {object}\n     */\n    static get EFFECT_BRIGHTNESS_LIMIT (){\n        return {min: -100, max: 100};\n    }\n\n    /**\n     * @param {Target} target - collect bubble state for this target. Probably, but not necessarily, a RenderedTarget.\n     * @returns {BubbleState} the mutable bubble state associated with that target. This will be created if necessary.\n     * @private\n     */\n    _getBubbleState (target) {\n        let bubbleState = target.getCustomState(Scratch3LooksBlocks.STATE_KEY);\n        if (!bubbleState) {\n            bubbleState = Clone.simple(Scratch3LooksBlocks.DEFAULT_BUBBLE_STATE);\n            target.setCustomState(Scratch3LooksBlocks.STATE_KEY, bubbleState);\n        }\n        return bubbleState;\n    }\n\n    /**\n     * Handle a target which has moved.\n     * @param {RenderedTarget} target - the target which has moved.\n     * @private\n     */\n    _onTargetChanged (target) {\n        const bubbleState = this._getBubbleState(target);\n        if (bubbleState.drawableId) {\n            this._positionBubble(target);\n        }\n    }\n\n    /**\n     * Handle a target which is exiting.\n     * @param {RenderedTarget} target - the target.\n     * @private\n     */\n    _onTargetWillExit (target) {\n        const bubbleState = this._getBubbleState(target);\n        if (bubbleState.drawableId && bubbleState.skinId) {\n            this.runtime.renderer.destroyDrawable(bubbleState.drawableId, StageLayering.SPRITE_LAYER);\n            this.runtime.renderer.destroySkin(bubbleState.skinId);\n            bubbleState.drawableId = null;\n            bubbleState.skinId = null;\n            this.runtime.requestRedraw();\n        }\n        target.removeListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n    }\n\n    /**\n     * Handle project start/stop by clearing all visible bubbles.\n     * @private\n     */\n    _onResetBubbles () {\n        for (let n = 0; n < this.runtime.targets.length; n++) {\n            const bubbleState = this._getBubbleState(this.runtime.targets[n]);\n            bubbleState.text = '';\n            this._onTargetWillExit(this.runtime.targets[n]);\n        }\n        clearTimeout(this._bubbleTimeout);\n    }\n\n    /**\n     * Position the bubble of a target. If it doesn't fit on the specified side, flip and rerender.\n     * @param {!Target} target Target whose bubble needs positioning.\n     * @private\n     */\n    _positionBubble (target) {\n        if (!target.visible) return;\n        const bubbleState = this._getBubbleState(target);\n        const [bubbleWidth, bubbleHeight] = this.runtime.renderer.getCurrentSkinSize(bubbleState.drawableId);\n        let targetBounds;\n        try {\n            targetBounds = target.getBoundsForBubble();\n        } catch (error_) {\n            // Bounds calculation could fail (e.g. on empty costumes), in that case\n            // use the x/y position of the target.\n            targetBounds = {\n                left: target.x,\n                right: target.x,\n                top: target.y,\n                bottom: target.y\n            };\n        }\n        const stageSize = this.runtime.renderer.getNativeSize();\n        const stageBounds = {\n            left: -stageSize[0] / 2,\n            right: stageSize[0] / 2,\n            top: stageSize[1] / 2,\n            bottom: -stageSize[1] / 2\n        };\n        if (bubbleState.onSpriteRight && bubbleWidth + targetBounds.right > stageBounds.right &&\n            (targetBounds.left - bubbleWidth > stageBounds.left)) { // Only flip if it would fit\n            bubbleState.onSpriteRight = false;\n            this._renderBubble(target);\n        } else if (!bubbleState.onSpriteRight && targetBounds.left - bubbleWidth < stageBounds.left &&\n            (bubbleWidth + targetBounds.right < stageBounds.right)) { // Only flip if it would fit\n            bubbleState.onSpriteRight = true;\n            this._renderBubble(target);\n        } else {\n            this.runtime.renderer.updateDrawablePosition(bubbleState.drawableId, [\n                bubbleState.onSpriteRight ? (\n                    Math.max(\n                        stageBounds.left, // Bubble should not extend past left edge of stage\n                        Math.min(stageBounds.right - bubbleWidth, targetBounds.right)\n                    )\n                ) : (\n                    Math.min(\n                        stageBounds.right - bubbleWidth, // Bubble should not extend past right edge of stage\n                        Math.max(stageBounds.left, targetBounds.left - bubbleWidth)\n                    )\n                ),\n                // Bubble should not extend past the top of the stage\n                Math.min(stageBounds.top, targetBounds.bottom + bubbleHeight)\n            ]);\n            this.runtime.requestRedraw();\n        }\n    }\n\n    /**\n     * Create a visible bubble for a target. If a bubble exists for the target,\n     * just set it to visible and update the type/text. Otherwise create a new\n     * bubble and update the relevant custom state.\n     * @param {!Target} target Target who needs a bubble.\n     * @return {undefined} Early return if text is empty string.\n     * @private\n     */\n    _renderBubble (target) {\n        if (!this.runtime.renderer) return;\n\n        const bubbleState = this._getBubbleState(target);\n        const {type, text, onSpriteRight} = bubbleState;\n\n        // Remove the bubble if target is not visible, or text is being set to blank.\n        if (!target.visible || text === '') {\n            this._onTargetWillExit(target);\n            return;\n        }\n\n        if (bubbleState.skinId) {\n            this.runtime.renderer.updateTextSkin(bubbleState.skinId, type, text, onSpriteRight, [0, 0]);\n        } else {\n            target.addListener(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this._onTargetChanged);\n            bubbleState.drawableId = this.runtime.renderer.createDrawable(StageLayering.SPRITE_LAYER);\n            bubbleState.skinId = this.runtime.renderer.createTextSkin(type, text, bubbleState.onSpriteRight, [0, 0]);\n            this.runtime.renderer.updateDrawableSkinId(bubbleState.drawableId, bubbleState.skinId);\n        }\n\n        this._positionBubble(target);\n    }\n\n    /**\n     * Properly format text for a text bubble.\n     * @param {string} text The text to be formatted\n     * @return {string} The formatted text\n     * @private\n     */\n    _formatBubbleText (text) {\n        if (text === '') return text;\n\n        // Non-integers should be rounded to 2 decimal places (no more, no less), unless they're small enough that\n        // rounding would display them as 0.00. This matches 2.0's behavior:\n        // https://github.com/scratchfoundation/scratch-flash/blob/2e4a402ceb205a042887f54b26eebe1c2e6da6c0/src/scratch/ScratchSprite.as#L579-L585\n        if (typeof text === 'number' &&\n            Math.abs(text) >= 0.01 && text % 1 !== 0) {\n            text = text.toFixed(2);\n        }\n\n        // Limit the length of the string.\n        text = String(text).substr(0, Scratch3LooksBlocks.SAY_BUBBLE_LIMIT);\n\n        return text;\n    }\n\n    /**\n     * The entry point for say/think blocks. Clears existing bubble if the text is empty.\n     * Set the bubble custom state and then call _renderBubble.\n     * @param {!Target} target Target that say/think blocks are being called on.\n     * @param {!string} type Either \"say\" or \"think\"\n     * @param {!string} text The text for the bubble, empty string clears the bubble.\n     * @private\n     */\n    _updateBubble (target, type, text) {\n        const bubbleState = this._getBubbleState(target);\n        bubbleState.type = type;\n        bubbleState.text = this._formatBubbleText(text);\n        bubbleState.usageId = uid();\n        this._renderBubble(target);\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            looks_say: this.say,\n            looks_sayforsecs: this.sayforsecs,\n            looks_think: this.think,\n            looks_thinkforsecs: this.thinkforsecs,\n            looks_show: this.show,\n            looks_hide: this.hide,\n            looks_hideallsprites: () => {}, // legacy no-op block\n            looks_switchcostumeto: this.switchCostume,\n            looks_switchbackdropto: this.switchBackdrop,\n            looks_switchbackdroptoandwait: this.switchBackdropAndWait,\n            looks_nextcostume: this.nextCostume,\n            looks_nextbackdrop: this.nextBackdrop,\n            looks_changeeffectby: this.changeEffect,\n            looks_seteffectto: this.setEffect,\n            looks_cleargraphiceffects: this.clearEffects,\n            looks_changesizeby: this.changeSize,\n            looks_setsizeto: this.setSize,\n            looks_changestretchby: () => {}, // legacy no-op blocks\n            looks_setstretchto: () => {},\n            looks_gotofrontback: this.goToFrontBack,\n            looks_goforwardbackwardlayers: this.goForwardBackwardLayers,\n            looks_size: this.getSize,\n            looks_costumenumbername: this.getCostumeNumberName,\n            looks_backdropnumbername: this.getBackdropNumberName\n        };\n    }\n\n    getMonitored () {\n        return {\n            looks_size: {\n                isSpriteSpecific: true,\n                getId: targetId => `${targetId}_size`\n            },\n            looks_costumenumbername: {\n                isSpriteSpecific: true,\n                getId: (targetId, fields) => getMonitorIdForBlockWithArgs(`${targetId}_costumenumbername`, fields)\n            },\n            looks_backdropnumbername: {\n                getId: (_, fields) => getMonitorIdForBlockWithArgs('backdropnumbername', fields)\n            }\n        };\n    }\n\n    say (args, util) {\n        // @TODO in 2.0 calling say/think resets the right/left bias of the bubble\n        this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'say', args.MESSAGE);\n    }\n\n    sayforsecs (args, util) {\n        this.say(args, util);\n        const target = util.target;\n        const usageId = this._getBubbleState(target).usageId;\n        return new Promise(resolve => {\n            this._bubbleTimeout = setTimeout(() => {\n                this._bubbleTimeout = null;\n                // Clear say bubble if it hasn't been changed and proceed.\n                if (this._getBubbleState(target).usageId === usageId) {\n                    this._updateBubble(target, 'say', '');\n                }\n                resolve();\n            }, 1000 * args.SECS);\n        });\n    }\n\n    think (args, util) {\n        this.runtime.emit(Scratch3LooksBlocks.SAY_OR_THINK, util.target, 'think', args.MESSAGE);\n    }\n\n    thinkforsecs (args, util) {\n        this.think(args, util);\n        const target = util.target;\n        const usageId = this._getBubbleState(target).usageId;\n        return new Promise(resolve => {\n            this._bubbleTimeout = setTimeout(() => {\n                this._bubbleTimeout = null;\n                // Clear think bubble if it hasn't been changed and proceed.\n                if (this._getBubbleState(target).usageId === usageId) {\n                    this._updateBubble(target, 'think', '');\n                }\n                resolve();\n            }, 1000 * args.SECS);\n        });\n    }\n\n    show (args, util) {\n        util.target.setVisible(true);\n        this._renderBubble(util.target);\n    }\n\n    hide (args, util) {\n        util.target.setVisible(false);\n        this._renderBubble(util.target);\n    }\n\n    /**\n     * Utility function to set the costume of a target.\n     * Matches the behavior of Scratch 2.0 for different types of arguments.\n     * @param {!Target} target Target to set costume to.\n     * @param {Any} requestedCostume Costume requested, e.g., 0, 'name', etc.\n     * @param {boolean=} optZeroIndex Set to zero-index the requestedCostume.\n     * @return {Array.<!Thread>} Any threads started by this switch.\n     */\n    _setCostume (target, requestedCostume, optZeroIndex) {\n        if (typeof requestedCostume === 'number') {\n            // Numbers should be treated as costume indices, always\n            target.setCostume(optZeroIndex ? requestedCostume : requestedCostume - 1);\n        } else {\n            // Strings should be treated as costume names, where possible\n            const costumeIndex = target.getCostumeIndexByName(requestedCostume.toString());\n\n            if (costumeIndex !== -1) {\n                target.setCostume(costumeIndex);\n            } else if (requestedCostume === 'next costume') {\n                target.setCostume(target.currentCostume + 1);\n            } else if (requestedCostume === 'previous costume') {\n                target.setCostume(target.currentCostume - 1);\n            // Try to cast the string to a number (and treat it as a costume index)\n            // Pure whitespace should not be treated as a number\n            // Note: isNaN will cast the string to a number before checking if it's NaN\n            } else if (!(isNaN(requestedCostume) || Cast.isWhiteSpace(requestedCostume))) {\n                target.setCostume(optZeroIndex ? Number(requestedCostume) : Number(requestedCostume) - 1);\n            }\n        }\n\n        // Per 2.0, 'switch costume' can't start threads even in the Stage.\n        return [];\n    }\n\n    /**\n     * Utility function to set the backdrop of a target.\n     * Matches the behavior of Scratch 2.0 for different types of arguments.\n     * @param {!Target} stage Target to set backdrop to.\n     * @param {Any} requestedBackdrop Backdrop requested, e.g., 0, 'name', etc.\n     * @param {boolean=} optZeroIndex Set to zero-index the requestedBackdrop.\n     * @return {Array.<!Thread>} Any threads started by this switch.\n     */\n    _setBackdrop (stage, requestedBackdrop, optZeroIndex) {\n        if (typeof requestedBackdrop === 'number') {\n            // Numbers should be treated as backdrop indices, always\n            stage.setCostume(optZeroIndex ? requestedBackdrop : requestedBackdrop - 1);\n        } else {\n            // Strings should be treated as backdrop names where possible\n            const costumeIndex = stage.getCostumeIndexByName(requestedBackdrop.toString());\n\n            if (costumeIndex !== -1) {\n                stage.setCostume(costumeIndex);\n            } else if (requestedBackdrop === 'next backdrop') {\n                stage.setCostume(stage.currentCostume + 1);\n            } else if (requestedBackdrop === 'previous backdrop') {\n                stage.setCostume(stage.currentCostume - 1);\n            } else if (requestedBackdrop === 'random backdrop') {\n                const numCostumes = stage.getCostumes().length;\n                if (numCostumes > 1) {\n                    // Don't pick the current backdrop, so that the block\n                    // will always have an observable effect.\n                    const lowerBound = 0;\n                    const upperBound = numCostumes - 1;\n                    const costumeToExclude = stage.currentCostume;\n\n                    const nextCostume = MathUtil.inclusiveRandIntWithout(lowerBound, upperBound, costumeToExclude);\n\n                    stage.setCostume(nextCostume);\n                }\n            // Try to cast the string to a number (and treat it as a costume index)\n            // Pure whitespace should not be treated as a number\n            // Note: isNaN will cast the string to a number before checking if it's NaN\n            } else if (!(isNaN(requestedBackdrop) || Cast.isWhiteSpace(requestedBackdrop))) {\n                stage.setCostume(optZeroIndex ? Number(requestedBackdrop) : Number(requestedBackdrop) - 1);\n            }\n        }\n\n        const newName = stage.getCostumes()[stage.currentCostume].name;\n        return this.runtime.startHats('event_whenbackdropswitchesto', {\n            BACKDROP: newName\n        });\n    }\n\n    switchCostume (args, util) {\n        this._setCostume(util.target, args.COSTUME);\n    }\n\n    nextCostume (args, util) {\n        this._setCostume(\n            util.target, util.target.currentCostume + 1, true\n        );\n    }\n\n    switchBackdrop (args) {\n        this._setBackdrop(this.runtime.getTargetForStage(), args.BACKDROP);\n    }\n\n    switchBackdropAndWait (args, util) {\n        // Have we run before, starting threads?\n        if (!util.stackFrame.startedThreads) {\n            // No - switch the backdrop.\n            util.stackFrame.startedThreads = (\n                this._setBackdrop(\n                    this.runtime.getTargetForStage(),\n                    args.BACKDROP\n                )\n            );\n            if (util.stackFrame.startedThreads.length === 0) {\n                // Nothing was started.\n                return;\n            }\n        }\n        // We've run before; check if the wait is still going on.\n        const instance = this;\n        // Scratch 2 considers threads to be waiting if they are still in\n        // runtime.threads. Threads that have run all their blocks, or are\n        // marked done but still in runtime.threads are still considered to\n        // be waiting.\n        const waiting = util.stackFrame.startedThreads\n            .some(thread => instance.runtime.threads.indexOf(thread) !== -1);\n        if (waiting) {\n            // If all threads are waiting for the next tick or later yield\n            // for a tick as well. Otherwise yield until the next loop of\n            // the threads.\n            if (\n                util.stackFrame.startedThreads\n                    .every(thread => instance.runtime.isWaitingThread(thread))\n            ) {\n                util.yieldTick();\n            } else {\n                util.yield();\n            }\n        }\n    }\n\n    nextBackdrop () {\n        const stage = this.runtime.getTargetForStage();\n        this._setBackdrop(\n            stage, stage.currentCostume + 1, true\n        );\n    }\n\n    clampEffect (effect, value) {\n        let clampedValue = value;\n        switch (effect) {\n        case 'ghost':\n            clampedValue = MathUtil.clamp(value,\n                Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.min,\n                Scratch3LooksBlocks.EFFECT_GHOST_LIMIT.max);\n            break;\n        case 'brightness':\n            clampedValue = MathUtil.clamp(value,\n                Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.min,\n                Scratch3LooksBlocks.EFFECT_BRIGHTNESS_LIMIT.max);\n            break;\n        }\n        return clampedValue;\n    }\n\n    changeEffect (args, util) {\n        const effect = Cast.toString(args.EFFECT).toLowerCase();\n        const change = Cast.toNumber(args.CHANGE);\n        if (!Object.prototype.hasOwnProperty.call(util.target.effects, effect)) return;\n        let newValue = change + util.target.effects[effect];\n        newValue = this.clampEffect(effect, newValue);\n        util.target.setEffect(effect, newValue);\n    }\n\n    setEffect (args, util) {\n        const effect = Cast.toString(args.EFFECT).toLowerCase();\n        let value = Cast.toNumber(args.VALUE);\n        value = this.clampEffect(effect, value);\n        util.target.setEffect(effect, value);\n    }\n\n    clearEffects (args, util) {\n        util.target.clearEffects();\n    }\n\n    changeSize (args, util) {\n        const change = Cast.toNumber(args.CHANGE);\n        util.target.setSize(util.target.size + change);\n    }\n\n    setSize (args, util) {\n        const size = Cast.toNumber(args.SIZE);\n        util.target.setSize(size);\n    }\n\n    goToFrontBack (args, util) {\n        if (!util.target.isStage) {\n            if (args.FRONT_BACK === 'front') {\n                util.target.goToFront();\n            } else {\n                util.target.goToBack();\n            }\n        }\n    }\n\n    goForwardBackwardLayers (args, util) {\n        if (!util.target.isStage) {\n            if (args.FORWARD_BACKWARD === 'forward') {\n                util.target.goForwardLayers(Cast.toNumber(args.NUM));\n            } else {\n                util.target.goBackwardLayers(Cast.toNumber(args.NUM));\n            }\n        }\n    }\n\n    getSize (args, util) {\n        return Math.round(util.target.size);\n    }\n\n    getBackdropNumberName (args) {\n        const stage = this.runtime.getTargetForStage();\n        if (args.NUMBER_NAME === 'number') {\n            return stage.currentCostume + 1;\n        }\n        // Else return name\n        return stage.getCostumes()[stage.currentCostume].name;\n    }\n\n    getCostumeNumberName (args, util) {\n        if (args.NUMBER_NAME === 'number') {\n            return util.target.currentCostume + 1;\n        }\n        // Else return name\n        return util.target.getCostumes()[util.target.currentCostume].name;\n    }\n}\n\nmodule.exports = Scratch3LooksBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_looks.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_motion.js":
/*!***************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_motion.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\nconst MathUtil = __webpack_require__(/*! ../util/math-util */ \"../scratch-vm/src/util/math-util.js\");\nconst Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\n\nclass Scratch3MotionBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            motion_movesteps: this.moveSteps,\n            motion_gotoxy: this.goToXY,\n            motion_goto: this.goTo,\n            motion_turnright: this.turnRight,\n            motion_turnleft: this.turnLeft,\n            motion_pointindirection: this.pointInDirection,\n            motion_pointtowards: this.pointTowards,\n            motion_glidesecstoxy: this.glide,\n            motion_glideto: this.glideTo,\n            motion_ifonedgebounce: this.ifOnEdgeBounce,\n            motion_setrotationstyle: this.setRotationStyle,\n            motion_changexby: this.changeX,\n            motion_setx: this.setX,\n            motion_changeyby: this.changeY,\n            motion_sety: this.setY,\n            motion_xposition: this.getX,\n            motion_yposition: this.getY,\n            motion_direction: this.getDirection,\n            // Legacy no-op blocks:\n            motion_scroll_right: () => {},\n            motion_scroll_up: () => {},\n            motion_align_scene: () => {},\n            motion_xscroll: () => {},\n            motion_yscroll: () => {}\n        };\n    }\n\n    getMonitored () {\n        return {\n            motion_xposition: {\n                isSpriteSpecific: true,\n                getId: targetId => `${targetId}_xposition`\n            },\n            motion_yposition: {\n                isSpriteSpecific: true,\n                getId: targetId => `${targetId}_yposition`\n            },\n            motion_direction: {\n                isSpriteSpecific: true,\n                getId: targetId => `${targetId}_direction`\n            }\n        };\n    }\n\n    moveSteps (args, util) {\n        const steps = Cast.toNumber(args.STEPS);\n        const radians = MathUtil.degToRad(90 - util.target.direction);\n        const dx = steps * Math.cos(radians);\n        const dy = steps * Math.sin(radians);\n        util.target.setXY(util.target.x + dx, util.target.y + dy);\n    }\n\n    goToXY (args, util) {\n        const x = Cast.toNumber(args.X);\n        const y = Cast.toNumber(args.Y);\n        util.target.setXY(x, y);\n    }\n\n    getTargetXY (targetName, util) {\n        let targetX = 0;\n        let targetY = 0;\n        if (targetName === '_mouse_') {\n            targetX = util.ioQuery('mouse', 'getScratchX');\n            targetY = util.ioQuery('mouse', 'getScratchY');\n        } else if (targetName === '_random_') {\n            const stageWidth = this.runtime.constructor.STAGE_WIDTH;\n            const stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n            targetX = Math.round(stageWidth * (Math.random() - 0.5));\n            targetY = Math.round(stageHeight * (Math.random() - 0.5));\n        } else {\n            targetName = Cast.toString(targetName);\n            const goToTarget = this.runtime.getSpriteTargetByName(targetName);\n            if (!goToTarget) return;\n            targetX = goToTarget.x;\n            targetY = goToTarget.y;\n        }\n        return [targetX, targetY];\n    }\n\n    goTo (args, util) {\n        const targetXY = this.getTargetXY(args.TO, util);\n        if (targetXY) {\n            util.target.setXY(targetXY[0], targetXY[1]);\n        }\n    }\n\n    turnRight (args, util) {\n        const degrees = Cast.toNumber(args.DEGREES);\n        util.target.setDirection(util.target.direction + degrees);\n    }\n\n    turnLeft (args, util) {\n        const degrees = Cast.toNumber(args.DEGREES);\n        util.target.setDirection(util.target.direction - degrees);\n    }\n\n    pointInDirection (args, util) {\n        const direction = Cast.toNumber(args.DIRECTION);\n        util.target.setDirection(direction);\n    }\n\n    pointTowards (args, util) {\n        let targetX = 0;\n        let targetY = 0;\n        if (args.TOWARDS === '_mouse_') {\n            targetX = util.ioQuery('mouse', 'getScratchX');\n            targetY = util.ioQuery('mouse', 'getScratchY');\n        } else if (args.TOWARDS === '_random_') {\n            util.target.setDirection(Math.round(Math.random() * 360) - 180);\n            return;\n        } else {\n            args.TOWARDS = Cast.toString(args.TOWARDS);\n            const pointTarget = this.runtime.getSpriteTargetByName(args.TOWARDS);\n            if (!pointTarget) return;\n            targetX = pointTarget.x;\n            targetY = pointTarget.y;\n        }\n\n        const dx = targetX - util.target.x;\n        const dy = targetY - util.target.y;\n        const direction = 90 - MathUtil.radToDeg(Math.atan2(dy, dx));\n        util.target.setDirection(direction);\n    }\n\n    glide (args, util) {\n        if (util.stackFrame.timer) {\n            const timeElapsed = util.stackFrame.timer.timeElapsed();\n            if (timeElapsed < util.stackFrame.duration * 1000) {\n                // In progress: move to intermediate position.\n                const frac = timeElapsed / (util.stackFrame.duration * 1000);\n                const dx = frac * (util.stackFrame.endX - util.stackFrame.startX);\n                const dy = frac * (util.stackFrame.endY - util.stackFrame.startY);\n                util.target.setXY(\n                    util.stackFrame.startX + dx,\n                    util.stackFrame.startY + dy\n                );\n                util.yield();\n            } else {\n                // Finished: move to final position.\n                util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);\n            }\n        } else {\n            // First time: save data for future use.\n            util.stackFrame.timer = new Timer();\n            util.stackFrame.timer.start();\n            util.stackFrame.duration = Cast.toNumber(args.SECS);\n            util.stackFrame.startX = util.target.x;\n            util.stackFrame.startY = util.target.y;\n            util.stackFrame.endX = Cast.toNumber(args.X);\n            util.stackFrame.endY = Cast.toNumber(args.Y);\n            if (util.stackFrame.duration <= 0) {\n                // Duration too short to glide.\n                util.target.setXY(util.stackFrame.endX, util.stackFrame.endY);\n                return;\n            }\n            util.yield();\n        }\n    }\n\n    glideTo (args, util) {\n        const targetXY = this.getTargetXY(args.TO, util);\n        if (targetXY) {\n            this.glide({SECS: args.SECS, X: targetXY[0], Y: targetXY[1]}, util);\n        }\n    }\n\n    ifOnEdgeBounce (args, util) {\n        const bounds = util.target.getBounds();\n        if (!bounds) {\n            return;\n        }\n        // Measure distance to edges.\n        // Values are positive when the sprite is far away,\n        // and clamped to zero when the sprite is beyond.\n        const stageWidth = this.runtime.constructor.STAGE_WIDTH;\n        const stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n        const distLeft = Math.max(0, (stageWidth / 2) + bounds.left);\n        const distTop = Math.max(0, (stageHeight / 2) - bounds.top);\n        const distRight = Math.max(0, (stageWidth / 2) - bounds.right);\n        const distBottom = Math.max(0, (stageHeight / 2) + bounds.bottom);\n        // Find the nearest edge.\n        let nearestEdge = '';\n        let minDist = Infinity;\n        if (distLeft < minDist) {\n            minDist = distLeft;\n            nearestEdge = 'left';\n        }\n        if (distTop < minDist) {\n            minDist = distTop;\n            nearestEdge = 'top';\n        }\n        if (distRight < minDist) {\n            minDist = distRight;\n            nearestEdge = 'right';\n        }\n        if (distBottom < minDist) {\n            minDist = distBottom;\n            nearestEdge = 'bottom';\n        }\n        if (minDist > 0) {\n            return; // Not touching any edge.\n        }\n        // Point away from the nearest edge.\n        const radians = MathUtil.degToRad(90 - util.target.direction);\n        let dx = Math.cos(radians);\n        let dy = -Math.sin(radians);\n        if (nearestEdge === 'left') {\n            dx = Math.max(0.2, Math.abs(dx));\n        } else if (nearestEdge === 'top') {\n            dy = Math.max(0.2, Math.abs(dy));\n        } else if (nearestEdge === 'right') {\n            dx = 0 - Math.max(0.2, Math.abs(dx));\n        } else if (nearestEdge === 'bottom') {\n            dy = 0 - Math.max(0.2, Math.abs(dy));\n        }\n        const newDirection = MathUtil.radToDeg(Math.atan2(dy, dx)) + 90;\n        util.target.setDirection(newDirection);\n        // Keep within the stage.\n        const fencedPosition = util.target.keepInFence(util.target.x, util.target.y);\n        util.target.setXY(fencedPosition[0], fencedPosition[1]);\n    }\n\n    setRotationStyle (args, util) {\n        util.target.setRotationStyle(args.STYLE);\n    }\n\n    changeX (args, util) {\n        const dx = Cast.toNumber(args.DX);\n        util.target.setXY(util.target.x + dx, util.target.y);\n    }\n\n    setX (args, util) {\n        const x = Cast.toNumber(args.X);\n        util.target.setXY(x, util.target.y);\n    }\n\n    changeY (args, util) {\n        const dy = Cast.toNumber(args.DY);\n        util.target.setXY(util.target.x, util.target.y + dy);\n    }\n\n    setY (args, util) {\n        const y = Cast.toNumber(args.Y);\n        util.target.setXY(util.target.x, y);\n    }\n\n    getX (args, util) {\n        return this.limitPrecision(util.target.x);\n    }\n\n    getY (args, util) {\n        return this.limitPrecision(util.target.y);\n    }\n\n    getDirection (args, util) {\n        return util.target.direction;\n    }\n\n    // This corresponds to snapToInteger in Scratch 2\n    limitPrecision (coordinate) {\n        const rounded = Math.round(coordinate);\n        const delta = coordinate - rounded;\n        const limitedCoord = (Math.abs(delta) < 1e-9) ? rounded : coordinate;\n\n        return limitedCoord;\n    }\n}\n\nmodule.exports = Scratch3MotionBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_motion.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_operators.js":
/*!******************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_operators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast.js */ \"../scratch-vm/src/util/cast.js\");\nconst MathUtil = __webpack_require__(/*! ../util/math-util.js */ \"../scratch-vm/src/util/math-util.js\");\n\nclass Scratch3OperatorsBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            operator_add: this.add,\n            operator_subtract: this.subtract,\n            operator_multiply: this.multiply,\n            operator_divide: this.divide,\n            operator_lt: this.lt,\n            operator_equals: this.equals,\n            operator_gt: this.gt,\n            operator_and: this.and,\n            operator_or: this.or,\n            operator_not: this.not,\n            operator_random: this.random,\n            operator_join: this.join,\n            operator_letter_of: this.letterOf,\n            operator_length: this.length,\n            operator_contains: this.contains,\n            operator_mod: this.mod,\n            operator_round: this.round,\n            operator_mathop: this.mathop\n        };\n    }\n\n    add (args) {\n        return Cast.toNumber(args.NUM1) + Cast.toNumber(args.NUM2);\n    }\n\n    subtract (args) {\n        return Cast.toNumber(args.NUM1) - Cast.toNumber(args.NUM2);\n    }\n\n    multiply (args) {\n        return Cast.toNumber(args.NUM1) * Cast.toNumber(args.NUM2);\n    }\n\n    divide (args) {\n        return Cast.toNumber(args.NUM1) / Cast.toNumber(args.NUM2);\n    }\n\n    lt (args) {\n        return Cast.compare(args.OPERAND1, args.OPERAND2) < 0;\n    }\n\n    equals (args) {\n        return Cast.compare(args.OPERAND1, args.OPERAND2) === 0;\n    }\n\n    gt (args) {\n        return Cast.compare(args.OPERAND1, args.OPERAND2) > 0;\n    }\n\n    and (args) {\n        return Cast.toBoolean(args.OPERAND1) && Cast.toBoolean(args.OPERAND2);\n    }\n\n    or (args) {\n        return Cast.toBoolean(args.OPERAND1) || Cast.toBoolean(args.OPERAND2);\n    }\n\n    not (args) {\n        return !Cast.toBoolean(args.OPERAND);\n    }\n\n    random (args) {\n        const nFrom = Cast.toNumber(args.FROM);\n        const nTo = Cast.toNumber(args.TO);\n        const low = nFrom <= nTo ? nFrom : nTo;\n        const high = nFrom <= nTo ? nTo : nFrom;\n        if (low === high) return low;\n        // If both arguments are ints, truncate the result to an int.\n        if (Cast.isInt(args.FROM) && Cast.isInt(args.TO)) {\n            return low + Math.floor(Math.random() * ((high + 1) - low));\n        }\n        return (Math.random() * (high - low)) + low;\n    }\n\n    join (args) {\n        return Cast.toString(args.STRING1) + Cast.toString(args.STRING2);\n    }\n\n    letterOf (args) {\n        const index = Cast.toNumber(args.LETTER) - 1;\n        const str = Cast.toString(args.STRING);\n        // Out of bounds?\n        if (index < 0 || index >= str.length) {\n            return '';\n        }\n        return str.charAt(index);\n    }\n\n    length (args) {\n        return Cast.toString(args.STRING).length;\n    }\n\n    contains (args) {\n        const format = function (string) {\n            return Cast.toString(string).toLowerCase();\n        };\n        return format(args.STRING1).includes(format(args.STRING2));\n    }\n\n    mod (args) {\n        const n = Cast.toNumber(args.NUM1);\n        const modulus = Cast.toNumber(args.NUM2);\n        let result = n % modulus;\n        // Scratch mod uses floored division instead of truncated division.\n        if (result / modulus < 0) result += modulus;\n        return result;\n    }\n\n    round (args) {\n        return Math.round(Cast.toNumber(args.NUM));\n    }\n\n    mathop (args) {\n        const operator = Cast.toString(args.OPERATOR).toLowerCase();\n        const n = Cast.toNumber(args.NUM);\n        switch (operator) {\n        case 'abs': return Math.abs(n);\n        case 'floor': return Math.floor(n);\n        case 'ceiling': return Math.ceil(n);\n        case 'sqrt': return Math.sqrt(n);\n        case 'sin': return parseFloat(Math.sin((Math.PI * n) / 180).toFixed(10));\n        case 'cos': return parseFloat(Math.cos((Math.PI * n) / 180).toFixed(10));\n        case 'tan': return MathUtil.tan(n);\n        case 'asin': return (Math.asin(n) * 180) / Math.PI;\n        case 'acos': return (Math.acos(n) * 180) / Math.PI;\n        case 'atan': return (Math.atan(n) * 180) / Math.PI;\n        case 'ln': return Math.log(n);\n        case 'log': return Math.log(n) / Math.LN10;\n        case 'e ^': return Math.exp(n);\n        case '10 ^': return Math.pow(10, n);\n        }\n        return 0;\n    }\n}\n\nmodule.exports = Scratch3OperatorsBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_operators.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_procedures.js":
/*!*******************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_procedures.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("class Scratch3ProcedureBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            procedures_definition: this.definition,\n            procedures_call: this.call,\n            argument_reporter_string_number: this.argumentReporterStringNumber,\n            argument_reporter_boolean: this.argumentReporterBoolean\n        };\n    }\n\n    definition () {\n        // No-op: execute the blocks.\n    }\n\n    call (args, util) {\n        if (!util.stackFrame.executed) {\n            const procedureCode = args.mutation.proccode;\n            const paramNamesIdsAndDefaults = util.getProcedureParamNamesIdsAndDefaults(procedureCode);\n\n            // If null, procedure could not be found, which can happen if custom\n            // block is dragged between sprites without the definition.\n            // Match Scratch 2.0 behavior and noop.\n            if (paramNamesIdsAndDefaults === null) {\n                return;\n            }\n\n            const [paramNames, paramIds, paramDefaults] = paramNamesIdsAndDefaults;\n\n            // Initialize params for the current stackFrame to {}, even if the procedure does\n            // not take any arguments. This is so that `getParam` down the line does not look\n            // at earlier stack frames for the values of a given parameter (#1729)\n            util.initParams();\n            for (let i = 0; i < paramIds.length; i++) {\n                if (Object.prototype.hasOwnProperty.call(args, paramIds[i])) {\n                    util.pushParam(paramNames[i], args[paramIds[i]]);\n                } else {\n                    util.pushParam(paramNames[i], paramDefaults[i]);\n                }\n            }\n\n            util.stackFrame.executed = true;\n            util.startProcedure(procedureCode);\n        }\n    }\n\n    argumentReporterStringNumber (args, util) {\n        const value = util.getParam(args.VALUE);\n        if (value === null) {\n            // When the parameter is not found in the most recent procedure\n            // call, the default is always 0.\n            return 0;\n        }\n        return value;\n    }\n\n    argumentReporterBoolean (args, util) {\n        const value = util.getParam(args.VALUE);\n        if (value === null) {\n            // When the parameter is not found in the most recent procedure\n            // call, the default is always 0.\n            return 0;\n        }\n        return value;\n    }\n}\n\nmodule.exports = Scratch3ProcedureBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_procedures.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_sensing.js":
/*!****************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_sensing.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\nconst Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\nconst getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ \"../scratch-vm/src/util/get-monitor-id.js\");\n\nclass Scratch3SensingBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n\n        /**\n         * The \"answer\" block value.\n         * @type {string}\n         */\n        this._answer = '';\n\n        /**\n         * The timer utility.\n         * @type {Timer}\n         */\n        this._timer = new Timer();\n\n        /**\n         * The stored microphone loudness measurement.\n         * @type {number}\n         */\n        this._cachedLoudness = -1;\n\n        /**\n         * The time of the most recent microphone loudness measurement.\n         * @type {number}\n         */\n        this._cachedLoudnessTimestamp = 0;\n\n        /**\n         * The list of queued questions and respective `resolve` callbacks.\n         * @type {!Array}\n         */\n        this._questionList = [];\n\n        this.runtime.on('ANSWER', this._onAnswer.bind(this));\n        this.runtime.on('PROJECT_START', this._resetAnswer.bind(this));\n        this.runtime.on('PROJECT_STOP_ALL', this._clearAllQuestions.bind(this));\n        this.runtime.on('STOP_FOR_TARGET', this._clearTargetQuestions.bind(this));\n        this.runtime.on('RUNTIME_DISPOSED', this._resetAnswer.bind(this));\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            sensing_touchingobject: this.touchingObject,\n            sensing_touchingcolor: this.touchingColor,\n            sensing_coloristouchingcolor: this.colorTouchingColor,\n            sensing_distanceto: this.distanceTo,\n            sensing_timer: this.getTimer,\n            sensing_resettimer: this.resetTimer,\n            sensing_of: this.getAttributeOf,\n            sensing_mousex: this.getMouseX,\n            sensing_mousey: this.getMouseY,\n            sensing_setdragmode: this.setDragMode,\n            sensing_mousedown: this.getMouseDown,\n            sensing_keypressed: this.getKeyPressed,\n            sensing_current: this.current,\n            sensing_dayssince2000: this.daysSince2000,\n            sensing_loudness: this.getLoudness,\n            sensing_loud: this.isLoud,\n            sensing_askandwait: this.askAndWait,\n            sensing_answer: this.getAnswer,\n            sensing_username: this.getUsername,\n            sensing_userid: () => {} // legacy no-op block\n        };\n    }\n\n    getMonitored () {\n        return {\n            sensing_answer: {\n                getId: () => 'answer'\n            },\n            sensing_loudness: {\n                getId: () => 'loudness'\n            },\n            sensing_timer: {\n                getId: () => 'timer'\n            },\n            sensing_current: {\n                // This is different from the default toolbox xml id in order to support\n                // importing multiple monitors from the same opcode from sb2 files,\n                // something that is not currently supported in scratch 3.\n                getId: (_, fields) => getMonitorIdForBlockWithArgs('current', fields) // _${param}`\n            }\n        };\n    }\n\n    _onAnswer (answer) {\n        this._answer = answer;\n        const questionObj = this._questionList.shift();\n        if (questionObj) {\n            const [_question, resolve, target, wasVisible, wasStage] = questionObj;\n            // If the target was visible when asked, hide the say bubble unless the target was the stage.\n            if (wasVisible && !wasStage) {\n                this.runtime.emit('SAY', target, 'say', '');\n            }\n            resolve();\n            this._askNextQuestion();\n        }\n    }\n\n    _resetAnswer () {\n        this._answer = '';\n    }\n\n    _enqueueAsk (question, resolve, target, wasVisible, wasStage) {\n        this._questionList.push([question, resolve, target, wasVisible, wasStage]);\n    }\n\n    _askNextQuestion () {\n        if (this._questionList.length > 0) {\n            const [question, _resolve, target, wasVisible, wasStage] = this._questionList[0];\n            // If the target is visible, emit a blank question and use the\n            // say event to trigger a bubble unless the target was the stage.\n            if (wasVisible && !wasStage) {\n                this.runtime.emit('SAY', target, 'say', question);\n                this.runtime.emit('QUESTION', '');\n            } else {\n                this.runtime.emit('QUESTION', question);\n            }\n        }\n    }\n\n    _clearAllQuestions () {\n        this._questionList = [];\n        this.runtime.emit('QUESTION', null);\n    }\n\n    _clearTargetQuestions (stopTarget) {\n        const currentlyAsking = this._questionList.length > 0 && this._questionList[0][2] === stopTarget;\n        this._questionList = this._questionList.filter(question => (\n            question[2] !== stopTarget\n        ));\n\n        if (currentlyAsking) {\n            this.runtime.emit('SAY', stopTarget, 'say', '');\n            if (this._questionList.length > 0) {\n                this._askNextQuestion();\n            } else {\n                this.runtime.emit('QUESTION', null);\n            }\n        }\n    }\n\n    askAndWait (args, util) {\n        const _target = util.target;\n        return new Promise(resolve => {\n            const isQuestionAsked = this._questionList.length > 0;\n            this._enqueueAsk(String(args.QUESTION), resolve, _target, _target.visible, _target.isStage);\n            if (!isQuestionAsked) {\n                this._askNextQuestion();\n            }\n        });\n    }\n\n    getAnswer () {\n        return this._answer;\n    }\n\n    touchingObject (args, util) {\n        return util.target.isTouchingObject(args.TOUCHINGOBJECTMENU);\n    }\n\n    touchingColor (args, util) {\n        const color = Cast.toRgbColorList(args.COLOR);\n        return util.target.isTouchingColor(color);\n    }\n\n    colorTouchingColor (args, util) {\n        const maskColor = Cast.toRgbColorList(args.COLOR);\n        const targetColor = Cast.toRgbColorList(args.COLOR2);\n        return util.target.colorIsTouchingColor(targetColor, maskColor);\n    }\n\n    distanceTo (args, util) {\n        if (util.target.isStage) return 10000;\n\n        let targetX = 0;\n        let targetY = 0;\n        if (args.DISTANCETOMENU === '_mouse_') {\n            targetX = util.ioQuery('mouse', 'getScratchX');\n            targetY = util.ioQuery('mouse', 'getScratchY');\n        } else {\n            args.DISTANCETOMENU = Cast.toString(args.DISTANCETOMENU);\n            const distTarget = this.runtime.getSpriteTargetByName(\n                args.DISTANCETOMENU\n            );\n            if (!distTarget) return 10000;\n            targetX = distTarget.x;\n            targetY = distTarget.y;\n        }\n\n        const dx = util.target.x - targetX;\n        const dy = util.target.y - targetY;\n        return Math.sqrt((dx * dx) + (dy * dy));\n    }\n\n    setDragMode (args, util) {\n        util.target.setDraggable(args.DRAG_MODE === 'draggable');\n    }\n\n    getTimer (args, util) {\n        return util.ioQuery('clock', 'projectTimer');\n    }\n\n    resetTimer (args, util) {\n        util.ioQuery('clock', 'resetProjectTimer');\n    }\n\n    getMouseX (args, util) {\n        return util.ioQuery('mouse', 'getScratchX');\n    }\n\n    getMouseY (args, util) {\n        return util.ioQuery('mouse', 'getScratchY');\n    }\n\n    getMouseDown (args, util) {\n        return util.ioQuery('mouse', 'getIsDown');\n    }\n\n    current (args) {\n        const menuOption = Cast.toString(args.CURRENTMENU).toLowerCase();\n        const date = new Date();\n        switch (menuOption) {\n        case 'year': return date.getFullYear();\n        case 'month': return date.getMonth() + 1; // getMonth is zero-based\n        case 'date': return date.getDate();\n        case 'dayofweek': return date.getDay() + 1; // getDay is zero-based, Sun=0\n        case 'hour': return date.getHours();\n        case 'minute': return date.getMinutes();\n        case 'second': return date.getSeconds();\n        }\n        return 0;\n    }\n\n    getKeyPressed (args, util) {\n        return util.ioQuery('keyboard', 'getKeyIsDown', [args.KEY_OPTION]);\n    }\n\n    daysSince2000 () {\n        const msPerDay = 24 * 60 * 60 * 1000;\n        const start = new Date(2000, 0, 1); // Months are 0-indexed.\n        const today = new Date();\n        const dstAdjust = today.getTimezoneOffset() - start.getTimezoneOffset();\n        let mSecsSinceStart = today.valueOf() - start.valueOf();\n        mSecsSinceStart += ((today.getTimezoneOffset() - dstAdjust) * 60 * 1000);\n        return mSecsSinceStart / msPerDay;\n    }\n\n    getLoudness () {\n        if (typeof this.runtime.audioEngine === 'undefined') return -1;\n        if (this.runtime.currentStepTime === null) return -1;\n\n        // Only measure loudness once per step\n        const timeSinceLoudness = this._timer.time() - this._cachedLoudnessTimestamp;\n        if (timeSinceLoudness < this.runtime.currentStepTime) {\n            return this._cachedLoudness;\n        }\n\n        this._cachedLoudnessTimestamp = this._timer.time();\n        this._cachedLoudness = this.runtime.audioEngine.getLoudness();\n        return this._cachedLoudness;\n    }\n\n    isLoud () {\n        return this.getLoudness() > 10;\n    }\n\n    getAttributeOf (args) {\n        let attrTarget;\n\n        if (args.OBJECT === '_stage_') {\n            attrTarget = this.runtime.getTargetForStage();\n        } else {\n            args.OBJECT = Cast.toString(args.OBJECT);\n            attrTarget = this.runtime.getSpriteTargetByName(args.OBJECT);\n        }\n\n        // attrTarget can be undefined if the target does not exist\n        // (e.g. single sprite uploaded from larger project referencing\n        // another sprite that wasn't uploaded)\n        if (!attrTarget) return 0;\n\n        // Generic attributes\n        if (attrTarget.isStage) {\n            switch (args.PROPERTY) {\n            // Scratch 1.4 support\n            case 'background #': return attrTarget.currentCostume + 1;\n\n            case 'backdrop #': return attrTarget.currentCostume + 1;\n            case 'backdrop name':\n                return attrTarget.getCostumes()[attrTarget.currentCostume].name;\n            case 'volume': return attrTarget.volume;\n            }\n        } else {\n            switch (args.PROPERTY) {\n            case 'x position': return attrTarget.x;\n            case 'y position': return attrTarget.y;\n            case 'direction': return attrTarget.direction;\n            case 'costume #': return attrTarget.currentCostume + 1;\n            case 'costume name':\n                return attrTarget.getCostumes()[attrTarget.currentCostume].name;\n            case 'size': return attrTarget.size;\n            case 'volume': return attrTarget.volume;\n            }\n        }\n\n        // Target variables.\n        const varName = args.PROPERTY;\n        const variable = attrTarget.lookupVariableByNameAndType(varName, '', true);\n        if (variable) {\n            return variable.value;\n        }\n\n        // Otherwise, 0\n        return 0;\n    }\n\n    getUsername (args, util) {\n        return util.ioQuery('userData', 'getUsername');\n    }\n}\n\nmodule.exports = Scratch3SensingBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_sensing.js?");

/***/ }),

/***/ "../scratch-vm/src/blocks/scratch3_sound.js":
/*!**************************************************!*\
  !*** ../scratch-vm/src/blocks/scratch3_sound.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MathUtil = __webpack_require__(/*! ../util/math-util */ \"../scratch-vm/src/util/math-util.js\");\nconst Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\nconst Clone = __webpack_require__(/*! ../util/clone */ \"../scratch-vm/src/util/clone.js\");\n\n/**\n * Occluded boolean value to make its use more understandable.\n * @const {boolean}\n */\nconst STORE_WAITING = true;\n\nclass Scratch3SoundBlocks {\n    constructor (runtime) {\n        /**\n         * The runtime instantiating this block package.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n\n        this.waitingSounds = {};\n\n        // Clear sound effects on green flag and stop button events.\n        this.stopAllSounds = this.stopAllSounds.bind(this);\n        this._stopWaitingSoundsForTarget = this._stopWaitingSoundsForTarget.bind(this);\n        this._clearEffectsForAllTargets = this._clearEffectsForAllTargets.bind(this);\n        if (this.runtime) {\n            this.runtime.on('PROJECT_STOP_ALL', this.stopAllSounds);\n            this.runtime.on('PROJECT_STOP_ALL', this._clearEffectsForAllTargets);\n            this.runtime.on('STOP_FOR_TARGET', this._stopWaitingSoundsForTarget);\n            this.runtime.on('PROJECT_START', this._clearEffectsForAllTargets);\n        }\n\n        this._onTargetCreated = this._onTargetCreated.bind(this);\n        if (this.runtime) {\n            runtime.on('targetWasCreated', this._onTargetCreated);\n        }\n    }\n\n    /**\n     * The key to load & store a target's sound-related state.\n     * @type {string}\n     */\n    static get STATE_KEY () {\n        return 'Scratch.sound';\n    }\n\n    /**\n     * The default sound-related state, to be used when a target has no existing sound state.\n     * @type {SoundState}\n     */\n    static get DEFAULT_SOUND_STATE () {\n        return {\n            effects: {\n                pitch: 0,\n                pan: 0\n            }\n        };\n    }\n\n    /**\n     * The minimum and maximum MIDI note numbers, for clamping the input to play note.\n     * @type {{min: number, max: number}}\n     */\n    static get MIDI_NOTE_RANGE () {\n        return {min: 36, max: 96}; // C2 to C7\n    }\n\n    /**\n     * The minimum and maximum beat values, for clamping the duration of play note, play drum and rest.\n     * 100 beats at the default tempo of 60bpm is 100 seconds.\n     * @type {{min: number, max: number}}\n     */\n    static get BEAT_RANGE () {\n        return {min: 0, max: 100};\n    }\n\n    /** The minimum and maximum tempo values, in bpm.\n     * @type {{min: number, max: number}}\n     */\n    static get TEMPO_RANGE () {\n        return {min: 20, max: 500};\n    }\n\n    /** The minimum and maximum values for each sound effect.\n     * @type {{effect:{min: number, max: number}}}\n     */\n    static get EFFECT_RANGE () {\n        return {\n            pitch: {min: -360, max: 360}, // -3 to 3 octaves\n            pan: {min: -100, max: 100} // 100% left to 100% right\n        };\n    }\n\n    /**\n     * @param {Target} target - collect sound state for this target.\n     * @returns {SoundState} the mutable sound state associated with that target. This will be created if necessary.\n     * @private\n     */\n    _getSoundState (target) {\n        let soundState = target.getCustomState(Scratch3SoundBlocks.STATE_KEY);\n        if (!soundState) {\n            soundState = Clone.simple(Scratch3SoundBlocks.DEFAULT_SOUND_STATE);\n            target.setCustomState(Scratch3SoundBlocks.STATE_KEY, soundState);\n            target.soundEffects = soundState.effects;\n        }\n        return soundState;\n    }\n\n    /**\n     * When a Target is cloned, clone the sound state.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @listens Runtime#event:targetWasCreated\n     * @private\n     */\n    _onTargetCreated (newTarget, sourceTarget) {\n        if (sourceTarget) {\n            const soundState = sourceTarget.getCustomState(Scratch3SoundBlocks.STATE_KEY);\n            if (soundState && newTarget) {\n                newTarget.setCustomState(Scratch3SoundBlocks.STATE_KEY, Clone.simple(soundState));\n                this._syncEffectsForTarget(newTarget);\n            }\n        }\n    }\n\n    /**\n     * Retrieve the block primitives implemented by this package.\n     * @return {object.<string, Function>} Mapping of opcode to Function.\n     */\n    getPrimitives () {\n        return {\n            sound_play: this.playSound,\n            sound_playuntildone: this.playSoundAndWait,\n            sound_stopallsounds: this.stopAllSounds,\n            sound_seteffectto: this.setEffect,\n            sound_changeeffectby: this.changeEffect,\n            sound_cleareffects: this.clearEffects,\n            sound_sounds_menu: this.soundsMenu,\n            sound_beats_menu: this.beatsMenu,\n            sound_effects_menu: this.effectsMenu,\n            sound_setvolumeto: this.setVolume,\n            sound_changevolumeby: this.changeVolume,\n            sound_volume: this.getVolume\n        };\n    }\n\n    getMonitored () {\n        return {\n            sound_volume: {\n                isSpriteSpecific: true,\n                getId: targetId => `${targetId}_volume`\n            }\n        };\n    }\n\n    playSound (args, util) {\n        // Don't return the promise, it's the only difference for AndWait\n        this._playSound(args, util);\n    }\n\n    playSoundAndWait (args, util) {\n        return this._playSound(args, util, STORE_WAITING);\n    }\n\n    _playSound (args, util, storeWaiting) {\n        const index = this._getSoundIndex(args.SOUND_MENU, util);\n        if (index >= 0) {\n            const {target} = util;\n            const {sprite} = target;\n            const {soundId} = sprite.sounds[index];\n            if (sprite.soundBank) {\n                if (storeWaiting === STORE_WAITING) {\n                    this._addWaitingSound(target.id, soundId);\n                } else {\n                    this._removeWaitingSound(target.id, soundId);\n                }\n                return sprite.soundBank.playSound(target, soundId);\n            }\n        }\n    }\n\n    _addWaitingSound (targetId, soundId) {\n        if (!this.waitingSounds[targetId]) {\n            this.waitingSounds[targetId] = new Set();\n        }\n        this.waitingSounds[targetId].add(soundId);\n    }\n\n    _removeWaitingSound (targetId, soundId) {\n        if (!this.waitingSounds[targetId]) {\n            return;\n        }\n        this.waitingSounds[targetId].delete(soundId);\n    }\n\n    _getSoundIndex (soundName, util) {\n        // if the sprite has no sounds, return -1\n        const len = util.target.sprite.sounds.length;\n        if (len === 0) {\n            return -1;\n        }\n\n        // look up by name first\n        const index = this.getSoundIndexByName(soundName, util);\n        if (index !== -1) {\n            return index;\n        }\n\n        // then try using the sound name as a 1-indexed index\n        const oneIndexedIndex = parseInt(soundName, 10);\n        if (!isNaN(oneIndexedIndex)) {\n            return MathUtil.wrapClamp(oneIndexedIndex - 1, 0, len - 1);\n        }\n\n        // could not be found as a name or converted to index, return -1\n        return -1;\n    }\n\n    getSoundIndexByName (soundName, util) {\n        const sounds = util.target.sprite.sounds;\n        for (let i = 0; i < sounds.length; i++) {\n            if (sounds[i].name === soundName) {\n                return i;\n            }\n        }\n        // if there is no sound by that name, return -1\n        return -1;\n    }\n\n    stopAllSounds () {\n        if (this.runtime.targets === null) return;\n        const allTargets = this.runtime.targets;\n        for (let i = 0; i < allTargets.length; i++) {\n            this._stopAllSoundsForTarget(allTargets[i]);\n        }\n    }\n\n    _stopAllSoundsForTarget (target) {\n        if (target.sprite.soundBank) {\n            target.sprite.soundBank.stopAllSounds(target);\n            if (this.waitingSounds[target.id]) {\n                this.waitingSounds[target.id].clear();\n            }\n        }\n    }\n\n    _stopWaitingSoundsForTarget (target) {\n        if (target.sprite.soundBank) {\n            if (this.waitingSounds[target.id]) {\n                for (const soundId of this.waitingSounds[target.id].values()) {\n                    target.sprite.soundBank.stop(target, soundId);\n                }\n                this.waitingSounds[target.id].clear();\n            }\n        }\n    }\n\n    setEffect (args, util) {\n        return this._updateEffect(args, util, false);\n    }\n\n    changeEffect (args, util) {\n        return this._updateEffect(args, util, true);\n    }\n\n    _updateEffect (args, util, change) {\n        const effect = Cast.toString(args.EFFECT).toLowerCase();\n        const value = Cast.toNumber(args.VALUE);\n\n        const soundState = this._getSoundState(util.target);\n        if (!Object.prototype.hasOwnProperty.call(soundState.effects, effect)) return;\n\n        if (change) {\n            soundState.effects[effect] += value;\n        } else {\n            soundState.effects[effect] = value;\n        }\n\n        const {min, max} = Scratch3SoundBlocks.EFFECT_RANGE[effect];\n        soundState.effects[effect] = MathUtil.clamp(soundState.effects[effect], min, max);\n\n        this._syncEffectsForTarget(util.target);\n        // Yield until the next tick.\n        return Promise.resolve();\n    }\n\n    _syncEffectsForTarget (target) {\n        if (!target || !target.sprite.soundBank) return;\n        target.soundEffects = this._getSoundState(target).effects;\n\n        target.sprite.soundBank.setEffects(target);\n    }\n\n    clearEffects (args, util) {\n        this._clearEffectsForTarget(util.target);\n    }\n\n    _clearEffectsForTarget (target) {\n        const soundState = this._getSoundState(target);\n        for (const effect in soundState.effects) {\n            if (!Object.prototype.hasOwnProperty.call(soundState.effects, effect)) continue;\n            soundState.effects[effect] = 0;\n        }\n        this._syncEffectsForTarget(target);\n    }\n\n    _clearEffectsForAllTargets () {\n        if (this.runtime.targets === null) return;\n        const allTargets = this.runtime.targets;\n        for (let i = 0; i < allTargets.length; i++) {\n            this._clearEffectsForTarget(allTargets[i]);\n        }\n    }\n\n    setVolume (args, util) {\n        const volume = Cast.toNumber(args.VOLUME);\n        return this._updateVolume(volume, util);\n    }\n\n    changeVolume (args, util) {\n        const volume = Cast.toNumber(args.VOLUME) + util.target.volume;\n        return this._updateVolume(volume, util);\n    }\n\n    _updateVolume (volume, util) {\n        volume = MathUtil.clamp(volume, 0, 100);\n        util.target.volume = volume;\n        this._syncEffectsForTarget(util.target);\n\n        // Yield until the next tick.\n        return Promise.resolve();\n    }\n\n    getVolume (args, util) {\n        return util.target.volume;\n    }\n\n    soundsMenu (args) {\n        return args.SOUND_MENU;\n    }\n\n    beatsMenu (args) {\n        return args.BEATS;\n    }\n\n    effectsMenu (args) {\n        return args.EFFECT;\n    }\n}\n\nmodule.exports = Scratch3SoundBlocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/blocks/scratch3_sound.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/adapter.js":
/*!*******************************************!*\
  !*** ../scratch-vm/src/engine/adapter.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ \"../scratch-vm/src/engine/mutation-adapter.js\");\nconst html = __webpack_require__(/*! htmlparser2 */ \"../scratch-vm/node_modules/htmlparser2/lib/index.js\");\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\n\n/**\n * Convert and an individual block DOM to the representation tree.\n * Based on Blockly's `domToBlockHeadless_`.\n * @param {Element} blockDOM DOM tree for an individual block.\n * @param {object} blocks Collection of blocks to add to.\n * @param {boolean} isTopBlock Whether blocks at this level are \"top blocks.\"\n * @param {?string} parent Parent block ID.\n * @return {undefined}\n */\nconst domToBlock = function (blockDOM, blocks, isTopBlock, parent) {\n    if (!blockDOM.attribs.id) {\n        blockDOM.attribs.id = uid();\n    }\n\n    // Block skeleton.\n    const block = {\n        id: blockDOM.attribs.id, // Block ID\n        opcode: blockDOM.attribs.type, // For execution, \"event_whengreenflag\".\n        inputs: {}, // Inputs to this block and the blocks they point to.\n        fields: {}, // Fields on this block and their values.\n        next: null, // Next block in the stack, if one exists.\n        topLevel: isTopBlock, // If this block starts a stack.\n        parent: parent, // Parent block ID, if available.\n        shadow: blockDOM.name === 'shadow', // If this represents a shadow/slot.\n        x: blockDOM.attribs.x, // X position of script, if top-level.\n        y: blockDOM.attribs.y // Y position of script, if top-level.\n    };\n\n    // Add the block to the representation tree.\n    blocks[block.id] = block;\n\n    // Process XML children and find enclosed blocks, fields, etc.\n    for (let i = 0; i < blockDOM.children.length; i++) {\n        const xmlChild = blockDOM.children[i];\n        // Enclosed blocks and shadows\n        let childBlockNode = null;\n        let childShadowNode = null;\n        for (let j = 0; j < xmlChild.children.length; j++) {\n            const grandChildNode = xmlChild.children[j];\n            if (!grandChildNode.name) {\n                // Non-XML tag node.\n                continue;\n            }\n            const grandChildNodeName = grandChildNode.name.toLowerCase();\n            if (grandChildNodeName === 'block') {\n                childBlockNode = grandChildNode;\n            } else if (grandChildNodeName === 'shadow') {\n                childShadowNode = grandChildNode;\n            }\n        }\n\n        // Use shadow block only if there's no real block node.\n        if (!childBlockNode && childShadowNode) {\n            childBlockNode = childShadowNode;\n        }\n\n        // Not all Blockly-type blocks are handled here,\n        // as we won't be using all of them for Scratch.\n        switch (xmlChild.name.toLowerCase()) {\n        case 'field':\n        {\n            // Add the field to this block.\n            const fieldName = xmlChild.attribs.name;\n            // Add id in case it is a variable field\n            const fieldId = xmlChild.attribs.id;\n            let fieldData = '';\n            if (xmlChild.children.length > 0 && xmlChild.children[0].data) {\n                fieldData = xmlChild.children[0].data;\n            } else {\n                // If the child of the field with a data property\n                // doesn't exist, set the data to an empty string.\n                fieldData = '';\n            }\n            block.fields[fieldName] = {\n                name: fieldName,\n                id: fieldId,\n                value: fieldData\n            };\n            const fieldVarType = xmlChild.attribs.variabletype;\n            if (typeof fieldVarType === 'string') {\n                block.fields[fieldName].variableType = fieldVarType;\n            }\n            break;\n        }\n        case 'comment':\n        {\n            block.comment = xmlChild.attribs.id;\n            break;\n        }\n        case 'value':\n        case 'statement':\n        {\n            // Recursively generate block structure for input block.\n            domToBlock(childBlockNode, blocks, false, block.id);\n            if (childShadowNode && childBlockNode !== childShadowNode) {\n                // Also generate the shadow block.\n                domToBlock(childShadowNode, blocks, false, block.id);\n            }\n            // Link this block's input to the child block.\n            const inputName = xmlChild.attribs.name;\n            block.inputs[inputName] = {\n                name: inputName,\n                block: childBlockNode.attribs.id,\n                shadow: childShadowNode ? childShadowNode.attribs.id : null\n            };\n            break;\n        }\n        case 'next':\n        {\n            if (!childBlockNode || !childBlockNode.attribs) {\n                // Invalid child block.\n                continue;\n            }\n            // Recursively generate block structure for next block.\n            domToBlock(childBlockNode, blocks, false, block.id);\n            // Link next block to this block.\n            block.next = childBlockNode.attribs.id;\n            break;\n        }\n        case 'mutation':\n        {\n            block.mutation = mutationAdapter(xmlChild);\n            break;\n        }\n        }\n    }\n};\n\n/**\n * Convert outer blocks DOM from a Blockly CREATE event\n * to a usable form for the Scratch runtime.\n * This structure is based on Blockly xml.js:`domToWorkspace` and `domToBlock`.\n * @param {Element} blocksDOM DOM tree for this event.\n * @return {Array.<object>} Usable list of blocks from this CREATE event.\n */\nconst domToBlocks = function (blocksDOM) {\n    // At this level, there could be multiple blocks adjacent in the DOM tree.\n    const blocks = {};\n    for (let i = 0; i < blocksDOM.length; i++) {\n        const block = blocksDOM[i];\n        if (!block.name || !block.attribs) {\n            continue;\n        }\n        const tagName = block.name.toLowerCase();\n        if (tagName === 'block' || tagName === 'shadow') {\n            domToBlock(block, blocks, true, null);\n        }\n    }\n    // Flatten blocks object into a list.\n    const blocksList = [];\n    for (const b in blocks) {\n        if (!Object.prototype.hasOwnProperty.call(blocks, b)) continue;\n        blocksList.push(blocks[b]);\n    }\n    return blocksList;\n};\n\n/**\n * Adapter between block creation events and block representation which can be\n * used by the Scratch runtime.\n * @param {object} e `Blockly.events.create` or `Blockly.events.endDrag`\n * @return {Array.<object>} List of blocks from this CREATE event.\n */\nconst adapter = function (e) {\n    // Validate input\n    if (typeof e !== 'object') return;\n    if (typeof e.xml !== 'object') return;\n\n    return domToBlocks(html.parseDOM(e.xml.outerHTML, {decodeEntities: true}));\n};\n\nmodule.exports = adapter;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/adapter.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/block-utility.js":
/*!*************************************************!*\
  !*** ../scratch-vm/src/engine/block-utility.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Thread = __webpack_require__(/*! ./thread */ \"../scratch-vm/src/engine/thread.js\");\nconst Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\n\n/**\n * @fileoverview\n * Interface provided to block primitive functions for interacting with the\n * runtime, thread, target, and convenient methods.\n */\n\nclass BlockUtility {\n    constructor (sequencer = null, thread = null) {\n        /**\n         * A sequencer block primitives use to branch or start procedures with\n         * @type {?Sequencer}\n         */\n        this.sequencer = sequencer;\n\n        /**\n         * The block primitives thread with the block's target, stackFrame and\n         * modifiable status.\n         * @type {?Thread}\n         */\n        this.thread = thread;\n\n        this._nowObj = {\n            now: () => this.sequencer.runtime.currentMSecs\n        };\n    }\n\n    /**\n     * The target the primitive is working on.\n     * @type {Target}\n     */\n    get target () {\n        return this.thread.target;\n    }\n\n    /**\n     * The runtime the block primitive is running in.\n     * @type {Runtime}\n     */\n    get runtime () {\n        return this.sequencer.runtime;\n    }\n\n    /**\n     * Use the runtime's currentMSecs value as a timestamp value for now\n     * This is useful in some cases where we need compatibility with Scratch 2\n     * @type {function}\n     */\n    get nowObj () {\n        if (this.runtime) {\n            return this._nowObj;\n        }\n        return null;\n    }\n\n    /**\n     * The stack frame used by loop and other blocks to track internal state.\n     * @type {object}\n     */\n    get stackFrame () {\n        const frame = this.thread.peekStackFrame();\n        if (frame.executionContext === null) {\n            frame.executionContext = {};\n        }\n        return frame.executionContext;\n    }\n\n    /**\n     * Check the stack timer and return a boolean based on whether it has finished or not.\n     * @return {boolean} - true if the stack timer has finished.\n     */\n    stackTimerFinished () {\n        const timeElapsed = this.stackFrame.timer.timeElapsed();\n        if (timeElapsed < this.stackFrame.duration) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Check if the stack timer needs initialization.\n     * @return {boolean} - true if the stack timer needs to be initialized.\n     */\n    stackTimerNeedsInit () {\n        return !this.stackFrame.timer;\n    }\n\n    /**\n     * Create and start a stack timer\n     * @param {number} duration - a duration in milliseconds to set the timer for.\n     */\n    startStackTimer (duration) {\n        if (this.nowObj) {\n            this.stackFrame.timer = new Timer(this.nowObj);\n        } else {\n            this.stackFrame.timer = new Timer();\n        }\n        this.stackFrame.timer.start();\n        this.stackFrame.duration = duration;\n    }\n\n    /**\n     * Set the thread to yield.\n     */\n    yield () {\n        this.thread.status = Thread.STATUS_YIELD;\n    }\n\n    /**\n     * Set the thread to yield until the next tick of the runtime.\n     */\n    yieldTick () {\n        this.thread.status = Thread.STATUS_YIELD_TICK;\n    }\n\n    /**\n     * Start a branch in the current block.\n     * @param {number} branchNum Which branch to step to (i.e., 1, 2).\n     * @param {boolean} isLoop Whether this block is a loop.\n     */\n    startBranch (branchNum, isLoop) {\n        this.sequencer.stepToBranch(this.thread, branchNum, isLoop);\n    }\n\n    /**\n     * Stop all threads.\n     */\n    stopAll () {\n        this.sequencer.runtime.stopAll();\n    }\n\n    /**\n     * Stop threads other on this target other than the thread holding the\n     * executed block.\n     */\n    stopOtherTargetThreads () {\n        this.sequencer.runtime.stopForTarget(this.thread.target, this.thread);\n    }\n\n    /**\n     * Stop this thread.\n     */\n    stopThisScript () {\n        this.thread.stopThisScript();\n    }\n\n    /**\n     * Start a specified procedure on this thread.\n     * @param {string} procedureCode Procedure code for procedure to start.\n     */\n    startProcedure (procedureCode) {\n        this.sequencer.stepToProcedure(this.thread, procedureCode);\n    }\n\n    /**\n     * Get names and ids of parameters for the given procedure.\n     * @param {string} procedureCode Procedure code for procedure to query.\n     * @return {Array.<string>} List of param names for a procedure.\n     */\n    getProcedureParamNamesAndIds (procedureCode) {\n        return this.thread.target.blocks.getProcedureParamNamesAndIds(procedureCode);\n    }\n\n    /**\n     * Get names, ids, and defaults of parameters for the given procedure.\n     * @param {string} procedureCode Procedure code for procedure to query.\n     * @return {Array.<string>} List of param names for a procedure.\n     */\n    getProcedureParamNamesIdsAndDefaults (procedureCode) {\n        return this.thread.target.blocks.getProcedureParamNamesIdsAndDefaults(procedureCode);\n    }\n\n    /**\n     * Initialize procedure parameters in the thread before pushing parameters.\n     */\n    initParams () {\n        this.thread.initParams();\n    }\n\n    /**\n     * Store a procedure parameter value by its name.\n     * @param {string} paramName The procedure's parameter name.\n     * @param {*} paramValue The procedure's parameter value.\n     */\n    pushParam (paramName, paramValue) {\n        this.thread.pushParam(paramName, paramValue);\n    }\n\n    /**\n     * Retrieve the stored parameter value for a given parameter name.\n     * @param {string} paramName The procedure's parameter name.\n     * @return {*} The parameter's current stored value.\n     */\n    getParam (paramName) {\n        return this.thread.getParam(paramName);\n    }\n\n    /**\n     * Start all relevant hats.\n     * @param {!string} requestedHat Opcode of hats to start.\n     * @param {object=} optMatchFields Optionally, fields to match on the hat.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     * @return {Array.<Thread>} List of threads started by this function.\n     */\n    startHats (requestedHat, optMatchFields, optTarget) {\n        // Store thread and sequencer to ensure we can return to the calling block's context.\n        // startHats may execute further blocks and dirty the BlockUtility's execution context\n        // and confuse the calling block when we return to it.\n        const callerThread = this.thread;\n        const callerSequencer = this.sequencer;\n        const result = this.sequencer.runtime.startHats(requestedHat, optMatchFields, optTarget);\n\n        // Restore thread and sequencer to prior values before we return to the calling block.\n        this.thread = callerThread;\n        this.sequencer = callerSequencer;\n\n        return result;\n    }\n\n    /**\n     * Query a named IO device.\n     * @param {string} device The name of like the device, like keyboard.\n     * @param {string} func The name of the device's function to query.\n     * @param {Array.<*>} args Arguments to pass to the device's function.\n     * @return {*} The expected output for the device's function.\n     */\n    ioQuery (device, func, args) {\n        // Find the I/O device and execute the query/function call.\n        if (\n            this.sequencer.runtime.ioDevices[device] &&\n            this.sequencer.runtime.ioDevices[device][func]) {\n            const devObject = this.sequencer.runtime.ioDevices[device];\n            // TODO: verify correct `this` after switching from apply to spread\n            // eslint-disable-next-line prefer-spread\n            return devObject[func].apply(devObject, args);\n        }\n    }\n}\n\nmodule.exports = BlockUtility;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/block-utility.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/blocks-execute-cache.js":
/*!********************************************************!*\
  !*** ../scratch-vm/src/engine/blocks-execute-cache.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @fileoverview\n * Access point for private method shared between blocks.js and execute.js for\n * caching execute information.\n */\n\n/**\n * A private method shared with execute to build an object containing the block\n * information execute needs and that is reset when other cached Blocks info is\n * reset.\n * @param {Blocks} blocks Blocks containing the expected blockId\n * @param {string} blockId blockId for the desired execute cache\n */\nexports.getCached = function () {\n    throw new Error('blocks.js has not initialized BlocksExecuteCache');\n};\n\n// Call after the default throwing getCached is assigned for Blocks to replace.\n__webpack_require__(/*! ./blocks */ \"../scratch-vm/src/engine/blocks.js\");\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/blocks-execute-cache.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/blocks-runtime-cache.js":
/*!********************************************************!*\
  !*** ../scratch-vm/src/engine/blocks-runtime-cache.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * @fileoverview\n * The BlocksRuntimeCache caches data about the top block of scripts so that\n * Runtime can iterate a targeted opcode and iterate the returned set faster.\n * Many top blocks need to match fields as well as opcode, since that matching\n * compares strings in uppercase we can go ahead and uppercase the cached value\n * so we don't need to in the future.\n */\n\n/**\n * A set of cached data about the top block of a script.\n * @param {Blocks} container - Container holding the block and related data\n * @param {string} blockId - Id for whose block data is cached in this instance\n */\nclass RuntimeScriptCache {\n    constructor (container, blockId) {\n        /**\n         * Container with block data for blockId.\n         * @type {Blocks}\n         */\n        this.container = container;\n\n        /**\n         * ID for block this instance caches.\n         * @type {string}\n         */\n        this.blockId = blockId;\n\n        const block = container.getBlock(blockId);\n        const fields = container.getFields(block);\n\n        /**\n         * Formatted fields or fields of input blocks ready for comparison in\n         * runtime.\n         *\n         * This is a clone of parts of the targeted blocks. Changes to these\n         * clones are limited to copies under RuntimeScriptCache and will not\n         * appear in the original blocks in their container. This copy is\n         * modified changing the case of strings to uppercase. These uppercase\n         * values will be compared later by the VM.\n         * @type {object}\n         */\n        this.fieldsOfInputs = Object.assign({}, fields);\n        if (Object.keys(fields).length === 0) {\n            const inputs = container.getInputs(block);\n            for (const input in inputs) {\n                if (!Object.prototype.hasOwnProperty.call(inputs, input)) continue;\n                const id = inputs[input].block;\n                const inputBlock = container.getBlock(id);\n                const inputFields = container.getFields(inputBlock);\n                Object.assign(this.fieldsOfInputs, inputFields);\n            }\n        }\n        for (const key in this.fieldsOfInputs) {\n            const field = this.fieldsOfInputs[key] = Object.assign({}, this.fieldsOfInputs[key]);\n            if (field.value.toUpperCase) {\n                field.value = field.value.toUpperCase();\n            }\n        }\n    }\n}\n\n/**\n * Get an array of scripts from a block container prefiltered to match opcode.\n * @param {Blocks} container - Container of blocks\n * @param {string} opcode - Opcode to filter top blocks by\n */\nexports.getScripts = function () {\n    throw new Error('blocks.js has not initialized BlocksRuntimeCache');\n};\n\n/**\n * Exposed RuntimeScriptCache class used by integration in blocks.js.\n * @private\n */\nexports._RuntimeScriptCache = RuntimeScriptCache;\n\n__webpack_require__(/*! ./blocks */ \"../scratch-vm/src/engine/blocks.js\");\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/blocks-runtime-cache.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/blocks.js":
/*!******************************************!*\
  !*** ../scratch-vm/src/engine/blocks.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const adapter = __webpack_require__(/*! ./adapter */ \"../scratch-vm/src/engine/adapter.js\");\nconst mutationAdapter = __webpack_require__(/*! ./mutation-adapter */ \"../scratch-vm/src/engine/mutation-adapter.js\");\nconst xmlEscape = __webpack_require__(/*! ../util/xml-escape */ \"../scratch-vm/src/util/xml-escape.js\");\nconst MonitorRecord = __webpack_require__(/*! ./monitor-record */ \"../scratch-vm/src/engine/monitor-record.js\");\nconst Clone = __webpack_require__(/*! ../util/clone */ \"../scratch-vm/src/util/clone.js\");\nconst {Map} = __webpack_require__(/*! immutable */ \"../scratch-vm/node_modules/immutable/dist/immutable.js\");\nconst BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ \"../scratch-vm/src/engine/blocks-execute-cache.js\");\nconst BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ \"../scratch-vm/src/engine/blocks-runtime-cache.js\");\nconst log = __webpack_require__(/*! ../util/log */ \"../scratch-vm/src/util/log.js\");\nconst Variable = __webpack_require__(/*! ./variable */ \"../scratch-vm/src/engine/variable.js\");\nconst getMonitorIdForBlockWithArgs = __webpack_require__(/*! ../util/get-monitor-id */ \"../scratch-vm/src/util/get-monitor-id.js\");\n\n/**\n * @fileoverview\n * Store and mutate the VM block representation,\n * and handle updates from Scratch Blocks events.\n */\n\n/**\n * Create a block container.\n * @param {Runtime} runtime The runtime this block container operates within\n * @param {boolean} optNoGlow Optional flag to indicate that blocks in this container\n * should not request glows. This does not affect glows when clicking on a block to execute it.\n */\nclass Blocks {\n    constructor (runtime, optNoGlow) {\n        this.runtime = runtime;\n\n        /**\n         * All blocks in the workspace.\n         * Keys are block IDs, values are metadata about the block.\n         * @type {Object.<string, Object>}\n         */\n        this._blocks = {};\n\n        /**\n         * All top-level scripts in the workspace.\n         * A list of block IDs that represent scripts (i.e., first block in script).\n         * @type {Array.<String>}\n         */\n        this._scripts = [];\n\n        /**\n         * Runtime Cache\n         * @type {{inputs: {}, procedureParamNames: {}, procedureDefinitions: {}}}\n         * @private\n         */\n        Object.defineProperty(this, '_cache', {\n            writable: true,\n            enumerable: false\n        });\n        this._cache = {\n            /**\n             * Cache block inputs by block id\n             * @type {object.<string, !Array.<object>>}\n             */\n            inputs: {},\n            /**\n             * Cache procedure Param Names by block id\n             * @type {object.<string, ?Array.<string>>}\n             */\n            procedureParamNames: {},\n            /**\n             * Cache procedure definitions by block id\n             * @type {object.<string, ?string>}\n             */\n            procedureDefinitions: {},\n\n            /**\n             * A cache for execute to use and store on. Only available to\n             * execute.\n             * @type {object.<string, object>}\n             */\n            _executeCached: {},\n\n            /**\n             * A cache of block IDs and targets to start threads on as they are\n             * actively monitored.\n             * @type {Array<{blockId: string, target: Target}>}\n             */\n            _monitored: null,\n\n            /**\n             * A cache of hat opcodes to collection of theads to execute.\n             * @type {object.<string, object>}\n             */\n            scripts: {}\n        };\n\n        /**\n         * Flag which indicates that blocks in this container should not glow.\n         * Blocks will still glow when clicked on, but this flag is used to control\n         * whether the blocks in this container can request a glow as part of\n         * a running stack. E.g. the flyout block container and the monitor block container\n         * should not be able to request a glow, but blocks containers belonging to\n         * sprites should.\n         * @type {boolean}\n         */\n        this.forceNoGlow = optNoGlow || false;\n    }\n\n    /**\n     * Blockly inputs that represent statements/branch.\n     * are prefixed with this string.\n     * @const{string}\n     */\n    static get BRANCH_INPUT_PREFIX () {\n        return 'SUBSTACK';\n    }\n\n    /**\n     * Provide an object with metadata for the requested block ID.\n     * @param {!string} blockId ID of block we have stored.\n     * @return {?object} Metadata about the block, if it exists.\n     */\n    getBlock (blockId) {\n        return this._blocks[blockId];\n    }\n\n    /**\n     * Get all known top-level blocks that start scripts.\n     * @return {Array.<string>} List of block IDs.\n     */\n    getScripts () {\n        return this._scripts;\n    }\n\n    /**\n     * Get the next block for a particular block\n     * @param {?string} id ID of block to get the next block for\n     * @return {?string} ID of next block in the sequence\n     */\n    getNextBlock (id) {\n        const block = this._blocks[id];\n        return typeof block === 'undefined' ? null : block.next;\n    }\n\n    /**\n     * Get the branch for a particular C-shaped block.\n     * @param {?string} id ID for block to get the branch for.\n     * @param {?number} branchNum Which branch to select (e.g. for if-else).\n     * @return {?string} ID of block in the branch.\n     */\n    getBranch (id, branchNum) {\n        const block = this._blocks[id];\n        if (typeof block === 'undefined') return null;\n        if (!branchNum) branchNum = 1;\n\n        let inputName = Blocks.BRANCH_INPUT_PREFIX;\n        if (branchNum > 1) {\n            inputName += branchNum;\n        }\n\n        // Empty C-block?\n        const input = block.inputs[inputName];\n        return typeof input === 'undefined' ? null : input.block;\n    }\n\n    /**\n     * Get the opcode for a particular block\n     * @param {?object} block The block to query\n     * @return {?string} the opcode corresponding to that block\n     */\n    getOpcode (block) {\n        return typeof block === 'undefined' ? null : block.opcode;\n    }\n\n    /**\n     * Get all fields and their values for a block.\n     * @param {?object} block The block to query.\n     * @return {?object} All fields and their values.\n     */\n    getFields (block) {\n        return typeof block === 'undefined' ? null : block.fields;\n    }\n\n    /**\n     * Get all non-branch inputs for a block.\n     * @param {?object} block the block to query.\n     * @return {?Array.<object>} All non-branch inputs and their associated blocks.\n     */\n    getInputs (block) {\n        if (typeof block === 'undefined') return null;\n        let inputs = this._cache.inputs[block.id];\n        if (typeof inputs !== 'undefined') {\n            return inputs;\n        }\n\n        inputs = {};\n        for (const input in block.inputs) {\n            // Ignore blocks prefixed with branch prefix.\n            if (\n                input.substring(0, Blocks.BRANCH_INPUT_PREFIX.length) !==\n                Blocks.BRANCH_INPUT_PREFIX\n            ) {\n                inputs[input] = block.inputs[input];\n            }\n        }\n\n        this._cache.inputs[block.id] = inputs;\n        return inputs;\n    }\n\n    /**\n     * Get mutation data for a block.\n     * @param {?object} block The block to query.\n     * @return {?object} Mutation for the block.\n     */\n    getMutation (block) {\n        return typeof block === 'undefined' ? null : block.mutation;\n    }\n\n    /**\n     * Get the top-level script for a given block.\n     * @param {?string} id ID of block to query.\n     * @return {?string} ID of top-level script block.\n     */\n    getTopLevelScript (id) {\n        let block = this._blocks[id];\n        if (typeof block === 'undefined') return null;\n        while (block.parent !== null) {\n            block = this._blocks[block.parent];\n        }\n        return block.id;\n    }\n\n    /**\n     * Get the procedure definition for a given name.\n     * @param {?string} name Name of procedure to query.\n     * @return {?string} ID of procedure definition.\n     */\n    getProcedureDefinition (name) {\n        const blockID = this._cache.procedureDefinitions[name];\n        if (typeof blockID !== 'undefined') {\n            return blockID;\n        }\n\n        for (const id in this._blocks) {\n            if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) {\n                continue;\n            }\n            const block = this._blocks[id];\n            if (block.opcode === 'procedures_definition') {\n                const internal = this._getCustomBlockInternal(block);\n                if (internal && internal.mutation.proccode === name) {\n                    this._cache.procedureDefinitions[name] = id; // The outer define block id\n                    return id;\n                }\n            }\n        }\n\n        this._cache.procedureDefinitions[name] = null;\n        return null;\n    }\n\n    /**\n     * Get names and ids of parameters for the given procedure.\n     * @param {?string} name Name of procedure to query.\n     * @return {?Array.<string>} List of param names for a procedure.\n     */\n    getProcedureParamNamesAndIds (name) {\n        return this.getProcedureParamNamesIdsAndDefaults(name).slice(0, 2);\n    }\n\n    /**\n     * Get names, ids, and defaults of parameters for the given procedure.\n     * @param {?string} name Name of procedure to query.\n     * @return {?Array.<string>} List of param names for a procedure.\n     */\n    getProcedureParamNamesIdsAndDefaults (name) {\n        const cachedNames = this._cache.procedureParamNames[name];\n        if (typeof cachedNames !== 'undefined') {\n            return cachedNames;\n        }\n\n        for (const id in this._blocks) {\n            if (!Object.prototype.hasOwnProperty.call(this._blocks, id)) {\n                continue;\n            }\n            const block = this._blocks[id];\n            if (\n                block.opcode === 'procedures_prototype' &&\n                block.mutation.proccode === name\n            ) {\n                const names = JSON.parse(block.mutation.argumentnames);\n                const ids = JSON.parse(block.mutation.argumentids);\n                const defaults = JSON.parse(block.mutation.argumentdefaults);\n\n                this._cache.procedureParamNames[name] = [names, ids, defaults];\n                return this._cache.procedureParamNames[name];\n            }\n        }\n\n        this._cache.procedureParamNames[name] = null;\n        return null;\n    }\n\n    duplicate () {\n        const newBlocks = new Blocks(this.runtime, this.forceNoGlow);\n        newBlocks._blocks = Clone.simple(this._blocks);\n        newBlocks._scripts = Clone.simple(this._scripts);\n        return newBlocks;\n    }\n    // ---------------------------------------------------------------------\n\n    /**\n     * Create event listener for blocks, variables, and comments. Handles validation and\n     * serves as a generic adapter between the blocks, variables, and the\n     * runtime interface.\n     * @param {object} e Blockly \"block\" or \"variable\" event\n     */\n    blocklyListen (e) {\n        // Validate event\n        if (typeof e !== 'object') return;\n        if (\n            typeof e.blockId !== 'string' &&\n            typeof e.varId !== 'string' &&\n            typeof e.commentId !== 'string'\n        ) {\n            return;\n        }\n        const stage = this.runtime.getTargetForStage();\n        const editingTarget = this.runtime.getEditingTarget();\n\n        // UI event: clicked scripts toggle in the runtime.\n        if (e.element === 'stackclick') {\n            this.runtime.toggleScript(e.blockId, {stackClick: true});\n            return;\n        }\n\n        // Block create/update/destroy\n        switch (e.type) {\n        case 'create': {\n            const newBlocks = adapter(e);\n            // A create event can create many blocks. Add them all.\n            for (let i = 0; i < newBlocks.length; i++) {\n                this.createBlock(newBlocks[i]);\n            }\n            break;\n        }\n        case 'change':\n            this.changeBlock({\n                id: e.blockId,\n                element: e.element,\n                name: e.name,\n                value: e.newValue\n            });\n            break;\n        case 'move':\n            this.moveBlock({\n                id: e.blockId,\n                oldParent: e.oldParentId,\n                oldInput: e.oldInputName,\n                newParent: e.newParentId,\n                newInput: e.newInputName,\n                newCoordinate: e.newCoordinate\n            });\n            break;\n        case 'dragOutside':\n            this.runtime.emitBlockDragUpdate(e.isOutside);\n            break;\n        case 'endDrag':\n            this.runtime.emitBlockDragUpdate(false /* areBlocksOverGui */);\n\n            // Drag blocks onto another sprite\n            if (e.isOutside) {\n                const newBlocks = adapter(e);\n                this.runtime.emitBlockEndDrag(newBlocks, e.blockId);\n            }\n            break;\n        case 'delete':\n            // Don't accept delete events for missing blocks,\n            // or shadow blocks being obscured.\n            if (\n                !Object.prototype.hasOwnProperty.call(\n                    this._blocks,\n                    e.blockId\n                ) ||\n                    this._blocks[e.blockId].shadow\n            ) {\n                return;\n            }\n            // Inform any runtime to forget about glows on this script.\n            if (this._blocks[e.blockId].topLevel) {\n                this.runtime.quietGlow(e.blockId);\n            }\n            this.deleteBlock(e.blockId);\n            break;\n        case 'var_create':\n            // Check if the variable being created is global or local\n            // If local, create a local var on the current editing target, as long\n            // as there are no conflicts, and the current target is actually a sprite\n            // If global or if the editing target is not present or we somehow got\n            // into a state where a local var was requested for the stage,\n            // create a stage (global) var after checking for name conflicts\n            // on all the sprites.\n            if (\n                e.isLocal &&\n                    editingTarget &&\n                    !editingTarget.isStage &&\n                    !e.isCloud\n            ) {\n                if (!editingTarget.lookupVariableById(e.varId)) {\n                    editingTarget.createVariable(\n                        e.varId,\n                        e.varName,\n                        e.varType\n                    );\n                    this.emitProjectChanged();\n                }\n            } else {\n                if (stage.lookupVariableById(e.varId)) {\n                    // Do not re-create a variable if it already exists\n                    return;\n                }\n                // Check for name conflicts in all of the targets\n                const allTargets = this.runtime.targets.filter(\n                    t => t.isOriginal\n                );\n                for (const target of allTargets) {\n                    if (\n                        target.lookupVariableByNameAndType(\n                            e.varName,\n                            e.varType,\n                            true\n                        )\n                    ) {\n                        return;\n                    }\n                }\n                stage.createVariable(\n                    e.varId,\n                    e.varName,\n                    e.varType,\n                    e.isCloud\n                );\n                this.emitProjectChanged();\n            }\n            break;\n        case 'var_rename':\n            if (\n                editingTarget &&\n                    Object.prototype.hasOwnProperty.call(\n                        editingTarget.variables,\n                        e.varId\n                    )\n            ) {\n                // This is a local variable, rename on the current target\n                editingTarget.renameVariable(e.varId, e.newName);\n                // Update all the blocks on the current target that use\n                // this variable\n                editingTarget.blocks.updateBlocksAfterVarRename(\n                    e.varId,\n                    e.newName\n                );\n            } else {\n                // This is a global variable\n                stage.renameVariable(e.varId, e.newName);\n                // Update all blocks on all targets that use the renamed variable\n                const targets = this.runtime.targets;\n                for (let i = 0; i < targets.length; i++) {\n                    const currTarget = targets[i];\n                    currTarget.blocks.updateBlocksAfterVarRename(\n                        e.varId,\n                        e.newName\n                    );\n                }\n            }\n            this.emitProjectChanged();\n            break;\n        case 'var_delete': {\n            const target =\n                    editingTarget &&\n                    Object.prototype.hasOwnProperty.call(\n                        editingTarget.variables,\n                        e.varId\n                    ) ?\n                        editingTarget :\n                        stage;\n            target.deleteVariable(e.varId);\n            this.emitProjectChanged();\n            break;\n        }\n        case 'comment_create':\n            if (this.runtime.getEditingTarget()) {\n                const currTarget = this.runtime.getEditingTarget();\n                currTarget.createComment(\n                    e.commentId,\n                    e.blockId,\n                    e.text,\n                    e.xy.x,\n                    e.xy.y,\n                    e.width,\n                    e.height,\n                    e.minimized\n                );\n\n                if (\n                    currTarget.comments[e.commentId].x === null &&\n                        currTarget.comments[e.commentId].y === null\n                ) {\n                    // Block comments imported from 2.0 projects are imported with their\n                    // x and y coordinates set to null so that scratch-blocks can\n                    // auto-position them. If we are receiving a create event for these\n                    // comments, then the auto positioning should have taken place.\n                    // Update the x and y position of these comments to match the\n                    // one from the event.\n                    currTarget.comments[e.commentId].x = e.xy.x;\n                    currTarget.comments[e.commentId].y = e.xy.y;\n                }\n            }\n            this.emitProjectChanged();\n            break;\n        case 'comment_change':\n            if (this.runtime.getEditingTarget()) {\n                const currTarget = this.runtime.getEditingTarget();\n                if (\n                    !Object.prototype.hasOwnProperty.call(\n                        currTarget.comments,\n                        e.commentId\n                    )\n                ) {\n                    log.warn(\n                        `Cannot change comment with id ${e.commentId} because it does not exist.`\n                    );\n                    return;\n                }\n                const comment = currTarget.comments[e.commentId];\n                const change = e.newContents_;\n                if (Object.prototype.hasOwnProperty.call(change, 'minimized')) {\n                    comment.minimized = change.minimized;\n                }\n                if (Object.prototype.hasOwnProperty.call(change, 'width') &&\n                    Object.prototype.hasOwnProperty.call(change, 'height')) {\n                    comment.width = change.width;\n                    comment.height = change.height;\n                }\n                if (Object.prototype.hasOwnProperty.call(change, 'text')) {\n                    comment.text = change.text;\n                }\n                this.emitProjectChanged();\n            }\n            break;\n        case 'comment_move':\n            if (this.runtime.getEditingTarget()) {\n                const currTarget = this.runtime.getEditingTarget();\n                if (\n                    currTarget &&\n                        !Object.prototype.hasOwnProperty.call(\n                            currTarget.comments,\n                            e.commentId\n                        )\n                ) {\n                    log.warn(\n                        `Cannot move comment with id ${e.commentId} because it does not exist.`\n                    );\n                    return;\n                }\n                const comment = currTarget.comments[e.commentId];\n                const newCoord = e.newCoordinate_;\n                comment.x = newCoord.x;\n                comment.y = newCoord.y;\n\n                this.emitProjectChanged();\n            }\n            break;\n        case 'comment_delete':\n            if (this.runtime.getEditingTarget()) {\n                const currTarget = this.runtime.getEditingTarget();\n                if (\n                    !Object.prototype.hasOwnProperty.call(\n                        currTarget.comments,\n                        e.commentId\n                    )\n                ) {\n                    // If we're in this state, we have probably received\n                    // a delete event from a workspace that we switched from\n                    // (e.g. a delete event for a comment on sprite a's workspace\n                    // when switching from sprite a to sprite b)\n                    return;\n                }\n                delete currTarget.comments[e.commentId];\n                if (e.blockId) {\n                    const block = currTarget.blocks.getBlock(e.blockId);\n                    if (!block) {\n                        log.warn(\n                            `Could not find block referenced by comment with id: ${e.commentId}`\n                        );\n                        return;\n                    }\n                    delete block.comment;\n                }\n\n                this.emitProjectChanged();\n            }\n            break;\n        }\n    }\n\n    // ---------------------------------------------------------------------\n\n    /**\n     * Reset all runtime caches.\n     */\n    resetCache () {\n        this._cache.inputs = {};\n        this._cache.procedureParamNames = {};\n        this._cache.procedureDefinitions = {};\n        this._cache._executeCached = {};\n        this._cache._monitored = null;\n        this._cache.scripts = {};\n    }\n\n    /**\n     * Emit a project changed event if this is a block container\n     * that can affect the project state.\n     */\n    emitProjectChanged () {\n        if (!this.forceNoGlow) {\n            this.runtime.emitProjectChanged();\n        }\n    }\n\n    /**\n     * Block management: create blocks and scripts from a `create` event\n     * @param {!object} block Blockly create event to be processed\n     */\n    createBlock (block) {\n        // Does the block already exist?\n        // Could happen, e.g., for an unobscured shadow.\n        if (Object.prototype.hasOwnProperty.call(this._blocks, block.id)) {\n            return;\n        }\n        // Create new block.\n        this._blocks[block.id] = block;\n        // Push block id to scripts array.\n        // Blocks are added as a top-level stack if they are marked as a top-block\n        // (if they were top-level XML in the event).\n        if (block.topLevel) {\n            this._addScript(block.id);\n        }\n\n        this.resetCache();\n\n        // A new block was actually added to the block container,\n        // emit a project changed event\n        this.emitProjectChanged();\n    }\n\n    /**\n     * Block management: change block field values\n     * @param {!object} args Blockly change event to be processed\n     */\n    changeBlock (args) {\n        // Validate\n        if (['field', 'mutation', 'checkbox'].indexOf(args.element) === -1) {\n            return;\n        }\n        let block = this._blocks[args.id];\n        if (typeof block === 'undefined') return;\n        switch (args.element) {\n        case 'field':\n            // TODO when the field of a monitored block changes,\n            // update the checkbox in the flyout based on whether\n            // a monitor for that current combination of selected parameters exists\n            // e.g.\n            // 1. check (current [v year])\n            // 2. switch dropdown in flyout block to (current [v minute])\n            // 3. the checkbox should become unchecked if we're not already\n            //    monitoring current minute\n\n            // Update block value\n            if (!block.fields[args.name]) return;\n            if (\n                args.name === 'VARIABLE' ||\n                    args.name === 'LIST' ||\n                    args.name === 'BROADCAST_OPTION'\n            ) {\n                // Get variable name using the id in args.value.\n                const variable = this.runtime\n                    .getEditingTarget()\n                    .lookupVariableById(args.value);\n                if (variable) {\n                    block.fields[args.name].value = variable.name;\n                    block.fields[args.name].id = args.value;\n                }\n            } else {\n                // Changing the value in a dropdown\n                block.fields[args.name].value = args.value;\n\n                // The selected item in the sensing of block menu needs to change based on the\n                // selected target.  Set it to the first item in the menu list.\n                // TODO: (#1787)\n                if (block.opcode === 'sensing_of_object_menu') {\n                    if (block.fields.OBJECT.value === '_stage_') {\n                        this._blocks[block.parent].fields.PROPERTY.value =\n                                'backdrop #';\n                    } else {\n                        this._blocks[block.parent].fields.PROPERTY.value =\n                                'x position';\n                    }\n                    this.runtime.requestBlocksUpdate();\n                }\n\n                const flyoutBlock =\n                        block.shadow && block.parent ?\n                            this._blocks[block.parent] :\n                            block;\n                if (flyoutBlock.isMonitored) {\n                    this.runtime.requestUpdateMonitor(\n                        Map({\n                            id: flyoutBlock.id,\n                            params: this._getBlockParams(flyoutBlock)\n                        })\n                    );\n                }\n            }\n            break;\n        case 'mutation':\n            block.mutation = mutationAdapter(args.value);\n            break;\n        case 'checkbox': {\n            // A checkbox usually has a one to one correspondence with the monitor\n            // block but in the case of monitored reporters that have arguments,\n            // map the old id to a new id, creating a new monitor block if necessary\n            if (\n                block.fields &&\n                    Object.keys(block.fields).length > 0 &&\n                    block.opcode !== 'data_variable' &&\n                    block.opcode !== 'data_listcontents'\n            ) {\n                // This block has an argument which needs to get separated out into\n                // multiple monitor blocks with ids based on the selected argument\n                // Note: we're not just constantly creating a longer and longer id everytime we check\n                // the checkbox because we're using the id of the block in the flyout as the base\n                const newId = getMonitorIdForBlockWithArgs(\n                    block.id,\n                    block.fields\n                );\n\n                // check if a block with the new id already exists, otherwise create\n                let newBlock = this.runtime.monitorBlocks.getBlock(newId);\n                if (!newBlock) {\n                    newBlock = JSON.parse(JSON.stringify(block));\n                    newBlock.id = newId;\n                    this.runtime.monitorBlocks.createBlock(newBlock);\n                }\n\n                block = newBlock; // Carry on through the rest of this code with newBlock\n            }\n\n            const wasMonitored = block.isMonitored;\n            block.isMonitored = args.value;\n\n            // Variable blocks may be sprite specific depending on the owner of the variable\n            let isSpriteLocalVariable = false;\n            if (block.opcode === 'data_variable') {\n                isSpriteLocalVariable =\n                        !this.runtime.getTargetForStage().variables[\n                            block.fields.VARIABLE.id\n                        ];\n            } else if (block.opcode === 'data_listcontents') {\n                isSpriteLocalVariable =\n                        !this.runtime.getTargetForStage().variables[\n                            block.fields.LIST.id\n                        ];\n            }\n\n            const isSpriteSpecific =\n                    isSpriteLocalVariable ||\n                    (Object.prototype.hasOwnProperty.call(\n                        this.runtime.monitorBlockInfo,\n                        block.opcode\n                    ) &&\n                        this.runtime.monitorBlockInfo[block.opcode]\n                            .isSpriteSpecific);\n            if (isSpriteSpecific) {\n                // If creating a new sprite specific monitor, the only possible target is\n                // the current editing one b/c you cannot dynamically create monitors.\n                // Also, do not change the targetId if it has already been assigned\n                block.targetId =\n                        block.targetId || this.runtime.getEditingTarget().id;\n            } else {\n                block.targetId = null;\n            }\n\n            if (wasMonitored && !block.isMonitored) {\n                this.runtime.requestHideMonitor(block.id);\n            } else if (!wasMonitored && block.isMonitored) {\n                // Tries to show the monitor for specified block. If it doesn't exist, add the monitor.\n                if (!this.runtime.requestShowMonitor(block.id)) {\n                    this.runtime.requestAddMonitor(\n                        MonitorRecord({\n                            id: block.id,\n                            targetId: block.targetId,\n                            spriteName: block.targetId ?\n                                this.runtime\n                                    .getTargetById(block.targetId)\n                                    .getName() :\n                                null,\n                            opcode: block.opcode,\n                            params: this._getBlockParams(block),\n                            // @todo(vm#565) for numerical values with decimals, some countries use comma\n                            value: '',\n                            mode:\n                                    block.opcode === 'data_listcontents' ?\n                                        'list' :\n                                        'default'\n                        })\n                    );\n                }\n            }\n            break;\n        }\n        }\n\n        this.emitProjectChanged();\n\n        this.resetCache();\n    }\n\n    /**\n     * Block management: move blocks from parent to parent\n     * @param {!object} e Blockly move event to be processed\n     */\n    moveBlock (e) {\n        if (!Object.prototype.hasOwnProperty.call(this._blocks, e.id)) {\n            return;\n        }\n\n        const block = this._blocks[e.id];\n        // Track whether a change actually occurred\n        // ignoring changes like routine re-positioning\n        // of a block when loading a workspace\n        let didChange = false;\n\n        // Move coordinate changes.\n        if (e.newCoordinate) {\n            didChange =\n                block.x !== e.newCoordinate.x || block.y !== e.newCoordinate.y;\n\n            block.x = e.newCoordinate.x;\n            block.y = e.newCoordinate.y;\n        }\n\n        // Remove from any old parent.\n        if (typeof e.oldParent !== 'undefined') {\n            const oldParent = this._blocks[e.oldParent];\n            if (\n                typeof e.oldInput !== 'undefined' &&\n                oldParent.inputs[e.oldInput].block === e.id\n            ) {\n                // This block was connected to the old parent's input.\n                oldParent.inputs[e.oldInput].block = null;\n            } else if (oldParent.next === e.id) {\n                // This block was connected to the old parent's next connection.\n                oldParent.next = null;\n            }\n            this._blocks[e.id].parent = null;\n            didChange = true;\n        }\n\n        // Is this block a top-level block?\n        if (typeof e.newParent === 'undefined') {\n            this._addScript(e.id);\n        } else {\n            // Remove script, if one exists.\n            this._deleteScript(e.id);\n            // Otherwise, try to connect it in its new place.\n            if (typeof e.newInput === 'undefined') {\n                // Moved to the new parent's next connection.\n                this._blocks[e.newParent].next = e.id;\n            } else {\n                // Moved to the new parent's input.\n                // Don't obscure the shadow block.\n                let oldShadow = null;\n                if (\n                    Object.prototype.hasOwnProperty.call(\n                        this._blocks[e.newParent].inputs,\n                        e.newInput\n                    )\n                ) {\n                    oldShadow =\n                        this._blocks[e.newParent].inputs[e.newInput].shadow;\n                }\n\n                // If the block being attached is itself a shadow, make sure to set\n                // both block and shadow to that blocks ID. This happens when adding\n                // inputs to a custom procedure.\n                if (this._blocks[e.id].shadow) oldShadow = e.id;\n\n                this._blocks[e.newParent].inputs[e.newInput] = {\n                    name: e.newInput,\n                    block: e.id,\n                    shadow: oldShadow\n                };\n            }\n            this._blocks[e.id].parent = e.newParent;\n            didChange = true;\n        }\n        this.resetCache();\n\n        if (didChange) this.emitProjectChanged();\n    }\n\n    /**\n     * Block management: run all blocks.\n     * @param {!object} runtime Runtime to run all blocks in.\n     */\n    runAllMonitored (runtime) {\n        if (this._cache._monitored === null) {\n            this._cache._monitored = Object.keys(this._blocks)\n                .filter(blockId => this.getBlock(blockId).isMonitored)\n                .map(blockId => {\n                    const targetId = this.getBlock(blockId).targetId;\n                    return {\n                        blockId,\n                        target: targetId ?\n                            runtime.getTargetById(targetId) :\n                            null\n                    };\n                });\n        }\n\n        const monitored = this._cache._monitored;\n        for (let i = 0; i < monitored.length; i++) {\n            const {blockId, target} = monitored[i];\n            runtime.addMonitorScript(blockId, target);\n        }\n    }\n\n    /**\n     * Block management: delete blocks and their associated scripts. Does nothing if a block\n     * with the given ID does not exist.\n     * @param {!string} blockId Id of block to delete\n     */\n    deleteBlock (blockId) {\n        // @todo In runtime, stop threads running on this script.\n\n        // Get block\n        const block = this._blocks[blockId];\n        if (!block) {\n            // No block with the given ID exists\n            return;\n        }\n\n        // Delete children\n        if (block.next !== null) {\n            this.deleteBlock(block.next);\n        }\n\n        // Delete inputs (including branches)\n        for (const input in block.inputs) {\n            // If it's null, the block in this input moved away.\n            if (block.inputs[input].block !== null) {\n                this.deleteBlock(block.inputs[input].block);\n            }\n            // Delete obscured shadow blocks.\n            if (\n                block.inputs[input].shadow !== null &&\n                block.inputs[input].shadow !== block.inputs[input].block\n            ) {\n                this.deleteBlock(block.inputs[input].shadow);\n            }\n        }\n\n        // Delete any script starting with this block.\n        this._deleteScript(blockId);\n\n        // Delete block itself.\n        delete this._blocks[blockId];\n\n        this.resetCache();\n        this.emitProjectChanged();\n    }\n\n    /**\n     * Delete all blocks and their associated scripts.\n     */\n    deleteAllBlocks () {\n        const blockIds = Object.keys(this._blocks);\n        blockIds.forEach(blockId => this.deleteBlock(blockId));\n    }\n\n    /**\n     * Returns a map of all references to variables or lists from blocks\n     * in this block container.\n     * @param {Array<object>} optBlocks Optional list of blocks to constrain the search to.\n     * This is useful for getting variable/list references for a stack of blocks instead\n     * of all blocks on the workspace\n     * @param {?boolean} optIncludeBroadcast Optional whether to include broadcast fields.\n     * @return {object} A map of variable ID to a list of all variable references\n     * for that ID. A variable reference contains the field referencing that variable\n     * and also the type of the variable being referenced.\n     */\n    getAllVariableAndListReferences (optBlocks, optIncludeBroadcast) {\n        const blocks = optBlocks ? optBlocks : this._blocks;\n        const allReferences = Object.create(null);\n        for (const blockId in blocks) {\n            let varOrListField = null;\n            let varType = null;\n            if (blocks[blockId].fields.VARIABLE) {\n                varOrListField = blocks[blockId].fields.VARIABLE;\n                varType = Variable.SCALAR_TYPE;\n            } else if (blocks[blockId].fields.LIST) {\n                varOrListField = blocks[blockId].fields.LIST;\n                varType = Variable.LIST_TYPE;\n            } else if (\n                optIncludeBroadcast &&\n                blocks[blockId].fields.BROADCAST_OPTION\n            ) {\n                varOrListField = blocks[blockId].fields.BROADCAST_OPTION;\n                varType = Variable.BROADCAST_MESSAGE_TYPE;\n            }\n            if (varOrListField) {\n                const currVarId = varOrListField.id;\n                if (allReferences[currVarId]) {\n                    allReferences[currVarId].push({\n                        referencingField: varOrListField,\n                        type: varType\n                    });\n                } else {\n                    allReferences[currVarId] = [\n                        {\n                            referencingField: varOrListField,\n                            type: varType\n                        }\n                    ];\n                }\n            }\n        }\n        return allReferences;\n    }\n\n    /**\n     * Keep blocks up to date after a variable gets renamed.\n     * @param {string} varId The id of the variable that was renamed\n     * @param {string} newName The new name of the variable that was renamed\n     */\n    updateBlocksAfterVarRename (varId, newName) {\n        const blocks = this._blocks;\n        for (const blockId in blocks) {\n            let varOrListField = null;\n            if (blocks[blockId].fields.VARIABLE) {\n                varOrListField = blocks[blockId].fields.VARIABLE;\n            } else if (blocks[blockId].fields.LIST) {\n                varOrListField = blocks[blockId].fields.LIST;\n            }\n            if (varOrListField) {\n                const currFieldId = varOrListField.id;\n                if (varId === currFieldId) {\n                    varOrListField.value = newName;\n                }\n            }\n        }\n    }\n\n    /**\n     * Keep blocks up to date after they are shared between targets.\n     * @param {boolean} isStage If the new target is a stage.\n     */\n    updateTargetSpecificBlocks (isStage) {\n        const blocks = this._blocks;\n        for (const blockId in blocks) {\n            if (\n                isStage &&\n                blocks[blockId].opcode === 'event_whenthisspriteclicked'\n            ) {\n                blocks[blockId].opcode = 'event_whenstageclicked';\n            } else if (\n                !isStage &&\n                blocks[blockId].opcode === 'event_whenstageclicked'\n            ) {\n                blocks[blockId].opcode = 'event_whenthisspriteclicked';\n            }\n        }\n    }\n\n    /**\n     * Update blocks after a sound, costume, or backdrop gets renamed.\n     * Any block referring to the old name of the asset should get updated\n     * to refer to the new name.\n     * @param {string} oldName The old name of the asset that was renamed.\n     * @param {string} newName The new name of the asset that was renamed.\n     * @param {string} assetType String representation of the kind of asset\n     * that was renamed. This can be one of 'sprite','costume', 'sound', or\n     * 'backdrop'.\n     */\n    updateAssetName (oldName, newName, assetType) {\n        let getAssetField;\n        if (assetType === 'costume') {\n            getAssetField = this._getCostumeField.bind(this);\n        } else if (assetType === 'sound') {\n            getAssetField = this._getSoundField.bind(this);\n        } else if (assetType === 'backdrop') {\n            getAssetField = this._getBackdropField.bind(this);\n        } else if (assetType === 'sprite') {\n            getAssetField = this._getSpriteField.bind(this);\n        } else {\n            return;\n        }\n        const blocks = this._blocks;\n        for (const blockId in blocks) {\n            const assetField = getAssetField(blockId);\n            if (assetField && assetField.value === oldName) {\n                assetField.value = newName;\n            }\n        }\n    }\n\n    /**\n     * Update sensing_of blocks after a variable gets renamed.\n     * @param {string} oldName The old name of the variable that was renamed.\n     * @param {string} newName The new name of the variable that was renamed.\n     * @param {string} targetName The name of the target the variable belongs to.\n     * @return {boolean} Returns true if any of the blocks were updated.\n     */\n    updateSensingOfReference (oldName, newName, targetName) {\n        const blocks = this._blocks;\n        let blockUpdated = false;\n        for (const blockId in blocks) {\n            const block = blocks[blockId];\n            if (\n                block.opcode === 'sensing_of' &&\n                block.fields.PROPERTY.value === oldName &&\n                // If block and shadow are different, it means a block is inserted to OBJECT, and should be ignored.\n                block.inputs.OBJECT.block === block.inputs.OBJECT.shadow\n            ) {\n                const inputBlock = this.getBlock(block.inputs.OBJECT.block);\n                if (inputBlock.fields.OBJECT.value === targetName) {\n                    block.fields.PROPERTY.value = newName;\n                    blockUpdated = true;\n                }\n            }\n        }\n        if (blockUpdated) this.resetCache();\n        return blockUpdated;\n    }\n\n    /**\n     * Helper function to retrieve a costume menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The costume menu field of the block with the given block id.\n     * Null if either a block with the given id doesn't exist or if a costume menu field\n     * does not exist on the block with the given id.\n     */\n    _getCostumeField (blockId) {\n        const block = this.getBlock(blockId);\n        if (\n            block &&\n            Object.prototype.hasOwnProperty.call(block.fields, 'COSTUME')\n        ) {\n            return block.fields.COSTUME;\n        }\n        return null;\n    }\n\n    /**\n     * Helper function to retrieve a sound menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The sound menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a sound menu field\n     * does not exist on the block with the given id.\n     */\n    _getSoundField (blockId) {\n        const block = this.getBlock(blockId);\n        if (\n            block &&\n            Object.prototype.hasOwnProperty.call(block.fields, 'SOUND_MENU')\n        ) {\n            return block.fields.SOUND_MENU;\n        }\n        return null;\n    }\n\n    /**\n     * Helper function to retrieve a backdrop menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The backdrop menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a backdrop menu field\n     * does not exist on the block with the given id.\n     */\n    _getBackdropField (blockId) {\n        const block = this.getBlock(blockId);\n        if (\n            block &&\n            Object.prototype.hasOwnProperty.call(block.fields, 'BACKDROP')\n        ) {\n            return block.fields.BACKDROP;\n        }\n        return null;\n    }\n\n    /**\n     * Helper function to retrieve a sprite menu field from a block given its id.\n     * @param {string} blockId A unique identifier for a block\n     * @return {?object} The sprite menu field of the block with the given block id.\n     * Null, if either a block with the given id doesn't exist or if a sprite menu field\n     * does not exist on the block with the given id.\n     */\n    _getSpriteField (blockId) {\n        const block = this.getBlock(blockId);\n        if (!block) {\n            return null;\n        }\n        const spriteMenuNames = [\n            'TOWARDS',\n            'TO',\n            'OBJECT',\n            'VIDEOONMENU2',\n            'DISTANCETOMENU',\n            'TOUCHINGOBJECTMENU',\n            'CLONE_OPTION'\n        ];\n        for (let i = 0; i < spriteMenuNames.length; i++) {\n            const menuName = spriteMenuNames[i];\n            if (Object.prototype.hasOwnProperty.call(block.fields, menuName)) {\n                return block.fields[menuName];\n            }\n        }\n        return null;\n    }\n\n    // ---------------------------------------------------------------------\n\n    /**\n     * Encode all of `this._blocks` as an XML string usable\n     * by a Blockly/scratch-blocks workspace.\n     * @param {object<string, Comment>} comments Map of comments referenced by id\n     * @return {string} String of XML representing this object's blocks.\n     */\n    toXML (comments) {\n        return this._scripts\n            .map(script => this.blockToXML(script, comments))\n            .join();\n    }\n\n    /**\n     * Recursively encode an individual block and its children\n     * into a Blockly/scratch-blocks XML string.\n     * @param {!string} blockId ID of block to encode.\n     * @param {object<string, Comment>} comments Map of comments referenced by id\n     * @return {string} String of XML representing this block and any children.\n     */\n    blockToXML (blockId, comments) {\n        const block = this._blocks[blockId];\n        // block should exist, but currently some blocks' next property point\n        // to a blockId for non-existent blocks. Until we track down that behavior,\n        // this early exit allows the project to load.\n        if (!block) return;\n        // Encode properties of this block.\n        const tagName = block.shadow ? 'shadow' : 'block';\n        let xmlString = `<${tagName}\n                id=\"${block.id}\"\n                type=\"${block.opcode}\"\n                ${block.topLevel ? `x=\"${block.x}\" y=\"${block.y}\"` : ''}\n            >`;\n        const commentId = block.comment;\n        if (commentId) {\n            if (comments) {\n                if (Object.prototype.hasOwnProperty.call(comments, commentId)) {\n                    xmlString += comments[commentId].toXML();\n                } else {\n                    log.warn(\n                        `Could not find comment with id: ${commentId} in provided comment descriptions.`\n                    );\n                }\n            } else {\n                log.warn(\n                    `Cannot serialize comment with id: ${commentId}; no comment descriptions provided.`\n                );\n            }\n        }\n        // Add any mutation. Must come before inputs.\n        if (block.mutation) {\n            xmlString += this.mutationToXML(block.mutation);\n        }\n        // Add any inputs on this block.\n        for (const input in block.inputs) {\n            if (!Object.prototype.hasOwnProperty.call(block.inputs, input)) {\n                continue;\n            }\n            const blockInput = block.inputs[input];\n            // Only encode a value tag if the value input is occupied.\n            if (blockInput.block || blockInput.shadow) {\n                xmlString += `<value name=\"${blockInput.name}\">`;\n                if (blockInput.block) {\n                    xmlString += this.blockToXML(blockInput.block, comments);\n                }\n                if (\n                    blockInput.shadow &&\n                    blockInput.shadow !== blockInput.block\n                ) {\n                    // Obscured shadow.\n                    xmlString += this.blockToXML(blockInput.shadow, comments);\n                }\n                xmlString += '</value>';\n            }\n        }\n        // Add any fields on this block.\n        for (const field in block.fields) {\n            if (!Object.prototype.hasOwnProperty.call(block.fields, field)) {\n                continue;\n            }\n            const blockField = block.fields[field];\n            xmlString += `<field name=\"${blockField.name}\"`;\n            const fieldId = blockField.id;\n            if (fieldId) {\n                xmlString += ` id=\"${fieldId}\"`;\n            }\n            const varType = blockField.variableType;\n            if (typeof varType === 'string') {\n                xmlString += ` variabletype=\"${varType}\"`;\n            }\n            let value = blockField.value;\n            if (typeof value === 'string') {\n                value = xmlEscape(blockField.value);\n            }\n            xmlString += `>${value}</field>`;\n        }\n        // Add blocks connected to the next connection.\n        if (block.next) {\n            xmlString += `<next>${this.blockToXML(\n                block.next,\n                comments\n            )}</next>`;\n        }\n        xmlString += `</${tagName}>`;\n        return xmlString;\n    }\n\n    /**\n     * Recursively encode a mutation object to XML.\n     * @param {!object} mutation Object representing a mutation.\n     * @return {string} XML string representing a mutation.\n     */\n    mutationToXML (mutation) {\n        let mutationString = `<${mutation.tagName}`;\n        for (const prop in mutation) {\n            if (prop === 'children' || prop === 'tagName') continue;\n            let mutationValue =\n                typeof mutation[prop] === 'string' ?\n                    xmlEscape(mutation[prop]) :\n                    mutation[prop];\n\n            // Handle dynamic extension blocks\n            if (prop === 'blockInfo') {\n                mutationValue = xmlEscape(JSON.stringify(mutation[prop]));\n            }\n\n            mutationString += ` ${prop}=\"${mutationValue}\"`;\n        }\n        mutationString += '>';\n        for (let i = 0; i < mutation.children.length; i++) {\n            mutationString += this.mutationToXML(mutation.children[i]);\n        }\n        mutationString += `</${mutation.tagName}>`;\n        return mutationString;\n    }\n\n    // ---------------------------------------------------------------------\n    /**\n     * Helper to serialize block fields and input fields for reporting new monitors\n     * @param {!object} block Block to be paramified.\n     * @return {!object} object of param key/values.\n     */\n    _getBlockParams (block) {\n        const params = {};\n        for (const key in block.fields) {\n            params[key] = block.fields[key].value;\n        }\n        for (const inputKey in block.inputs) {\n            const inputBlock = this._blocks[block.inputs[inputKey].block];\n            for (const key in inputBlock.fields) {\n                params[key] = inputBlock.fields[key].value;\n            }\n        }\n        return params;\n    }\n\n    /**\n     * Helper to get the corresponding internal procedure definition block\n     * @param {!object} defineBlock Outer define block.\n     * @return {!object} internal definition block which has the mutation.\n     */\n    _getCustomBlockInternal (defineBlock) {\n        if (defineBlock.inputs && defineBlock.inputs.custom_block) {\n            return this._blocks[defineBlock.inputs.custom_block.block];\n        }\n    }\n\n    /**\n     * Helper to add a stack to `this._scripts`.\n     * @param {?string} topBlockId ID of block that starts the script.\n     */\n    _addScript (topBlockId) {\n        const i = this._scripts.indexOf(topBlockId);\n        if (i > -1) return; // Already in scripts.\n        this._scripts.push(topBlockId);\n        // Update `topLevel` property on the top block.\n        this._blocks[topBlockId].topLevel = true;\n    }\n\n    /**\n     * Helper to remove a script from `this._scripts`.\n     * @param {?string} topBlockId ID of block that starts the script.\n     */\n    _deleteScript (topBlockId) {\n        const i = this._scripts.indexOf(topBlockId);\n        if (i > -1) this._scripts.splice(i, 1);\n        // Update `topLevel` property on the top block.\n        if (this._blocks[topBlockId]) this._blocks[topBlockId].topLevel = false;\n    }\n}\n\n/**\n * A private method shared with execute to build an object containing the block\n * information execute needs and that is reset when other cached Blocks info is\n * reset.\n * @param {Blocks} blocks Blocks containing the expected blockId\n * @param {string} blockId blockId for the desired execute cache\n * @param {function} CacheType constructor for cached block information\n * @return {object} execute cache object\n */\nBlocksExecuteCache.getCached = function (blocks, blockId, CacheType) {\n    let cached = blocks._cache._executeCached[blockId];\n    if (typeof cached !== 'undefined') {\n        return cached;\n    }\n\n    const block = blocks.getBlock(blockId);\n    if (typeof block === 'undefined') return null;\n\n    if (typeof CacheType === 'undefined') {\n        cached = {\n            id: blockId,\n            opcode: blocks.getOpcode(block),\n            fields: blocks.getFields(block),\n            inputs: blocks.getInputs(block),\n            mutation: blocks.getMutation(block)\n        };\n    } else {\n        cached = new CacheType(blocks, {\n            id: blockId,\n            opcode: blocks.getOpcode(block),\n            fields: blocks.getFields(block),\n            inputs: blocks.getInputs(block),\n            mutation: blocks.getMutation(block)\n        });\n    }\n\n    blocks._cache._executeCached[blockId] = cached;\n    return cached;\n};\n\n/**\n * Cache class constructor for runtime. Used to consider what threads should\n * start based on hat data.\n * @type {function}\n */\nconst RuntimeScriptCache = BlocksRuntimeCache._RuntimeScriptCache;\n\n/**\n * Get an array of scripts from a block container prefiltered to match opcode.\n * @param {Blocks} blocks - Container of blocks\n * @param {string} opcode - Opcode to filter top blocks by\n * @returns {Array.<RuntimeScriptCache>} - Array of RuntimeScriptCache cache\n *   objects\n */\nBlocksRuntimeCache.getScripts = function (blocks, opcode) {\n    let scripts = blocks._cache.scripts[opcode];\n    if (!scripts) {\n        scripts = blocks._cache.scripts[opcode] = [];\n\n        const allScripts = blocks._scripts;\n        for (let i = 0; i < allScripts.length; i++) {\n            const topBlockId = allScripts[i];\n            const block = blocks.getBlock(topBlockId);\n            if (block.opcode === opcode) {\n                scripts.push(new RuntimeScriptCache(blocks, topBlockId));\n            }\n        }\n    }\n    return scripts;\n};\n\nmodule.exports = Blocks;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/blocks.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/comment.js":
/*!*******************************************!*\
  !*** ../scratch-vm/src/engine/comment.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview\n * Object representing a Scratch Comment (block or workspace).\n */\n\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\nconst xmlEscape = __webpack_require__(/*! ../util/xml-escape */ \"../scratch-vm/src/util/xml-escape.js\");\n\nclass Comment {\n    /**\n     * @param {string} id Id of the comment.\n     * @param {string} text Text content of the comment.\n     * @param {number} x X position of the comment on the workspace.\n     * @param {number} y Y position of the comment on the workspace.\n     * @param {number} width The width of the comment when it is full size.\n     * @param {number} height The height of the comment when it is full size.\n     * @param {boolean} minimized Whether the comment is minimized.\n     * @constructor\n     */\n    constructor (id, text, x, y, width, height, minimized) {\n        this.id = id || uid();\n        this.text = text;\n        this.x = x;\n        this.y = y;\n        this.width = Math.max(Number(width), Comment.MIN_WIDTH);\n        this.height = Math.max(Number(height), Comment.MIN_HEIGHT);\n        this.minimized = minimized || false;\n        this.blockId = null;\n    }\n\n    toXML () {\n        return `<comment id=\"${this.id}\" x=\"${this.x}\" y=\"${\n            this.y}\" w=\"${this.width}\" h=\"${this.height}\" pinned=\"${\n            this.blockId !== null}\" minimized=\"${this.minimized}\">${xmlEscape(this.text)}</comment>`;\n    }\n\n    // TODO choose min and defaults for width and height\n    static get MIN_WIDTH () {\n        return 20;\n    }\n\n    static get MIN_HEIGHT () {\n        return 20;\n    }\n\n    static get DEFAULT_WIDTH () {\n        return 100;\n    }\n\n    static get DEFAULT_HEIGHT () {\n        return 100;\n    }\n\n}\n\nmodule.exports = Comment;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/comment.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/execute.js":
/*!*******************************************!*\
  !*** ../scratch-vm/src/engine/execute.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BlockUtility = __webpack_require__(/*! ./block-utility */ \"../scratch-vm/src/engine/block-utility.js\");\nconst BlocksExecuteCache = __webpack_require__(/*! ./blocks-execute-cache */ \"../scratch-vm/src/engine/blocks-execute-cache.js\");\nconst log = __webpack_require__(/*! ../util/log */ \"../scratch-vm/src/util/log.js\");\nconst Thread = __webpack_require__(/*! ./thread */ \"../scratch-vm/src/engine/thread.js\");\nconst {Map} = __webpack_require__(/*! immutable */ \"../scratch-vm/node_modules/immutable/dist/immutable.js\");\nconst cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\n\n/**\n * Single BlockUtility instance reused by execute for every pritimive ran.\n * @const\n */\nconst blockUtility = new BlockUtility();\n\n/**\n * Profiler frame name for block functions.\n * @const {string}\n */\nconst blockFunctionProfilerFrame = 'blockFunction';\n\n/**\n * Profiler frame ID for 'blockFunction'.\n * @type {number}\n */\nlet blockFunctionProfilerId = -1;\n\n/**\n * Utility function to determine if a value is a Promise.\n * @param {*} value Value to check for a Promise.\n * @return {boolean} True if the value appears to be a Promise.\n */\nconst isPromise = function (value) {\n    return (\n        value !== null &&\n        typeof value === 'object' &&\n        typeof value.then === 'function'\n    );\n};\n\n/**\n * Handle any reported value from the primitive, either directly returned\n * or after a promise resolves.\n * @param {*} resolvedValue Value eventually returned from the primitive.\n * @param {!Sequencer} sequencer Sequencer stepping the thread for the ran\n * primitive.\n * @param {!Thread} thread Thread containing the primitive.\n * @param {!string} currentBlockId Id of the block in its thread for value from\n * the primitive.\n * @param {!string} opcode opcode used to identify a block function primitive.\n * @param {!boolean} isHat Is the current block a hat?\n */\n// @todo move this to callback attached to the thread when we have performance\n// metrics (dd)\nconst handleReport = function (resolvedValue, sequencer, thread, blockCached, lastOperation) {\n    const currentBlockId = blockCached.id;\n    const opcode = blockCached.opcode;\n    const isHat = blockCached._isHat;\n\n    thread.pushReportedValue(resolvedValue);\n    if (isHat) {\n        // Hat predicate was evaluated.\n        if (sequencer.runtime.getIsEdgeActivatedHat(opcode)) {\n            // If this is an edge-activated hat, only proceed if the value is\n            // true and used to be false, or the stack was activated explicitly\n            // via stack click\n            if (!thread.stackClick) {\n                const hasOldEdgeValue = thread.target.hasEdgeActivatedValue(currentBlockId);\n                const oldEdgeValue = thread.target.updateEdgeActivatedValue(\n                    currentBlockId,\n                    resolvedValue\n                );\n\n                const edgeWasActivated = hasOldEdgeValue ? (!oldEdgeValue && resolvedValue) : resolvedValue;\n                if (!edgeWasActivated) {\n                    sequencer.retireThread(thread);\n                }\n            }\n        } else if (!resolvedValue) {\n            // Not an edge-activated hat: retire the thread\n            // if predicate was false.\n            sequencer.retireThread(thread);\n        }\n    } else {\n        // In a non-hat, report the value visually if necessary if\n        // at the top of the thread stack.\n        if (lastOperation && typeof resolvedValue !== 'undefined' && thread.atStackTop()) {\n            if (thread.stackClick) {\n                sequencer.runtime.visualReport(currentBlockId, resolvedValue);\n            }\n            if (thread.updateMonitor) {\n                const targetId = sequencer.runtime.monitorBlocks.getBlock(currentBlockId).targetId;\n                if (targetId && !sequencer.runtime.getTargetById(targetId)) {\n                    // Target no longer exists\n                    return;\n                }\n                sequencer.runtime.requestUpdateMonitor(Map({\n                    id: currentBlockId,\n                    spriteName: targetId ? sequencer.runtime.getTargetById(targetId).getName() : null,\n                    value: resolvedValue\n                }));\n            }\n        }\n        // Finished any yields.\n        thread.status = Thread.STATUS_RUNNING;\n    }\n};\n\nconst handlePromise = (primitiveReportedValue, sequencer, thread, blockCached, lastOperation) => {\n    if (thread.status === Thread.STATUS_RUNNING) {\n        // Primitive returned a promise; automatically yield thread.\n        thread.status = Thread.STATUS_PROMISE_WAIT;\n    }\n    // Promise handlers\n    primitiveReportedValue.then(resolvedValue => {\n        handleReport(resolvedValue, sequencer, thread, blockCached, lastOperation);\n        // If it's a command block or a top level reporter in a stackClick.\n        if (lastOperation) {\n            let stackFrame;\n            let nextBlockId;\n            do {\n                // In the case that the promise is the last block in the current thread stack\n                // We need to pop out repeatedly until we find the next block.\n                const popped = thread.popStack();\n                if (popped === null) {\n                    return;\n                }\n                nextBlockId = thread.target.blocks.getNextBlock(popped);\n                if (nextBlockId !== null) {\n                    // A next block exists so break out this loop\n                    break;\n                }\n                // Investigate the next block and if not in a loop,\n                // then repeat and pop the next item off the stack frame\n                stackFrame = thread.peekStackFrame();\n            } while (stackFrame !== null && !stackFrame.isLoop);\n\n            thread.pushStack(nextBlockId);\n        }\n    }, rejectionReason => {\n        // Promise rejected: the primitive had some error.\n        // Log it and proceed.\n        log.warn('Primitive rejected promise: ', rejectionReason);\n        thread.status = Thread.STATUS_RUNNING;\n        thread.popStack();\n    });\n};\n\n/**\n * A execute.js internal representation of a block to reduce the time spent in\n * execute as the same blocks are called the most.\n *\n * With the help of the Blocks class create a mutable copy of block\n * information. The members of BlockCached derived values of block information\n * that does not need to be reevaluated until a change in Blocks. Since Blocks\n * handles where the cache instance is stored, it drops all cache versions of a\n * block when any change happens to it. This way we can quickly execute blocks\n * and keep perform the right action according to the current block information\n * in the editor.\n *\n * @param {Blocks} blockContainer the related Blocks instance\n * @param {object} cached default set of cached values\n */\nclass BlockCached {\n    constructor (blockContainer, cached) {\n        /**\n         * Block id in its parent set of blocks.\n         * @type {string}\n         */\n        this.id = cached.id;\n\n        /**\n         * Block operation code for this block.\n         * @type {string}\n         */\n        this.opcode = cached.opcode;\n\n        /**\n         * Original block object containing argument values for static fields.\n         * @type {object}\n         */\n        this.fields = cached.fields;\n\n        /**\n         * Original block object containing argument values for executable inputs.\n         * @type {object}\n         */\n        this.inputs = cached.inputs;\n\n        /**\n         * Procedure mutation.\n         * @type {?object}\n         */\n        this.mutation = cached.mutation;\n\n        /**\n         * The profiler the block is configured with.\n         * @type {?Profiler}\n         */\n        this._profiler = null;\n\n        /**\n         * Profiler information frame.\n         * @type {?ProfilerFrame}\n         */\n        this._profilerFrame = null;\n\n        /**\n         * Is the opcode a hat (event responder) block.\n         * @type {boolean}\n         */\n        this._isHat = false;\n\n        /**\n         * The block opcode's implementation function.\n         * @type {?function}\n         */\n        this._blockFunction = null;\n\n        /**\n         * Is the block function defined for this opcode?\n         * @type {boolean}\n         */\n        this._definedBlockFunction = false;\n\n        /**\n         * Is this block a block with no function but a static value to return.\n         * @type {boolean}\n         */\n        this._isShadowBlock = false;\n\n        /**\n         * The static value of this block if it is a shadow block.\n         * @type {?any}\n         */\n        this._shadowValue = null;\n\n        /**\n         * A copy of the block's fields that may be modified.\n         * @type {object}\n         */\n        this._fields = Object.assign({}, this.fields);\n\n        /**\n         * A copy of the block's inputs that may be modified.\n         * @type {object}\n         */\n        this._inputs = Object.assign({}, this.inputs);\n\n        /**\n         * An arguments object for block implementations. All executions of this\n         * specific block will use this objecct.\n         * @type {object}\n         */\n        this._argValues = {\n            mutation: this.mutation\n        };\n\n        /**\n         * The inputs key the parent refers to this BlockCached by.\n         * @type {string}\n         */\n        this._parentKey = null;\n\n        /**\n         * The target object where the parent wants the resulting value stored\n         * with _parentKey as the key.\n         * @type {object}\n         */\n        this._parentValues = null;\n\n        /**\n         * A sequence of non-shadow operations that can must be performed. This\n         * list recreates the order this block and its children are executed.\n         * Since the order is always the same we can safely store that order\n         * and iterate over the operations instead of dynamically walking the\n         * tree every time.\n         * @type {Array<BlockCached>}\n         */\n        this._ops = [];\n\n        const {runtime} = blockUtility.sequencer;\n\n        const {opcode, fields, inputs} = this;\n\n        // Assign opcode isHat and blockFunction data to avoid dynamic lookups.\n        this._isHat = runtime.getIsHat(opcode);\n        this._blockFunction = runtime.getOpcodeFunction(opcode);\n        this._definedBlockFunction = typeof this._blockFunction !== 'undefined';\n\n        // Store the current shadow value if there is a shadow value.\n        const fieldKeys = Object.keys(fields);\n        this._isShadowBlock = (\n            !this._definedBlockFunction &&\n            fieldKeys.length === 1 &&\n            Object.keys(inputs).length === 0\n        );\n        this._shadowValue = this._isShadowBlock && fields[fieldKeys[0]].value;\n\n        // Store the static fields onto _argValues.\n        for (const fieldName in fields) {\n            if (\n                fieldName === 'VARIABLE' ||\n                fieldName === 'LIST' ||\n                fieldName === 'BROADCAST_OPTION'\n            ) {\n                this._argValues[fieldName] = {\n                    id: fields[fieldName].id,\n                    name: fields[fieldName].value\n                };\n            } else {\n                this._argValues[fieldName] = fields[fieldName].value;\n            }\n        }\n\n        // Remove custom_block. It is not part of block execution.\n        delete this._inputs.custom_block;\n\n        if ('BROADCAST_INPUT' in this._inputs) {\n            // BROADCAST_INPUT is called BROADCAST_OPTION in the args and is an\n            // object with an unchanging shape.\n            this._argValues.BROADCAST_OPTION = {\n                id: null,\n                name: null\n            };\n\n            // We can go ahead and compute BROADCAST_INPUT if it is a shadow\n            // value.\n            const broadcastInput = this._inputs.BROADCAST_INPUT;\n            if (broadcastInput.block === broadcastInput.shadow) {\n                // Shadow dropdown menu is being used.\n                // Get the appropriate information out of it.\n                const shadow = blockContainer.getBlock(broadcastInput.shadow);\n                const broadcastField = shadow.fields.BROADCAST_OPTION;\n                this._argValues.BROADCAST_OPTION.id = broadcastField.id;\n                this._argValues.BROADCAST_OPTION.name = broadcastField.value;\n\n                // Evaluating BROADCAST_INPUT here we do not need to do so\n                // later.\n                delete this._inputs.BROADCAST_INPUT;\n            }\n        }\n\n        // Cache all input children blocks in the operation lists. The\n        // operations can later be run in the order they appear in correctly\n        // executing the operations quickly in a flat loop instead of needing to\n        // recursivly iterate them.\n        for (const inputName in this._inputs) {\n            const input = this._inputs[inputName];\n            if (input.block) {\n                const inputCached = BlocksExecuteCache.getCached(blockContainer, input.block, BlockCached);\n\n                if (inputCached._isHat) {\n                    continue;\n                }\n\n                this._ops.push(...inputCached._ops);\n                inputCached._parentKey = inputName;\n                inputCached._parentValues = this._argValues;\n\n                // Shadow values are static and do not change, go ahead and\n                // store their value on args.\n                if (inputCached._isShadowBlock) {\n                    this._argValues[inputName] = inputCached._shadowValue;\n                }\n            }\n        }\n\n        // The final operation is this block itself. At the top most block is a\n        // command block or a block that is being run as a monitor.\n        if (this._definedBlockFunction) {\n            this._ops.push(this);\n        }\n    }\n}\n\n/**\n * Initialize a BlockCached instance so its command/hat\n * block and reporters can be profiled during execution.\n * @param {Profiler} profiler - The profiler that is currently enabled.\n * @param {BlockCached} blockCached - The blockCached instance to profile.\n */\nconst _prepareBlockProfiling = function (profiler, blockCached) {\n    blockCached._profiler = profiler;\n\n    if (blockFunctionProfilerId === -1) {\n        blockFunctionProfilerId = profiler.idByName(blockFunctionProfilerFrame);\n    }\n\n    const ops = blockCached._ops;\n    for (let i = 0; i < ops.length; i++) {\n        ops[i]._profilerFrame = profiler.frame(blockFunctionProfilerId, ops[i].opcode);\n    }\n};\n\n/**\n * Execute a block.\n * @param {!Sequencer} sequencer Which sequencer is executing.\n * @param {!Thread} thread Thread which to read and execute.\n */\nconst execute = function (sequencer, thread) {\n    const runtime = sequencer.runtime;\n\n    // store sequencer and thread so block functions can access them through\n    // convenience methods.\n    blockUtility.sequencer = sequencer;\n    blockUtility.thread = thread;\n\n    // Current block to execute is the one on the top of the stack.\n    const currentBlockId = thread.peekStack();\n    const currentStackFrame = thread.peekStackFrame();\n\n    let blockContainer = thread.blockContainer;\n    let blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);\n    if (blockCached === null) {\n        blockContainer = runtime.flyoutBlocks;\n        blockCached = BlocksExecuteCache.getCached(blockContainer, currentBlockId, BlockCached);\n        // Stop if block or target no longer exists.\n        if (blockCached === null) {\n            // No block found: stop the thread; script no longer exists.\n            sequencer.retireThread(thread);\n            return;\n        }\n    }\n\n    const ops = blockCached._ops;\n    const length = ops.length;\n    let i = 0;\n\n    if (currentStackFrame.reported !== null) {\n        const reported = currentStackFrame.reported;\n        // Reinstate all the previous values.\n        for (; i < reported.length; i++) {\n            const {opCached: oldOpCached, inputValue} = reported[i];\n\n            const opCached = ops.find(op => op.id === oldOpCached);\n\n            if (opCached) {\n                const inputName = opCached._parentKey;\n                const argValues = opCached._parentValues;\n\n                if (inputName === 'BROADCAST_INPUT') {\n                    // Something is plugged into the broadcast input.\n                    // Cast it to a string. We don't need an id here.\n                    argValues.BROADCAST_OPTION.id = null;\n                    argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n                } else {\n                    argValues[inputName] = inputValue;\n                }\n            }\n        }\n\n        // Find the last reported block that is still in the set of operations.\n        // This way if the last operation was removed, we'll find the next\n        // candidate. If an earlier block that was performed was removed then\n        // we'll find the index where the last operation is now.\n        if (reported.length > 0) {\n            const lastExisting = reported.reverse().find(report => ops.find(op => op.id === report.opCached));\n            if (lastExisting) {\n                i = ops.findIndex(opCached => opCached.id === lastExisting.opCached) + 1;\n            } else {\n                i = 0;\n            }\n        }\n\n        // The reporting block must exist and must be the next one in the sequence of operations.\n        if (thread.justReported !== null && ops[i] && ops[i].id === currentStackFrame.reporting) {\n            const opCached = ops[i];\n            const inputValue = thread.justReported;\n\n            thread.justReported = null;\n\n            const inputName = opCached._parentKey;\n            const argValues = opCached._parentValues;\n\n            if (inputName === 'BROADCAST_INPUT') {\n                // Something is plugged into the broadcast input.\n                // Cast it to a string. We don't need an id here.\n                argValues.BROADCAST_OPTION.id = null;\n                argValues.BROADCAST_OPTION.name = cast.toString(inputValue);\n            } else {\n                argValues[inputName] = inputValue;\n            }\n\n            i += 1;\n        }\n\n        currentStackFrame.reporting = null;\n        currentStackFrame.reported = null;\n    }\n\n    const start = i;\n\n    for (; i < length; i++) {\n        const lastOperation = i === length - 1;\n        const opCached = ops[i];\n\n        const blockFunction = opCached._blockFunction;\n\n        // Update values for arguments (inputs).\n        const argValues = opCached._argValues;\n\n        // Fields are set during opCached initialization.\n\n        // Blocks should glow when a script is starting,\n        // not after it has finished (see #1404).\n        // Only blocks in blockContainers that don't forceNoGlow\n        // should request a glow.\n        if (!blockContainer.forceNoGlow) {\n            thread.requestScriptGlowInFrame = true;\n        }\n\n        // Inputs are set during previous steps in the loop.\n\n        const primitiveReportedValue = blockFunction(argValues, blockUtility);\n\n        // If it's a promise, wait until promise resolves.\n        if (isPromise(primitiveReportedValue)) {\n            handlePromise(primitiveReportedValue, sequencer, thread, opCached, lastOperation);\n\n            // Store the already reported values. They will be thawed into the\n            // future versions of the same operations by block id. The reporting\n            // operation if it is promise waiting will set its parent value at\n            // that time.\n            thread.justReported = null;\n            currentStackFrame.reporting = ops[i].id;\n            currentStackFrame.reported = ops.slice(0, i).map(reportedCached => {\n                const inputName = reportedCached._parentKey;\n                const reportedValues = reportedCached._parentValues;\n\n                if (inputName === 'BROADCAST_INPUT') {\n                    return {\n                        opCached: reportedCached.id,\n                        inputValue: reportedValues[inputName].BROADCAST_OPTION.name\n                    };\n                }\n                return {\n                    opCached: reportedCached.id,\n                    inputValue: reportedValues[inputName]\n                };\n            });\n\n            // We are waiting for a promise. Stop running this set of operations\n            // and continue them later after thawing the reported values.\n            break;\n        } else if (thread.status === Thread.STATUS_RUNNING) {\n            if (lastOperation) {\n                handleReport(primitiveReportedValue, sequencer, thread, opCached, lastOperation);\n            } else {\n                // By definition a block that is not last in the list has a\n                // parent.\n                const inputName = opCached._parentKey;\n                const parentValues = opCached._parentValues;\n\n                if (inputName === 'BROADCAST_INPUT') {\n                    // Something is plugged into the broadcast input.\n                    // Cast it to a string. We don't need an id here.\n                    parentValues.BROADCAST_OPTION.id = null;\n                    parentValues.BROADCAST_OPTION.name = cast.toString(primitiveReportedValue);\n                } else {\n                    parentValues[inputName] = primitiveReportedValue;\n                }\n            }\n        }\n    }\n\n    if (runtime.profiler !== null) {\n        if (blockCached._profiler !== runtime.profiler) {\n            _prepareBlockProfiling(runtime.profiler, blockCached);\n        }\n        // Determine the index that is after the last executed block. `i` is\n        // currently the block that was just executed. `i + 1` will be the block\n        // after that. `length` with the min call makes sure we don't try to\n        // reference an operation outside of the set of operations.\n        const end = Math.min(i + 1, length);\n        for (let p = start; p < end; p++) {\n            ops[p]._profilerFrame.count += 1;\n        }\n    }\n};\n\nmodule.exports = execute;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/execute.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/monitor-record.js":
/*!**************************************************!*\
  !*** ../scratch-vm/src/engine/monitor-record.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {Record} = __webpack_require__(/*! immutable */ \"../scratch-vm/node_modules/immutable/dist/immutable.js\");\n\nconst MonitorRecord = Record({\n    id: null, // Block Id\n    /** Present only if the monitor is sprite-specific, such as x position */\n    spriteName: null,\n    /** Present only if the monitor is sprite-specific, such as x position */\n    targetId: null,\n    opcode: null,\n    value: null,\n    params: null,\n    mode: 'default',\n    sliderMin: 0,\n    sliderMax: 100,\n    isDiscrete: true,\n    x: null, // (x: null, y: null) Indicates that the monitor should be auto-positioned\n    y: null,\n    width: 0,\n    height: 0,\n    visible: true\n});\n\nmodule.exports = MonitorRecord;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/monitor-record.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/mutation-adapter.js":
/*!****************************************************!*\
  !*** ../scratch-vm/src/engine/mutation-adapter.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const html = __webpack_require__(/*! htmlparser2 */ \"../scratch-vm/node_modules/htmlparser2/lib/index.js\");\nconst decodeHtml = __webpack_require__(/*! decode-html */ \"../scratch-vm/node_modules/decode-html/index.js\");\n\n/**\n * Convert a part of a mutation DOM to a mutation VM object, recursively.\n * @param {object} dom DOM object for mutation tag.\n * @return {object} Object representing useful parts of this mutation.\n */\nconst mutatorTagToObject = function (dom) {\n    const obj = Object.create(null);\n    obj.tagName = dom.name;\n    obj.children = [];\n    for (const prop in dom.attribs) {\n        if (prop === 'xmlns') continue;\n        obj[prop] = decodeHtml(dom.attribs[prop]);\n        // Note: the capitalization of block info in the following lines is important.\n        // The lowercase is read in from xml which normalizes case. The VM uses camel case everywhere else.\n        if (prop === 'blockinfo') {\n            obj.blockInfo = JSON.parse(obj.blockinfo);\n            delete obj.blockinfo;\n        }\n    }\n    for (let i = 0; i < dom.children.length; i++) {\n        obj.children.push(\n            mutatorTagToObject(dom.children[i])\n        );\n    }\n    return obj;\n};\n\n/**\n * Adapter between mutator XML or DOM and block representation which can be\n * used by the Scratch runtime.\n * @param {(object|string)} mutation Mutation XML string or DOM.\n * @return {object} Object representing the mutation.\n */\nconst mutationAdpater = function (mutation) {\n    let mutationParsed;\n    // Check if the mutation is already parsed; if not, parse it.\n    if (typeof mutation === 'object') {\n        mutationParsed = mutation;\n    } else {\n        mutationParsed = html.parseDOM(mutation)[0];\n    }\n    return mutatorTagToObject(mutationParsed);\n};\n\nmodule.exports = mutationAdpater;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/mutation-adapter.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/profiler.js":
/*!********************************************!*\
  !*** ../scratch-vm/src/engine/profiler.js ***!
  \********************************************/
/***/ ((module) => {

eval("/**\n * @fileoverview\n * A way to profile Scratch internal performance. Like what blocks run during a\n * step? How much time do they take? How much time is spent inbetween blocks?\n *\n * Profiler aims for to spend as little time inside its functions while\n * recording. For this it has a simple internal record structure that records a\n * series of values for each START and STOP event in a single array. This lets\n * all the values be pushed in one call for the array. This simplicity allows\n * the contents of the start() and stop() calls to be inlined in areas that are\n * called frequently enough to want even greater performance from Profiler so\n * what is recorded better reflects on the profiled code and not Profiler\n * itself.\n */\n\n/**\n * The next id returned for a new profile'd function.\n * @type {number}\n */\nlet nextId = 0;\n\n/**\n * The mapping of names to ids.\n * @const {Object.<string, number>}\n */\nconst profilerNames = {};\n\n/**\n * The START event identifier in Profiler records.\n * @const {number}\n */\nconst START = 0;\n\n/**\n * The STOP event identifier in Profiler records.\n * @const {number}\n */\nconst STOP = 1;\n\n/**\n * The number of cells used in the records array by a START event.\n * @const {number}\n */\nconst START_SIZE = 4;\n\n/**\n * The number of cells used in the records array by a STOP event.\n * @const {number}\n */\nconst STOP_SIZE = 2;\n\n/**\n * Stored reference to Performance instance provided by the Browser.\n * @const {Performance}\n */\nconst performance = typeof window === 'object' && window.performance;\n\n\n/**\n * Callback handle called by Profiler for each frame it decodes from its\n * records.\n * @callback FrameCallback\n * @param {ProfilerFrame} frame\n */\n\n/**\n * A set of information about a frame of execution that was recorded.\n */\nclass ProfilerFrame {\n    /**\n     * @param {number} depth Depth of the frame in the recorded stack.\n     */\n    constructor (depth) {\n        /**\n         * The numeric id of a record symbol like Runtime._step or\n         * blockFunction.\n         * @type {number}\n         */\n        this.id = -1;\n\n        /**\n         * The amount of time spent inside the recorded frame and any deeper\n         * frames.\n         * @type {number}\n         */\n        this.totalTime = 0;\n\n        /**\n         * The amount of time spent only inside this record frame. Not\n         * including time in any deeper frames.\n         * @type {number}\n         */\n        this.selfTime = 0;\n\n        /**\n         * An arbitrary argument for the recorded frame. For example a block\n         * function might record its opcode as an argument.\n         * @type {*}\n         */\n        this.arg = null;\n\n        /**\n         * The depth of the recorded frame. This can help compare recursive\n         * funtions that are recorded. Each level of recursion with have a\n         * different depth value.\n         * @type {number}\n         */\n        this.depth = depth;\n\n        /**\n         * A summarized count of the number of calls to this frame.\n         * @type {number}\n         */\n        this.count = 0;\n    }\n}\n\nclass Profiler {\n    /**\n     * @param {FrameCallback} onFrame a handle called for each recorded frame.\n     * The passed frame value may not be stored as it'll be updated with later\n     * frame information. Any information that is further stored by the handler\n     * should make copies or reduce the information.\n     */\n    constructor (onFrame = function () {}) {\n        /**\n         * A series of START and STOP values followed by arguments. After\n         * recording is complete the full set of records is reported back by\n         * stepping through the series to connect the relative START and STOP\n         * information.\n         * @type {Array.<*>}\n         */\n        this.records = [];\n\n        /**\n         * An array of frames incremented on demand instead as part of start\n         * and stop.\n         * @type {Array.<ProfilerFrame>}\n         */\n        this.increments = [];\n\n        /**\n         * An array of profiler frames separated by counter argument. Generally\n         * for Scratch these frames are separated by block function opcode.\n         * This tracks each time an opcode is called.\n         * @type {Array.<ProfilerFrame>}\n         */\n        this.counters = [];\n\n        /**\n         * A frame with no id or argument.\n         * @type {ProfilerFrame}\n         */\n        this.nullFrame = new ProfilerFrame(-1);\n\n        /**\n         * A cache of ProfilerFrames to reuse when reporting the recorded\n         * frames in records.\n         * @type {Array.<ProfilerFrame>}\n         */\n        this._stack = [new ProfilerFrame(0)];\n\n        /**\n         * A callback handle called with each decoded frame when reporting back\n         * all the recorded times.\n         * @type {FrameCallback}\n         */\n        this.onFrame = onFrame;\n\n        /**\n         * A reference to the START record id constant.\n         * @const {number}\n         */\n        this.START = START;\n\n        /**\n         * A reference to the STOP record id constant.\n         * @const {number}\n         */\n        this.STOP = STOP;\n    }\n\n    /**\n     * Start recording a frame of time for an id and optional argument.\n     * @param {number} id The id returned by idByName for a name symbol like\n     * Runtime._step.\n     * @param {?*} arg An arbitrary argument value to store with the frame.\n     */\n    start (id, arg) {\n        this.records.push(START, id, arg, performance.now());\n    }\n\n    /**\n     * Stop the current frame.\n     */\n    stop () {\n        this.records.push(STOP, performance.now());\n    }\n\n    /**\n     * Increment the number of times this symbol is called.\n     * @param {number} id The id returned by idByName for a name symbol.\n     */\n    increment (id) {\n        if (!this.increments[id]) {\n            this.increments[id] = new ProfilerFrame(-1);\n            this.increments[id].id = id;\n        }\n        this.increments[id].count += 1;\n    }\n\n    /**\n     * Find or create a ProfilerFrame-like object whose counter can be\n     * incremented outside of the Profiler.\n     * @param {number} id The id returned by idByName for a name symbol.\n     * @param {*} arg The argument for a frame that identifies it in addition\n     *   to the id.\n     * @return {{count: number}} A ProfilerFrame-like whose count should be\n     *   incremented for each call.\n     */\n    frame (id, arg) {\n        for (let i = 0; i < this.counters.length; i++) {\n            if (this.counters[i].id === id && this.counters[i].arg === arg) {\n                return this.counters[i];\n            }\n        }\n\n        const newCounter = new ProfilerFrame(-1);\n        newCounter.id = id;\n        newCounter.arg = arg;\n        this.counters.push(newCounter);\n        return newCounter;\n    }\n\n    /**\n     * Decode records and report all frames to `this.onFrame`.\n     */\n    reportFrames () {\n        const stack = this._stack;\n        let depth = 1;\n\n        // Step through the records and initialize Frame instances from the\n        // START and STOP events. START and STOP events are separated by events\n        // for deeper frames run by higher frames. Frames are stored on a stack\n        // and reinitialized for each START event. When a stop event is reach\n        // the Frame for the current depth has its final values stored and its\n        // passed to the current onFrame callback. This way Frames are \"pushed\"\n        // for each START event and \"popped\" for each STOP and handed to an\n        // outside handle to any desired reduction of the collected data.\n        for (let i = 0; i < this.records.length;) {\n            if (this.records[i] === START) {\n                if (depth >= stack.length) {\n                    stack.push(new ProfilerFrame(depth));\n                }\n\n                // Store id, arg, totalTime, and initialize selfTime.\n                const frame = stack[depth++];\n                frame.id = this.records[i + 1];\n                frame.arg = this.records[i + 2];\n                // totalTime is first set as the time recorded by this START\n                // event. Once the STOP event is reached the stored start time\n                // is subtracted from the recorded stop time. The resulting\n                // difference is the actual totalTime, and replaces the start\n                // time in frame.totalTime.\n                //\n                // totalTime is used this way as a convenient member to store a\n                // value between the two events without needing additional\n                // members on the Frame or in a shadow map.\n                frame.totalTime = this.records[i + 3];\n                // selfTime is decremented until we reach the STOP event for\n                // this frame. totalTime will be added to it then to get the\n                // time difference.\n                frame.selfTime = 0;\n\n                i += START_SIZE;\n            } else if (this.records[i] === STOP) {\n                const now = this.records[i + 1];\n\n                const frame = stack[--depth];\n                // totalTime is the difference between the start event time\n                // stored in totalTime and the stop event time pulled from this\n                // record.\n                frame.totalTime = now - frame.totalTime;\n                // selfTime is the difference of this frame's totalTime and the\n                // sum of totalTime of deeper frames.\n                frame.selfTime += frame.totalTime;\n\n                // Remove this frames totalTime from the parent's selfTime.\n                stack[depth - 1].selfTime -= frame.totalTime;\n\n                // This frame occured once.\n                frame.count = 1;\n\n                this.onFrame(frame);\n\n                i += STOP_SIZE;\n            } else {\n                this.records.length = 0;\n                throw new Error('Unable to decode Profiler records.');\n            }\n        }\n\n        for (let j = 0; j < this.increments.length; j++) {\n            if (this.increments[j] && this.increments[j].count > 0) {\n                this.onFrame(this.increments[j]);\n                this.increments[j].count = 0;\n            }\n        }\n\n        for (let k = 0; k < this.counters.length; k++) {\n            if (this.counters[k].count > 0) {\n                this.onFrame(this.counters[k]);\n                this.counters[k].count = 0;\n            }\n        }\n\n        this.records.length = 0;\n    }\n\n    /**\n     * Lookup or create an id for a frame name.\n     * @param {string} name The name to return an id for.\n     * @return {number} The id for the passed name.\n     */\n    idByName (name) {\n        return Profiler.idByName(name);\n    }\n\n    /**\n     * Reverse lookup the name from a given frame id.\n     * @param {number} id The id to search for.\n     * @return {string} The name for the given id.\n     */\n    nameById (id) {\n        return Profiler.nameById(id);\n    }\n\n    /**\n     * Lookup or create an id for a frame name.\n     * @static\n     * @param {string} name The name to return an id for.\n     * @return {number} The id for the passed name.\n     */\n    static idByName (name) {\n        if (typeof profilerNames[name] !== 'number') {\n            profilerNames[name] = nextId++;\n        }\n        return profilerNames[name];\n    }\n\n    /**\n     * Reverse lookup the name from a given frame id.\n     * @static\n     * @param {number} id The id to search for.\n     * @return {string} The name for the given id.\n     */\n    static nameById (id) {\n        for (const name in profilerNames) {\n            if (profilerNames[name] === id) {\n                return name;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Profiler is only available on platforms with the Performance API.\n     * @return {boolean} Can the Profiler run in this browser?\n     */\n    static available () {\n        return (\n            typeof window === 'object' &&\n            typeof window.performance !== 'undefined');\n    }\n}\n\n\n/**\n * A reference to the START record id constant.\n * @const {number}\n */\nProfiler.START = START;\n\n/**\n * A reference to the STOP record id constant.\n * @const {number}\n */\nProfiler.STOP = STOP;\n\nmodule.exports = Profiler;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/profiler.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/runtime.js":
/*!*******************************************!*\
  !*** ../scratch-vm/src/engine/runtime.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst {OrderedMap} = __webpack_require__(/*! immutable */ \"../scratch-vm/node_modules/immutable/dist/immutable.js\");\nconst uuid = __webpack_require__(/*! uuid */ \"../scratch-vm/node_modules/uuid/dist/esm-node/index.js\");\n\nconst ArgumentType = __webpack_require__(/*! ../extension-support/argument-type */ \"../scratch-vm/src/extension-support/argument-type.js\");\nconst Blocks = __webpack_require__(/*! ./blocks */ \"../scratch-vm/src/engine/blocks.js\");\nconst BlocksRuntimeCache = __webpack_require__(/*! ./blocks-runtime-cache */ \"../scratch-vm/src/engine/blocks-runtime-cache.js\");\nconst BlockType = __webpack_require__(/*! ../extension-support/block-type */ \"../scratch-vm/src/extension-support/block-type.js\");\nconst Profiler = __webpack_require__(/*! ./profiler */ \"../scratch-vm/src/engine/profiler.js\");\nconst Sequencer = __webpack_require__(/*! ./sequencer */ \"../scratch-vm/src/engine/sequencer.js\");\nconst execute = __webpack_require__(/*! ./execute.js */ \"../scratch-vm/src/engine/execute.js\");\nconst ScratchBlocksConstants = __webpack_require__(/*! ./scratch-blocks-constants */ \"../scratch-vm/src/engine/scratch-blocks-constants.js\");\nconst TargetType = __webpack_require__(/*! ../extension-support/target-type */ \"../scratch-vm/src/extension-support/target-type.js\");\nconst Thread = __webpack_require__(/*! ./thread */ \"../scratch-vm/src/engine/thread.js\");\nconst log = __webpack_require__(/*! ../util/log */ \"../scratch-vm/src/util/log.js\");\nconst maybeFormatMessage = __webpack_require__(/*! ../util/maybe-format-message */ \"../scratch-vm/src/util/maybe-format-message.js\");\nconst StageLayering = __webpack_require__(/*! ./stage-layering */ \"../scratch-vm/src/engine/stage-layering.js\");\nconst Variable = __webpack_require__(/*! ./variable */ \"../scratch-vm/src/engine/variable.js\");\nconst xmlEscape = __webpack_require__(/*! ../util/xml-escape */ \"../scratch-vm/src/util/xml-escape.js\");\nconst ScratchLinkWebSocket = __webpack_require__(/*! ../util/scratch-link-websocket */ \"../scratch-vm/src/util/scratch-link-websocket.js\");\nconst fetchWithTimeout = __webpack_require__(/*! ../util/fetch-with-timeout */ \"../scratch-vm/src/util/fetch-with-timeout.js\");\n\n// Virtual I/O devices.\nconst Clock = __webpack_require__(/*! ../io/clock */ \"../scratch-vm/src/io/clock.js\");\nconst Cloud = __webpack_require__(/*! ../io/cloud */ \"../scratch-vm/src/io/cloud.js\");\nconst Keyboard = __webpack_require__(/*! ../io/keyboard */ \"../scratch-vm/src/io/keyboard.js\");\nconst Mouse = __webpack_require__(/*! ../io/mouse */ \"../scratch-vm/src/io/mouse.js\");\nconst MouseWheel = __webpack_require__(/*! ../io/mouseWheel */ \"../scratch-vm/src/io/mouseWheel.js\");\nconst UserData = __webpack_require__(/*! ../io/userData */ \"../scratch-vm/src/io/userData.js\");\nconst Video = __webpack_require__(/*! ../io/video */ \"../scratch-vm/src/io/video.js\");\n\nconst StringUtil = __webpack_require__(/*! ../util/string-util */ \"../scratch-vm/src/util/string-util.js\");\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\n\nconst defaultBlockPackages = {\n    scratch3_control: __webpack_require__(/*! ../blocks/scratch3_control */ \"../scratch-vm/src/blocks/scratch3_control.js\"),\n    scratch3_event: __webpack_require__(/*! ../blocks/scratch3_event */ \"../scratch-vm/src/blocks/scratch3_event.js\"),\n    scratch3_looks: __webpack_require__(/*! ../blocks/scratch3_looks */ \"../scratch-vm/src/blocks/scratch3_looks.js\"),\n    scratch3_motion: __webpack_require__(/*! ../blocks/scratch3_motion */ \"../scratch-vm/src/blocks/scratch3_motion.js\"),\n    scratch3_operators: __webpack_require__(/*! ../blocks/scratch3_operators */ \"../scratch-vm/src/blocks/scratch3_operators.js\"),\n    scratch3_sound: __webpack_require__(/*! ../blocks/scratch3_sound */ \"../scratch-vm/src/blocks/scratch3_sound.js\"),\n    scratch3_sensing: __webpack_require__(/*! ../blocks/scratch3_sensing */ \"../scratch-vm/src/blocks/scratch3_sensing.js\"),\n    scratch3_data: __webpack_require__(/*! ../blocks/scratch3_data */ \"../scratch-vm/src/blocks/scratch3_data.js\"),\n    scratch3_procedures: __webpack_require__(/*! ../blocks/scratch3_procedures */ \"../scratch-vm/src/blocks/scratch3_procedures.js\")\n};\n\nconst defaultExtensionColors = ['#0FBD8C', '#0DA57A', '#0B8E69'];\n\n/**\n * Information used for converting Scratch argument types into scratch-blocks data.\n * @type {object.<ArgumentType, {shadowType: string, fieldType: string}>}\n */\nconst ArgumentTypeMap = (() => {\n    const map = {};\n    map[ArgumentType.ANGLE] = {\n        shadow: {\n            type: 'math_angle',\n            // We specify fieldNames here so that we can pick\n            // create and populate a field with the defaultValue\n            // specified in the extension.\n            // When the `fieldName` property is not specified,\n            // the <field></field> will be left out of the XML and\n            // the scratch-blocks defaults for that field will be\n            // used instead (e.g. default of 0 for number fields)\n            fieldName: 'NUM'\n        }\n    };\n    map[ArgumentType.COLOR] = {\n        shadow: {\n            type: 'colour_picker',\n            fieldName: 'COLOUR'\n        }\n    };\n    map[ArgumentType.NUMBER] = {\n        shadow: {\n            type: 'math_number',\n            fieldName: 'NUM'\n        }\n    };\n    map[ArgumentType.STRING] = {\n        shadow: {\n            type: 'text',\n            fieldName: 'TEXT'\n        }\n    };\n    map[ArgumentType.BOOLEAN] = {\n        check: 'Boolean'\n    };\n    map[ArgumentType.MATRIX] = {\n        shadow: {\n            type: 'matrix',\n            fieldName: 'MATRIX'\n        }\n    };\n    map[ArgumentType.NOTE] = {\n        shadow: {\n            type: 'note',\n            fieldName: 'NOTE'\n        }\n    };\n    map[ArgumentType.IMAGE] = {\n        // Inline images are weird because they're not actually \"arguments\".\n        // They are more analagous to the label on a block.\n        fieldType: 'field_image'\n    };\n    return map;\n})();\n\n/**\n * A pair of functions used to manage the cloud variable limit,\n * to be used when adding (or attempting to add) or removing a cloud variable.\n * @typedef {object} CloudDataManager\n * @property {function} canAddCloudVariable A function to call to check that\n * a cloud variable can be added.\n * @property {function} addCloudVariable A function to call to track a new\n * cloud variable on the runtime.\n * @property {function} removeCloudVariable A function to call when\n * removing an existing cloud variable.\n * @property {function} hasCloudVariables A function to call to check that\n * the runtime has any cloud variables.\n */\n\n/**\n * Creates and manages cloud variable limit in a project,\n * and returns two functions to be used to add a new\n * cloud variable (while checking that it can be added)\n * and remove an existing cloud variable.\n * These are to be called whenever attempting to create or delete\n * a cloud variable.\n * @return {CloudDataManager} The functions to be used when adding or removing a\n * cloud variable.\n */\nconst cloudDataManager = () => {\n    const limit = 10;\n    let count = 0;\n\n    const canAddCloudVariable = () => count < limit;\n\n    const addCloudVariable = () => {\n        count++;\n    };\n\n    const removeCloudVariable = () => {\n        count--;\n    };\n\n    const hasCloudVariables = () => count > 0;\n\n    return {\n        canAddCloudVariable,\n        addCloudVariable,\n        removeCloudVariable,\n        hasCloudVariables\n    };\n};\n\n/**\n * Numeric ID for Runtime._step in Profiler instances.\n * @type {number}\n */\nlet stepProfilerId = -1;\n\n/**\n * Numeric ID for Sequencer.stepThreads in Profiler instances.\n * @type {number}\n */\nlet stepThreadsProfilerId = -1;\n\n/**\n * Numeric ID for RenderWebGL.draw in Profiler instances.\n * @type {number}\n */\nlet rendererDrawProfilerId = -1;\n\n/**\n * Manages targets, scripts, and the sequencer.\n * @constructor\n */\nclass Runtime extends EventEmitter {\n    constructor () {\n        super();\n\n        /**\n         * Target management and storage.\n         * @type {Array.<!Target>}\n         */\n        this.targets = [];\n\n        /**\n         * Targets in reverse order of execution. Shares its order with drawables.\n         * @type {Array.<!Target>}\n         */\n        this.executableTargets = [];\n\n        /**\n         * A list of threads that are currently running in the VM.\n         * Threads are added when execution starts and pruned when execution ends.\n         * @type {Array.<Thread>}\n         */\n        this.threads = [];\n\n        /** @type {!Sequencer} */\n        this.sequencer = new Sequencer(this);\n\n        /**\n         * Storage container for flyout blocks.\n         * These will execute on `_editingTarget.`\n         * @type {!Blocks}\n         */\n        this.flyoutBlocks = new Blocks(this, true /* force no glow */);\n\n        /**\n         * Storage container for monitor blocks.\n         * These will execute on a target maybe\n         * @type {!Blocks}\n         */\n        this.monitorBlocks = new Blocks(this, true /* force no glow */);\n\n        /**\n         * Currently known editing target for the VM.\n         * @type {?Target}\n         */\n        this._editingTarget = null;\n\n        /**\n         * Map to look up a block primitive's implementation function by its opcode.\n         * This is a two-step lookup: package name first, then primitive name.\n         * @type {Object.<string, Function>}\n         */\n        this._primitives = {};\n\n        /**\n         * Map to look up all block information by extended opcode.\n         * @type {Array.<CategoryInfo>}\n         * @private\n         */\n        this._blockInfo = [];\n\n        /**\n         * Map to look up hat blocks' metadata.\n         * Keys are opcode for hat, values are metadata objects.\n         * @type {Object.<string, Object>}\n         */\n        this._hats = {};\n\n        /**\n         * A list of script block IDs that were glowing during the previous frame.\n         * @type {!Array.<!string>}\n         */\n        this._scriptGlowsPreviousFrame = [];\n\n        /**\n         * Number of non-monitor threads running during the previous frame.\n         * @type {number}\n         */\n        this._nonMonitorThreadCount = 0;\n\n        /**\n         * All threads that finished running and were removed from this.threads\n         * by behaviour in Sequencer.stepThreads.\n         * @type {Array<Thread>}\n         */\n        this._lastStepDoneThreads = null;\n\n        /**\n         * Currently known number of clones, used to enforce clone limit.\n         * @type {number}\n         */\n        this._cloneCounter = 0;\n\n        /**\n         * Flag to emit a targets update at the end of a step. When target data\n         * changes, this flag is set to true.\n         * @type {boolean}\n         */\n        this._refreshTargets = false;\n\n        /**\n         * Map to look up all monitor block information by opcode.\n         * @type {object}\n         * @private\n         */\n        this.monitorBlockInfo = {};\n\n        /**\n         * Ordered map of all monitors, which are MonitorReporter objects.\n         */\n        this._monitorState = OrderedMap({});\n\n        /**\n         * Monitor state from last tick\n         */\n        this._prevMonitorState = OrderedMap({});\n\n        /**\n         * Whether the project is in \"turbo mode.\"\n         * @type {Boolean}\n         */\n        this.turboMode = false;\n\n        /**\n         * Whether the project is in \"compatibility mode\" (30 TPS).\n         * @type {Boolean}\n         */\n        this.compatibilityMode = false;\n\n        /**\n         * A reference to the current runtime stepping interval, set\n         * by a `setInterval`.\n         * @type {!number}\n         */\n        this._steppingInterval = null;\n\n        /**\n         * Current length of a step.\n         * Changes as mode switches, and used by the sequencer to calculate\n         * WORK_TIME.\n         * @type {!number}\n         */\n        this.currentStepTime = null;\n\n        // Set an intial value for this.currentMSecs\n        this.updateCurrentMSecs();\n\n        /**\n         * Whether any primitive has requested a redraw.\n         * Affects whether `Sequencer.stepThreads` will yield\n         * after stepping each thread.\n         * Reset on every frame.\n         * @type {boolean}\n         */\n        this.redrawRequested = false;\n\n        // Register all given block packages.\n        this._registerBlockPackages();\n\n        // Register and initialize \"IO devices\", containers for processing\n        // I/O related data.\n        /** @type {Object.<string, Object>} */\n        this.ioDevices = {\n            clock: new Clock(this),\n            cloud: new Cloud(this),\n            keyboard: new Keyboard(this),\n            mouse: new Mouse(this),\n            mouseWheel: new MouseWheel(this),\n            userData: new UserData(),\n            video: new Video(this)\n        };\n\n        /**\n         * A list of extensions, used to manage hardware connection.\n         */\n        this.peripheralExtensions = {};\n\n        /**\n         * A runtime profiler that records timed events for later playback to\n         * diagnose Scratch performance.\n         * @type {Profiler}\n         */\n        this.profiler = null;\n\n        const newCloudDataManager = cloudDataManager();\n\n        /**\n         * Check wether the runtime has any cloud data.\n         * @type {function}\n         * @return {boolean} Whether or not the runtime currently has any\n         * cloud variables.\n         */\n        this.hasCloudData = newCloudDataManager.hasCloudVariables;\n\n        /**\n         * A function which checks whether a new cloud variable can be added\n         * to the runtime.\n         * @type {function}\n         * @return {boolean} Whether or not a new cloud variable can be added\n         * to the runtime.\n         */\n        this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n\n        /**\n         * A function that tracks a new cloud variable in the runtime,\n         * updating the cloud variable limit. Calling this function will\n         * emit a cloud data update event if this is the first cloud variable\n         * being added.\n         * @type {function}\n         */\n        this.addCloudVariable =\n            this._initializeAddCloudVariable(newCloudDataManager);\n\n        /**\n         * A function which updates the runtime's cloud variable limit\n         * when removing a cloud variable and emits a cloud update event\n         * if the last of the cloud variables is being removed.\n         * @type {function}\n         */\n        this.removeCloudVariable =\n            this._initializeRemoveCloudVariable(newCloudDataManager);\n\n        /**\n         * A string representing the origin of the current project from outside of the\n         * Scratch community, such as CSFirst.\n         * @type {?string}\n         */\n        this.origin = null;\n\n        this._initScratchLink();\n\n        this.resetRunId();\n    }\n\n    /**\n     * Width of the stage, in pixels.\n     * @const {number}\n     */\n    static get STAGE_WIDTH () {\n        return 480;\n    }\n\n    /**\n     * Height of the stage, in pixels.\n     * @const {number}\n     */\n    static get STAGE_HEIGHT () {\n        return 360;\n    }\n\n    /**\n     * Event name for glowing a script.\n     * @const {string}\n     */\n    static get SCRIPT_GLOW_ON () {\n        return 'SCRIPT_GLOW_ON';\n    }\n\n    /**\n     * Event name for unglowing a script.\n     * @const {string}\n     */\n    static get SCRIPT_GLOW_OFF () {\n        return 'SCRIPT_GLOW_OFF';\n    }\n\n    /**\n     * Event name for glowing a block.\n     * @const {string}\n     */\n    static get BLOCK_GLOW_ON () {\n        return 'BLOCK_GLOW_ON';\n    }\n\n    /**\n     * Event name for unglowing a block.\n     * @const {string}\n     */\n    static get BLOCK_GLOW_OFF () {\n        return 'BLOCK_GLOW_OFF';\n    }\n\n    /**\n     * Event name for a cloud data update\n     * to this project.\n     * @const {string}\n     */\n    static get HAS_CLOUD_DATA_UPDATE () {\n        return 'HAS_CLOUD_DATA_UPDATE';\n    }\n\n    /**\n     * Event name for turning on turbo mode.\n     * @const {string}\n     */\n    static get TURBO_MODE_ON () {\n        return 'TURBO_MODE_ON';\n    }\n\n    /**\n     * Event name for turning off turbo mode.\n     * @const {string}\n     */\n    static get TURBO_MODE_OFF () {\n        return 'TURBO_MODE_OFF';\n    }\n\n    /**\n     * Event name when the project is started (threads may not necessarily be\n     * running).\n     * @const {string}\n     */\n    static get PROJECT_START () {\n        return 'PROJECT_START';\n    }\n\n    /**\n     * Event name when threads start running.\n     * Used by the UI to indicate running status.\n     * @const {string}\n     */\n    static get PROJECT_RUN_START () {\n        return 'PROJECT_RUN_START';\n    }\n\n    /**\n     * Event name when threads stop running\n     * Used by the UI to indicate not-running status.\n     * @const {string}\n     */\n    static get PROJECT_RUN_STOP () {\n        return 'PROJECT_RUN_STOP';\n    }\n\n    /**\n     * Event name for project being stopped or restarted by the user.\n     * Used by blocks that need to reset state.\n     * @const {string}\n     */\n    static get PROJECT_STOP_ALL () {\n        return 'PROJECT_STOP_ALL';\n    }\n\n    /**\n     * Event name for target being stopped by a stop for target call.\n     * Used by blocks that need to stop individual targets.\n     * @const {string}\n     */\n    static get STOP_FOR_TARGET () {\n        return 'STOP_FOR_TARGET';\n    }\n\n    /**\n     * Event name for visual value report.\n     * @const {string}\n     */\n    static get VISUAL_REPORT () {\n        return 'VISUAL_REPORT';\n    }\n\n    /**\n     * Event name for project loaded report.\n     * @const {string}\n     */\n    static get PROJECT_LOADED () {\n        return 'PROJECT_LOADED';\n    }\n\n    /**\n     * Event name for report that a change was made that can be saved\n     * @const {string}\n     */\n    static get PROJECT_CHANGED () {\n        return 'PROJECT_CHANGED';\n    }\n\n    /**\n     * Event name for report that a change was made to an extension in the toolbox.\n     * @const {string}\n     */\n    static get TOOLBOX_EXTENSIONS_NEED_UPDATE () {\n        return 'TOOLBOX_EXTENSIONS_NEED_UPDATE';\n    }\n\n    /**\n     * Event name for targets update report.\n     * @const {string}\n     */\n    static get TARGETS_UPDATE () {\n        return 'TARGETS_UPDATE';\n    }\n\n    /**\n     * Event name for monitors update.\n     * @const {string}\n     */\n    static get MONITORS_UPDATE () {\n        return 'MONITORS_UPDATE';\n    }\n\n    /**\n     * Event name for block drag update.\n     * @const {string}\n     */\n    static get BLOCK_DRAG_UPDATE () {\n        return 'BLOCK_DRAG_UPDATE';\n    }\n\n    /**\n     * Event name for block drag end.\n     * @const {string}\n     */\n    static get BLOCK_DRAG_END () {\n        return 'BLOCK_DRAG_END';\n    }\n\n    /**\n     * Event name for reporting that an extension was added.\n     * @const {string}\n     */\n    static get EXTENSION_ADDED () {\n        return 'EXTENSION_ADDED';\n    }\n\n    /**\n     * Event name for reporting that an extension as asked for a custom field to be added\n     * @const {string}\n     */\n    static get EXTENSION_FIELD_ADDED () {\n        return 'EXTENSION_FIELD_ADDED';\n    }\n\n    /**\n     * Event name for updating the available set of peripheral devices.\n     * This causes the peripheral connection modal to update a list of\n     * available peripherals.\n     * @const {string}\n     */\n    static get PERIPHERAL_LIST_UPDATE () {\n        return 'PERIPHERAL_LIST_UPDATE';\n    }\n\n    /**\n     * Event name for when the user picks a bluetooth device to connect to\n     * via Companion Device Manager (CDM)\n     * @const {string}\n     */\n    static get USER_PICKED_PERIPHERAL () {\n        return 'USER_PICKED_PERIPHERAL';\n    }\n\n    /**\n     * Event name for reporting that a peripheral has connected.\n     * This causes the status button in the blocks menu to indicate 'connected'.\n     * @const {string}\n     */\n    static get PERIPHERAL_CONNECTED () {\n        return 'PERIPHERAL_CONNECTED';\n    }\n\n    /**\n     * Event name for reporting that a peripheral has been intentionally disconnected.\n     * This causes the status button in the blocks menu to indicate 'disconnected'.\n     * @const {string}\n     */\n    static get PERIPHERAL_DISCONNECTED () {\n        return 'PERIPHERAL_DISCONNECTED';\n    }\n\n    /**\n     * Event name for reporting that a peripheral has encountered a request error.\n     * This causes the peripheral connection modal to switch to an error state.\n     * @const {string}\n     */\n    static get PERIPHERAL_REQUEST_ERROR () {\n        return 'PERIPHERAL_REQUEST_ERROR';\n    }\n\n    /**\n     * Event name for reporting that a peripheral connection has been lost.\n     * This causes a 'peripheral connection lost' error alert to display.\n     * @const {string}\n     */\n    static get PERIPHERAL_CONNECTION_LOST_ERROR () {\n        return 'PERIPHERAL_CONNECTION_LOST_ERROR';\n    }\n\n    /**\n     * Event name for reporting that a peripheral has not been discovered.\n     * This causes the peripheral connection modal to show a timeout state.\n     * @const {string}\n     */\n    static get PERIPHERAL_SCAN_TIMEOUT () {\n        return 'PERIPHERAL_SCAN_TIMEOUT';\n    }\n\n    /**\n     * Event name to indicate that the microphone is being used to stream audio.\n     * @const {string}\n     */\n    static get MIC_LISTENING () {\n        return 'MIC_LISTENING';\n    }\n\n    /**\n     * Event name for reporting that blocksInfo was updated.\n     * @const {string}\n     */\n    static get BLOCKSINFO_UPDATE () {\n        return 'BLOCKSINFO_UPDATE';\n    }\n\n    /**\n     * Event name when the runtime tick loop has been started.\n     * @const {string}\n     */\n    static get RUNTIME_STARTED () {\n        return 'RUNTIME_STARTED';\n    }\n\n    /**\n     * Event name when the runtime dispose has been called.\n     * @const {string}\n     */\n    static get RUNTIME_DISPOSED () {\n        return 'RUNTIME_DISPOSED';\n    }\n\n    /**\n     * Event name for reporting that a block was updated and needs to be rerendered.\n     * @const {string}\n     */\n    static get BLOCKS_NEED_UPDATE () {\n        return 'BLOCKS_NEED_UPDATE';\n    }\n\n    /**\n     * How rapidly we try to step threads by default, in ms.\n     */\n    static get THREAD_STEP_INTERVAL () {\n        return 1000 / 60;\n    }\n\n    /**\n     * In compatibility mode, how rapidly we try to step threads, in ms.\n     */\n    static get THREAD_STEP_INTERVAL_COMPATIBILITY () {\n        return 1000 / 30;\n    }\n\n    /**\n     * How many clones can be created at a time.\n     * @const {number}\n     */\n    static get MAX_CLONES () {\n        return 300;\n    }\n\n    // -----------------------------------------------------------------------------\n    // -----------------------------------------------------------------------------\n\n    // Helper function for initializing the addCloudVariable function\n    _initializeAddCloudVariable (newCloudDataManager) {\n        // The addCloudVariable function\n        return () => {\n            const hadCloudVarsBefore = this.hasCloudData();\n            newCloudDataManager.addCloudVariable();\n            if (!hadCloudVarsBefore && this.hasCloudData()) {\n                this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, true);\n            }\n        };\n    }\n\n    // Helper function for initializing the removeCloudVariable function\n    _initializeRemoveCloudVariable (newCloudDataManager) {\n        return () => {\n            const hadCloudVarsBefore = this.hasCloudData();\n            newCloudDataManager.removeCloudVariable();\n            if (hadCloudVarsBefore && !this.hasCloudData()) {\n                this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n            }\n        };\n    }\n\n    /**\n     * Register default block packages with this runtime.\n     * @todo Prefix opcodes with package name.\n     * @private\n     */\n    _registerBlockPackages () {\n        for (const packageName in defaultBlockPackages) {\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    defaultBlockPackages,\n                    packageName\n                )\n            ) {\n                // @todo pass a different runtime depending on package privilege?\n                const packageObject = new defaultBlockPackages[packageName](\n                    this\n                );\n                // Collect primitives from package.\n                if (packageObject.getPrimitives) {\n                    const packagePrimitives = packageObject.getPrimitives();\n                    for (const op in packagePrimitives) {\n                        if (\n                            Object.prototype.hasOwnProperty.call(\n                                packagePrimitives,\n                                op\n                            )\n                        ) {\n                            this._primitives[op] =\n                                packagePrimitives[op].bind(packageObject);\n                        }\n                    }\n                }\n                // Collect hat metadata from package.\n                if (packageObject.getHats) {\n                    const packageHats = packageObject.getHats();\n                    for (const hatName in packageHats) {\n                        if (\n                            Object.prototype.hasOwnProperty.call(\n                                packageHats,\n                                hatName\n                            )\n                        ) {\n                            this._hats[hatName] = packageHats[hatName];\n                        }\n                    }\n                }\n                // Collect monitored from package.\n                if (packageObject.getMonitored) {\n                    this.monitorBlockInfo = Object.assign(\n                        {},\n                        this.monitorBlockInfo,\n                        packageObject.getMonitored()\n                    );\n                }\n            }\n        }\n    }\n\n    getMonitorState () {\n        return this._monitorState;\n    }\n\n    /**\n     * Generate an extension-specific menu ID.\n     * @param {string} menuName - the name of the menu.\n     * @param {string} extensionId - the ID of the extension hosting the menu.\n     * @returns {string} - the constructed ID.\n     * @private\n     */\n    _makeExtensionMenuId (menuName, extensionId) {\n        return `${extensionId}_menu_${xmlEscape(menuName)}`;\n    }\n\n    /**\n     * Create a context (\"args\") object for use with `formatMessage` on messages which might be target-specific.\n     * @param {Target} [target] - the target to use as context. If a target is not provided, default to the current\n     * editing target or the stage.\n     */\n    makeMessageContextForTarget (target) {\n        const context = {};\n        target = target || this.getEditingTarget() || this.getTargetForStage();\n        if (target) {\n            context.targetType = target.isStage ?\n                TargetType.STAGE :\n                TargetType.SPRITE;\n        }\n    }\n\n    /**\n     * Register the primitives provided by an extension.\n     * @param {ExtensionMetadata} extensionInfo - information about the extension (id, blocks, etc.)\n     * @private\n     */\n    _registerExtensionPrimitives (extensionInfo) {\n        const categoryInfo = {\n            id: extensionInfo.id,\n            name: maybeFormatMessage(extensionInfo.name),\n            showStatusButton: extensionInfo.showStatusButton,\n            blockIconURI: extensionInfo.blockIconURI,\n            menuIconURI: extensionInfo.menuIconURI\n        };\n\n        if (extensionInfo.color1) {\n            categoryInfo.color1 = extensionInfo.color1;\n            categoryInfo.color2 = extensionInfo.color2;\n            categoryInfo.color3 = extensionInfo.color3;\n        } else {\n            categoryInfo.color1 = defaultExtensionColors[0];\n            categoryInfo.color2 = defaultExtensionColors[1];\n            categoryInfo.color3 = defaultExtensionColors[2];\n        }\n\n        this._blockInfo.push(categoryInfo);\n\n        this._fillExtensionCategory(categoryInfo, extensionInfo);\n\n        for (const fieldTypeName in categoryInfo.customFieldTypes) {\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    extensionInfo.customFieldTypes,\n                    fieldTypeName\n                )\n            ) {\n                const fieldTypeInfo =\n                    categoryInfo.customFieldTypes[fieldTypeName];\n\n                // Emit events for custom field types from extension\n                this.emit(Runtime.EXTENSION_FIELD_ADDED, {\n                    name: `field_${fieldTypeInfo.extendedName}`,\n                    implementation: fieldTypeInfo.fieldImplementation\n                });\n            }\n        }\n\n        this.emit(Runtime.EXTENSION_ADDED, categoryInfo);\n    }\n\n    /**\n     * Reregister the primitives for an extension\n     * @param  {ExtensionMetadata} extensionInfo - new info (results of running getInfo) for an extension\n     * @private\n     */\n    _refreshExtensionPrimitives (extensionInfo) {\n        const categoryInfo = this._blockInfo.find(\n            info => info.id === extensionInfo.id\n        );\n        if (categoryInfo) {\n            categoryInfo.name = maybeFormatMessage(extensionInfo.name);\n            this._fillExtensionCategory(categoryInfo, extensionInfo);\n\n            this.emit(Runtime.BLOCKSINFO_UPDATE, categoryInfo);\n        }\n    }\n\n    /**\n     * Read extension information, convert menus, blocks and custom field types\n     * and store the results in the provided category object.\n     * @param {CategoryInfo} categoryInfo - the category to be filled\n     * @param {ExtensionMetadata} extensionInfo - the extension metadata to read\n     * @private\n     */\n    _fillExtensionCategory (categoryInfo, extensionInfo) {\n        categoryInfo.blocks = [];\n        categoryInfo.customFieldTypes = {};\n        categoryInfo.menus = [];\n        categoryInfo.menuInfo = {};\n\n        for (const menuName in extensionInfo.menus) {\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    extensionInfo.menus,\n                    menuName\n                )\n            ) {\n                const menuInfo = extensionInfo.menus[menuName];\n                const convertedMenu = this._buildMenuForScratchBlocks(\n                    menuName,\n                    menuInfo,\n                    categoryInfo\n                );\n                categoryInfo.menus.push(convertedMenu);\n                categoryInfo.menuInfo[menuName] = menuInfo;\n            }\n        }\n        for (const fieldTypeName in extensionInfo.customFieldTypes) {\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    extensionInfo.customFieldTypes,\n                    fieldTypeName\n                )\n            ) {\n                const fieldType = extensionInfo.customFieldTypes[fieldTypeName];\n                const fieldTypeInfo = this._buildCustomFieldInfo(\n                    fieldTypeName,\n                    fieldType,\n                    extensionInfo.id,\n                    categoryInfo\n                );\n\n                categoryInfo.customFieldTypes[fieldTypeName] = fieldTypeInfo;\n            }\n        }\n\n        for (const blockInfo of extensionInfo.blocks) {\n            try {\n                const convertedBlock = this._convertForScratchBlocks(\n                    blockInfo,\n                    categoryInfo\n                );\n                categoryInfo.blocks.push(convertedBlock);\n                if (convertedBlock.json) {\n                    const opcode = convertedBlock.json.type;\n                    if (blockInfo.blockType !== BlockType.EVENT) {\n                        this._primitives[opcode] = convertedBlock.info.func;\n                    }\n                    if (\n                        blockInfo.blockType === BlockType.EVENT ||\n                        blockInfo.blockType === BlockType.HAT\n                    ) {\n                        this._hats[opcode] = {\n                            edgeActivated: blockInfo.isEdgeActivated,\n                            restartExistingThreads:\n                                blockInfo.shouldRestartExistingThreads\n                        };\n                    }\n                }\n            } catch (e) {\n                log.error('Error parsing block: ', {\n                    block: blockInfo,\n                    error: e\n                });\n            }\n        }\n    }\n\n    /**\n     * Convert the given extension menu items into the scratch-blocks style of list of pairs.\n     * If the menu is dynamic (e.g. the passed in argument is a function), return the input unmodified.\n     * @param {object} menuItems - an array of menu items or a function to retrieve such an array\n     * @returns {object} - an array of 2 element arrays or the original input function\n     * @private\n     */\n    _convertMenuItems (menuItems) {\n        if (typeof menuItems !== 'function') {\n            const extensionMessageContext = this.makeMessageContextForTarget();\n            return menuItems.map(item => {\n                const formattedItem = maybeFormatMessage(\n                    item,\n                    extensionMessageContext\n                );\n                switch (typeof formattedItem) {\n                case 'string':\n                    return [formattedItem, formattedItem];\n                case 'object':\n                    return [\n                        maybeFormatMessage(\n                            item.text,\n                            extensionMessageContext\n                        ),\n                        item.value\n                    ];\n                default:\n                    throw new Error(\n                        `Can't interpret menu item: ${JSON.stringify(item)}`\n                    );\n                }\n            });\n        }\n        return menuItems;\n    }\n\n    /**\n     * Build the scratch-blocks JSON for a menu. Note that scratch-blocks treats menus as a special kind of block.\n     * @param {string} menuName - the name of the menu\n     * @param {object} menuInfo - a description of this menu and its items\n     * @property {*} items - an array of menu items or a function to retrieve such an array\n     * @property {boolean} [acceptReporters] - if true, allow dropping reporters onto this menu\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {object} - a JSON-esque object ready for scratch-blocks' consumption\n     * @private\n     */\n    _buildMenuForScratchBlocks (menuName, menuInfo, categoryInfo) {\n        const menuId = this._makeExtensionMenuId(menuName, categoryInfo.id);\n        const menuItems = this._convertMenuItems(menuInfo.items);\n        return {\n            json: {\n                message0: '%1',\n                type: menuId,\n                inputsInline: true,\n                output: 'String',\n                colour: categoryInfo.color1,\n                colourSecondary: categoryInfo.color2,\n                colourTertiary: categoryInfo.color3,\n                outputShape: menuInfo.acceptReporters ?\n                    ScratchBlocksConstants.OUTPUT_SHAPE_ROUND :\n                    ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE,\n                args0: [\n                    {\n                        type: 'field_dropdown',\n                        name: menuName,\n                        options: menuItems\n                    }\n                ]\n            }\n        };\n    }\n\n    _buildCustomFieldInfo (fieldName, fieldInfo, extensionId, categoryInfo) {\n        const extendedName = `${extensionId}_${fieldName}`;\n        return {\n            fieldName: fieldName,\n            extendedName: extendedName,\n            argumentTypeInfo: {\n                shadow: {\n                    type: extendedName,\n                    fieldName: `field_${extendedName}`\n                }\n            },\n            scratchBlocksDefinition: this._buildCustomFieldTypeForScratchBlocks(\n                extendedName,\n                fieldInfo.output,\n                fieldInfo.outputShape,\n                categoryInfo\n            ),\n            fieldImplementation: fieldInfo.implementation\n        };\n    }\n\n    /**\n     * Build the scratch-blocks JSON needed for a fieldType.\n     * Custom field types need to be namespaced to the extension so that extensions can't interfere with each other\n     * @param  {string} fieldName - The name of the field\n     * @param {string} output - The output of the field\n     * @param {number} outputShape - Shape of the field (from ScratchBlocksConstants)\n     * @param {object} categoryInfo - The category the field belongs to (Used to set its colors)\n     * @returns {object} - Object to be inserted into scratch-blocks\n     */\n    _buildCustomFieldTypeForScratchBlocks (\n        fieldName,\n        output,\n        outputShape,\n        categoryInfo\n    ) {\n        return {\n            json: {\n                type: fieldName,\n                message0: '%1',\n                inputsInline: true,\n                output: output,\n                colour: categoryInfo.color1,\n                colourSecondary: categoryInfo.color2,\n                colourTertiary: categoryInfo.color3,\n                outputShape: outputShape,\n                args0: [\n                    {\n                        name: `field_${fieldName}`,\n                        type: `field_${fieldName}`\n                    }\n                ]\n            }\n        };\n    }\n\n    /**\n     * Convert ExtensionBlockMetadata into data ready for scratch-blocks.\n     * @param {ExtensionBlockMetadata} blockInfo - the block info to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n    _convertForScratchBlocks (blockInfo, categoryInfo) {\n        if (blockInfo === '---') {\n            return this._convertSeparatorForScratchBlocks(blockInfo);\n        }\n\n        if (blockInfo.blockType === BlockType.BUTTON) {\n            return this._convertButtonForScratchBlocks(blockInfo);\n        }\n\n        return this._convertBlockForScratchBlocks(blockInfo, categoryInfo);\n    }\n\n    /**\n     * Convert ExtensionBlockMetadata into scratch-blocks JSON & XML, and generate a proxy function.\n     * @param {ExtensionBlockMetadata} blockInfo - the block to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n    _convertBlockForScratchBlocks (blockInfo, categoryInfo) {\n        const extendedOpcode = `${categoryInfo.id}_${blockInfo.opcode}`;\n\n        const blockJSON = {\n            type: extendedOpcode,\n            inputsInline: true,\n            category: categoryInfo.name,\n            colour: categoryInfo.color1,\n            colourSecondary: categoryInfo.color2,\n            colourTertiary: categoryInfo.color3\n        };\n        const context = {\n            // TODO: store this somewhere so that we can map args appropriately after translation.\n            // This maps an arg name to its relative position in the original (usually English) block text.\n            // When displaying a block in another language we'll need to run a `replace` action similar to the one\n            // below, but each `[ARG]` will need to be replaced with the number in this map.\n            argsMap: {},\n            blockJSON,\n            categoryInfo,\n            blockInfo,\n            inputList: []\n        };\n\n        // If an icon for the extension exists, prepend it to each block, with a vertical separator.\n        // We can overspecify an icon for each block, but if no icon exists on a block, fall back to\n        // the category block icon.\n        const iconURI = blockInfo.blockIconURI || categoryInfo.blockIconURI;\n\n        if (iconURI) {\n            blockJSON.extensions = ['scratch_extension'];\n            blockJSON.message0 = '%1 %2';\n            const iconJSON = {\n                type: 'field_image',\n                src: iconURI,\n                width: 40,\n                height: 40\n            };\n            const separatorJSON = {\n                type: 'field_vertical_separator'\n            };\n            blockJSON.args0 = [iconJSON, separatorJSON];\n        }\n\n        switch (blockInfo.blockType) {\n        case BlockType.COMMAND:\n            blockJSON.outputShape =\n                    ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n            blockJSON.previousStatement = null; // null = available connection; undefined = hat\n            if (!blockInfo.isTerminal) {\n                blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n            }\n            break;\n        case BlockType.REPORTER:\n            blockJSON.output = 'String'; // TODO: distinguish number & string here?\n            blockJSON.outputShape =\n                    ScratchBlocksConstants.OUTPUT_SHAPE_ROUND;\n            break;\n        case BlockType.BOOLEAN:\n            blockJSON.output = 'Boolean';\n            blockJSON.outputShape =\n                    ScratchBlocksConstants.OUTPUT_SHAPE_HEXAGONAL;\n            break;\n        case BlockType.HAT:\n        case BlockType.EVENT:\n            if (\n                !Object.prototype.hasOwnProperty.call(\n                    blockInfo,\n                    'isEdgeActivated'\n                )\n            ) {\n                // if absent, this property defaults to true\n                blockInfo.isEdgeActivated = true;\n            }\n            blockJSON.outputShape =\n                    ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n            blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n            break;\n        case BlockType.CONDITIONAL:\n        case BlockType.LOOP:\n            blockInfo.branchCount = blockInfo.branchCount || 1;\n            blockJSON.outputShape =\n                    ScratchBlocksConstants.OUTPUT_SHAPE_SQUARE;\n            blockJSON.previousStatement = null; // null = available connection; undefined = hat\n            if (!blockInfo.isTerminal) {\n                blockJSON.nextStatement = null; // null = available connection; undefined = terminal\n            }\n            break;\n        }\n\n        const blockText = Array.isArray(blockInfo.text) ?\n            blockInfo.text :\n            [blockInfo.text];\n        let inTextNum = 0; // text for the next block \"arm\" is blockText[inTextNum]\n        let inBranchNum = 0; // how many branches have we placed into the JSON so far?\n        let outLineNum = 0; // used for scratch-blocks `message${outLineNum}` and `args${outLineNum}`\n        const convertPlaceholders = this._convertPlaceholders.bind(\n            this,\n            context\n        );\n        const extensionMessageContext = this.makeMessageContextForTarget();\n\n        // alternate between a block \"arm\" with text on it and an open slot for a substack\n        while (\n            inTextNum < blockText.length ||\n            inBranchNum < blockInfo.branchCount\n        ) {\n            if (inTextNum < blockText.length) {\n                context.outLineNum = outLineNum;\n                const lineText = maybeFormatMessage(\n                    blockText[inTextNum],\n                    extensionMessageContext\n                );\n                const convertedText = lineText.replace(\n                    /\\[(.+?)]/g,\n                    convertPlaceholders\n                );\n                if (blockJSON[`message${outLineNum}`]) {\n                    blockJSON[`message${outLineNum}`] += convertedText;\n                } else {\n                    blockJSON[`message${outLineNum}`] = convertedText;\n                }\n                ++inTextNum;\n                ++outLineNum;\n            }\n            if (inBranchNum < blockInfo.branchCount) {\n                blockJSON[`message${outLineNum}`] = '%1';\n                blockJSON[`args${outLineNum}`] = [\n                    {\n                        type: 'input_statement',\n                        name: `SUBSTACK${\n                            inBranchNum > 0 ? inBranchNum + 1 : ''\n                        }`\n                    }\n                ];\n                ++inBranchNum;\n                ++outLineNum;\n            }\n        }\n\n        if (blockInfo.blockType === BlockType.REPORTER) {\n            if (!blockInfo.disableMonitor && context.inputList.length === 0) {\n                blockJSON.checkboxInFlyout = true;\n            }\n        } else if (blockInfo.blockType === BlockType.LOOP) {\n            // Add icon to the bottom right of a loop block\n            blockJSON[`lastDummyAlign${outLineNum}`] = 'RIGHT';\n            blockJSON[`message${outLineNum}`] = '%1';\n            blockJSON[`args${outLineNum}`] = [\n                {\n                    type: 'field_image',\n                    src: './static/blocks-media/repeat.svg', // TODO: use a constant or make this configurable?\n                    width: 24,\n                    height: 24,\n                    alt: '*', // TODO remove this since we don't use collapsed blocks in scratch\n                    flip_rtl: true\n                }\n            ];\n            ++outLineNum;\n        }\n\n        const mutation = blockInfo.isDynamic ?\n            `<mutation blockInfo=\"${xmlEscape(JSON.stringify(blockInfo))}\"/>` :\n            '';\n        const inputs = context.inputList.join('');\n        const blockXML = `<block type=\"${extendedOpcode}\">${mutation}${inputs}</block>`;\n\n        return {\n            info: context.blockInfo,\n            json: context.blockJSON,\n            xml: blockXML\n        };\n    }\n\n    /**\n     * Generate a separator between blocks categories or sub-categories.\n     * @param {ExtensionBlockMetadata} blockInfo - the block to convert\n     * @param {CategoryInfo} categoryInfo - the category for this block\n     * @returns {ConvertedBlockInfo} - the converted & original block information\n     * @private\n     */\n    _convertSeparatorForScratchBlocks (blockInfo) {\n        return {\n            info: blockInfo,\n            xml: '<sep gap=\"36\"/>'\n        };\n    }\n\n    /**\n     * Convert a button for scratch-blocks. A button has no opcode but specifies a callback name in the `func` field.\n     * @param {ExtensionBlockMetadata} buttonInfo - the button to convert\n     * @property {string} func - the callback name\n     * @param {CategoryInfo} categoryInfo - the category for this button\n     * @returns {ConvertedBlockInfo} - the converted & original button information\n     * @private\n     */\n    _convertButtonForScratchBlocks (buttonInfo) {\n        // for now we only support these pre-defined callbacks handled in scratch-blocks\n        const supportedCallbackKeys = [\n            'MAKE_A_LIST',\n            'MAKE_A_PROCEDURE',\n            'MAKE_A_VARIABLE'\n        ];\n        if (supportedCallbackKeys.indexOf(buttonInfo.func) < 0) {\n            log.error(\n                `Custom button callbacks not supported yet: ${buttonInfo.func}`\n            );\n        }\n\n        const extensionMessageContext = this.makeMessageContextForTarget();\n        const buttonText = maybeFormatMessage(\n            buttonInfo.text,\n            extensionMessageContext\n        );\n        return {\n            info: buttonInfo,\n            xml: `<button text=\"${buttonText}\" callbackKey=\"${buttonInfo.func}\"></button>`\n        };\n    }\n\n    /**\n     * Helper for _convertPlaceholdes which handles inline images which are a specialized case of block \"arguments\".\n     * @param {object} argInfo Metadata about the inline image as specified by the extension\n     * @return {object} JSON blob for a scratch-blocks image field.\n     * @private\n     */\n    _constructInlineImageJson (argInfo) {\n        if (!argInfo.dataURI) {\n            log.warn(\n                'Missing data URI in extension block with argument type IMAGE'\n            );\n        }\n        return {\n            type: 'field_image',\n            src: argInfo.dataURI || '',\n            // TODO these probably shouldn't be hardcoded...?\n            width: 24,\n            height: 24,\n            // Whether or not the inline image should be flipped horizontally\n            // in RTL languages. Defaults to false, indicating that the\n            // image will not be flipped.\n            flip_rtl: argInfo.flipRTL || false\n        };\n    }\n\n    /**\n     * Helper for _convertForScratchBlocks which handles linearization of argument placeholders. Called as a callback\n     * from string#replace. In addition to the return value the JSON and XML items in the context will be filled.\n     * @param {object} context - information shared with _convertForScratchBlocks about the block, etc.\n     * @param {string} match - the overall string matched by the placeholder regex, including brackets: '[FOO]'.\n     * @param {string} placeholder - the name of the placeholder being matched: 'FOO'.\n     * @return {string} scratch-blocks placeholder for the argument: '%1'.\n     * @private\n     */\n    _convertPlaceholders (context, match, placeholder) {\n        // Sanitize the placeholder to ensure valid XML\n        placeholder = placeholder.replace(/[<\"&]/, '_');\n\n        // Determine whether the argument type is one of the known standard field types\n        const argInfo = context.blockInfo.arguments[placeholder] || {};\n        let argTypeInfo = ArgumentTypeMap[argInfo.type] || {};\n\n        // Field type not a standard field type, see if extension has registered custom field type\n        if (\n            !ArgumentTypeMap[argInfo.type] &&\n            context.categoryInfo.customFieldTypes[argInfo.type]\n        ) {\n            argTypeInfo =\n                context.categoryInfo.customFieldTypes[argInfo.type]\n                    .argumentTypeInfo;\n        }\n\n        // Start to construct the scratch-blocks style JSON defining how the block should be\n        // laid out\n        let argJSON;\n\n        // Most field types are inputs (slots on the block that can have other blocks plugged into them)\n        // check if this is not one of those cases. E.g. an inline image on a block.\n        if (argTypeInfo.fieldType === 'field_image') {\n            argJSON = this._constructInlineImageJson(argInfo);\n        } else {\n            // Construct input value\n\n            // Layout a block argument (e.g. an input slot on the block)\n            argJSON = {\n                type: 'input_value',\n                name: placeholder\n            };\n\n            const defaultValue =\n                typeof argInfo.defaultValue === 'undefined' ?\n                    '' :\n                    xmlEscape(\n                        maybeFormatMessage(\n                            argInfo.defaultValue,\n                            this.makeMessageContextForTarget()\n                        ).toString()\n                    );\n\n            if (argTypeInfo.check) {\n                // Right now the only type of 'check' we have specifies that the\n                // input slot on the block accepts Boolean reporters, so it should be\n                // shaped like a hexagon\n                argJSON.check = argTypeInfo.check;\n            }\n\n            let valueName;\n            let shadowType;\n            let fieldName;\n            if (argInfo.menu) {\n                const menuInfo = context.categoryInfo.menuInfo[argInfo.menu];\n                if (menuInfo.acceptReporters) {\n                    valueName = placeholder;\n                    shadowType = this._makeExtensionMenuId(\n                        argInfo.menu,\n                        context.categoryInfo.id\n                    );\n                    fieldName = argInfo.menu;\n                } else {\n                    argJSON.type = 'field_dropdown';\n                    argJSON.options = this._convertMenuItems(menuInfo.items);\n                    valueName = null;\n                    shadowType = null;\n                    fieldName = placeholder;\n                }\n            } else {\n                valueName = placeholder;\n                shadowType =\n                    (argTypeInfo.shadow && argTypeInfo.shadow.type) || null;\n                fieldName =\n                    (argTypeInfo.shadow && argTypeInfo.shadow.fieldName) ||\n                    null;\n            }\n\n            // <value> is the ScratchBlocks name for a block input.\n            if (valueName) {\n                context.inputList.push(`<value name=\"${placeholder}\">`);\n            }\n\n            // The <shadow> is a placeholder for a reporter and is visible when there's no reporter in this input.\n            // Boolean inputs don't need to specify a shadow in the XML.\n            if (shadowType) {\n                context.inputList.push(`<shadow type=\"${shadowType}\">`);\n            }\n\n            // A <field> displays a dynamic value: a user-editable text field, a drop-down menu, etc.\n            // Leave out the field if defaultValue or fieldName are not specified\n            if (defaultValue && fieldName) {\n                context.inputList.push(\n                    `<field name=\"${fieldName}\">${defaultValue}</field>`\n                );\n            }\n\n            if (shadowType) {\n                context.inputList.push('</shadow>');\n            }\n\n            if (valueName) {\n                context.inputList.push('</value>');\n            }\n        }\n\n        const argsName = `args${context.outLineNum}`;\n        const blockArgs = (context.blockJSON[argsName] =\n            context.blockJSON[argsName] || []);\n        if (argJSON) blockArgs.push(argJSON);\n        const argNum = blockArgs.length;\n        context.argsMap[placeholder] = argNum;\n\n        return `%${argNum}`;\n    }\n\n    /**\n     * @returns {Array.<object>} scratch-blocks XML for each category of extension blocks, in category order.\n     * @param {?Target} [target] - the active editing target (optional)\n     * @property {string} id - the category / extension ID\n     * @property {string} xml - the XML text for this category, starting with `<category>` and ending with `</category>`\n     */\n    getBlocksXML (target) {\n        return this._blockInfo.map(categoryInfo => {\n            const {name, color1, color2} = categoryInfo;\n            // Filter out blocks that aren't supposed to be shown on this target, as determined by the block info's\n            // `hideFromPalette` and `filter` properties.\n            const paletteBlocks = categoryInfo.blocks.filter(block => {\n                let blockFilterIncludesTarget = true;\n                // If an editing target is not passed, include all blocks\n                // If the block info doesn't include a `filter` property, always include it\n                if (target && block.info.filter) {\n                    blockFilterIncludesTarget = block.info.filter.includes(\n                        target.isStage ? TargetType.STAGE : TargetType.SPRITE\n                    );\n                }\n                // If the block info's `hideFromPalette` is true, then filter out this block\n                return blockFilterIncludesTarget && !block.info.hideFromPalette;\n            });\n\n            const colorXML = `colour=\"${color1}\" secondaryColour=\"${color2}\"`;\n\n            // Use a menu icon if there is one. Otherwise, use the block icon. If there's no icon,\n            // the category menu will show its default colored circle.\n            let menuIconURI = '';\n            if (categoryInfo.menuIconURI) {\n                menuIconURI = categoryInfo.menuIconURI;\n            } else if (categoryInfo.blockIconURI) {\n                menuIconURI = categoryInfo.blockIconURI;\n            }\n            const menuIconXML = menuIconURI ? `iconURI=\"${menuIconURI}\"` : '';\n\n            let statusButtonXML = '';\n            if (categoryInfo.showStatusButton) {\n                statusButtonXML = 'showStatusButton=\"true\"';\n            }\n\n            return {\n                id: categoryInfo.id,\n                xml: `<category name=\"${name}\" id=\"${\n                    categoryInfo.id\n                }\" ${statusButtonXML} ${colorXML} ${menuIconXML}>${paletteBlocks\n                    .map(block => block.xml)\n                    .join('')}</category>`\n            };\n        });\n    }\n\n    /**\n     * @returns {Array.<string>} - an array containing the scratch-blocks JSON information for each dynamic block.\n     */\n    getBlocksJSON () {\n        return this._blockInfo.reduce(\n            (result, categoryInfo) =>\n                result.concat(\n                    categoryInfo.blocks.map(blockInfo => blockInfo.json)\n                ),\n            []\n        );\n    }\n\n    /**\n     * One-time initialization for Scratch Link support.\n     */\n    _initScratchLink () {\n        // Check that we're actually in a real browser, not Node.js or JSDOM, and we have a valid-looking origin.\n        // note that `if (self?....)` will throw if `self` is undefined, so check for that first!\n        if (\n            typeof self !== 'undefined' &&\n            typeof document !== 'undefined' &&\n            document.getElementById &&\n            self.origin &&\n            self.origin !== 'null' && // note this is a string comparison, not a null check\n            self.navigator &&\n            self.navigator.userAgent &&\n            !(\n                self.navigator.userAgent.includes('Node.js') ||\n                self.navigator.userAgent.includes('jsdom')\n            )\n        ) {\n            // Create a script tag for the Scratch Link browser extension, unless one already exists\n            const scriptElement = document.getElementById(\n                'scratch-link-extension-script'\n            );\n            if (!scriptElement) {\n                const script = document.createElement('script');\n                script.id = 'scratch-link-extension-script';\n                document.body.appendChild(script);\n\n                // Tell the browser extension to inject its script.\n                // If the extension isn't present or isn't active, this will do nothing.\n                self.postMessage('inject-scratch-link-script', self.origin);\n            }\n        }\n    }\n\n    /**\n     * Get a scratch link socket.\n     * @param {string} type Either BLE or BT\n     * @returns {ScratchLinkSocket} The scratch link socket.\n     */\n    getScratchLinkSocket (type) {\n        const factory =\n            this._linkSocketFactory || this._defaultScratchLinkSocketFactory;\n        return factory(type);\n    }\n\n    /**\n     * Configure how ScratchLink sockets are created. Factory must consume a \"type\" parameter\n     * either BT or BLE.\n     * @param {Function} factory The new factory for creating ScratchLink sockets.\n     */\n    configureScratchLinkSocketFactory (factory) {\n        this._linkSocketFactory = factory;\n    }\n\n    /**\n     * The default scratch link socket creator, using websockets to the installed device manager.\n     * @param {string} type Either BLE or BT\n     * @returns {ScratchLinkSocket} The new scratch link socket (a WebSocket object)\n     */\n    _defaultScratchLinkSocketFactory (type) {\n        const Scratch = self.Scratch;\n        const ScratchLinkSafariSocket =\n            Scratch && Scratch.ScratchLinkSafariSocket;\n        // detect this every time in case the user turns on the extension after loading the page\n        const useSafariSocket =\n            ScratchLinkSafariSocket &&\n            ScratchLinkSafariSocket.isSafariHelperCompatible();\n        return useSafariSocket ?\n            new ScratchLinkSafariSocket(type) :\n            new ScratchLinkWebSocket(type);\n    }\n\n    /**\n     * Register an extension that communications with a hardware peripheral by id,\n     * to have access to it and its peripheral functions in the future.\n     * @param {string} extensionId - the id of the extension.\n     * @param {object} extension - the extension to register.\n     */\n    registerPeripheralExtension (extensionId, extension) {\n        this.peripheralExtensions[extensionId] = extension;\n    }\n\n    /**\n     * Tell the specified extension to scan for a peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n    scanForPeripheral (extensionId) {\n        if (this.peripheralExtensions[extensionId]) {\n            this.peripheralExtensions[extensionId].scan();\n        }\n    }\n\n    /**\n     * Connect to the extension's specified peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @param {number} peripheralId - the id of the peripheral.\n     */\n    connectPeripheral (extensionId, peripheralId) {\n        if (this.peripheralExtensions[extensionId]) {\n            this.peripheralExtensions[extensionId].connect(peripheralId);\n        }\n    }\n\n    /**\n     * Disconnect from the extension's connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     */\n    disconnectPeripheral (extensionId) {\n        if (this.peripheralExtensions[extensionId]) {\n            this.peripheralExtensions[extensionId].disconnect();\n        }\n    }\n\n    /**\n     * Returns whether the extension has a currently connected peripheral.\n     * @param {string} extensionId - the id of the extension.\n     * @return {boolean} - whether the extension has a connected peripheral.\n     */\n    getPeripheralIsConnected (extensionId) {\n        let isConnected = false;\n        if (this.peripheralExtensions[extensionId]) {\n            isConnected = this.peripheralExtensions[extensionId].isConnected();\n        }\n        return isConnected;\n    }\n\n    /**\n     * Emit an event to indicate that the microphone is being used to stream audio.\n     * @param {boolean} listening - true if the microphone is currently listening.\n     */\n    emitMicListening (listening) {\n        this.emit(Runtime.MIC_LISTENING, listening);\n    }\n\n    /**\n     * Retrieve the function associated with the given opcode.\n     * @param {!string} opcode The opcode to look up.\n     * @return {Function} The function which implements the opcode.\n     */\n    getOpcodeFunction (opcode) {\n        return this._primitives[opcode];\n    }\n\n    /**\n     * Return whether an opcode represents a hat block.\n     * @param {!string} opcode The opcode to look up.\n     * @return {boolean} True if the op is known to be a hat.\n     */\n    getIsHat (opcode) {\n        return Object.prototype.hasOwnProperty.call(this._hats, opcode);\n    }\n\n    /**\n     * Return whether an opcode represents an edge-activated hat block.\n     * @param {!string} opcode The opcode to look up.\n     * @return {boolean} True if the op is known to be a edge-activated hat.\n     */\n    getIsEdgeActivatedHat (opcode) {\n        return (\n            Object.prototype.hasOwnProperty.call(this._hats, opcode) &&\n            this._hats[opcode].edgeActivated\n        );\n    }\n\n    /**\n     * Attach the audio engine\n     * @param {!AudioEngine} audioEngine The audio engine to attach\n     */\n    attachAudioEngine (audioEngine) {\n        this.audioEngine = audioEngine;\n    }\n\n    /**\n     * Attach the renderer\n     * @param {!RenderWebGL} renderer The renderer to attach\n     */\n    attachRenderer (renderer) {\n        this.renderer = renderer;\n        this.renderer.setLayerGroupOrdering(StageLayering.LAYER_GROUPS);\n    }\n\n    /**\n     * Set the bitmap adapter for the VM/runtime, which converts scratch 2\n     * bitmaps to scratch 3 bitmaps. (Scratch 3 bitmaps are all bitmap resolution 2)\n     * @param {!function} bitmapAdapter The adapter to attach\n     */\n    attachV2BitmapAdapter (bitmapAdapter) {\n        this.v2BitmapAdapter = bitmapAdapter;\n    }\n\n    /**\n     * Attach the storage module\n     * @param {!ScratchStorage} storage The storage module to attach\n     */\n    attachStorage (storage) {\n        this.storage = storage;\n        fetchWithTimeout.setFetch(storage.scratchFetch.scratchFetch);\n        this.resetRunId();\n    }\n\n    // -----------------------------------------------------------------------------\n    // -----------------------------------------------------------------------------\n\n    /**\n     * Create a thread and push it to the list of threads.\n     * @param {!string} id ID of block that starts the stack.\n     * @param {!Target} target Target to run thread on.\n     * @param {?object} opts optional arguments\n     * @param {?boolean} opts.stackClick true if the script was activated by clicking on the stack\n     * @param {?boolean} opts.updateMonitor true if the script should update a monitor value\n     * @return {!Thread} The newly created thread.\n     */\n    _pushThread (id, target, opts) {\n        const thread = new Thread(id);\n        thread.target = target;\n        thread.stackClick = Boolean(opts && opts.stackClick);\n        thread.updateMonitor = Boolean(opts && opts.updateMonitor);\n        thread.blockContainer = thread.updateMonitor ?\n            this.monitorBlocks :\n            target.blocks;\n\n        thread.pushStack(id);\n        this.threads.push(thread);\n        return thread;\n    }\n\n    /**\n     * Stop a thread: stop running it immediately, and remove it from the thread list later.\n     * @param {!Thread} thread Thread object to remove from actives\n     */\n    _stopThread (thread) {\n        // Mark the thread for later removal\n        thread.isKilled = true;\n        // Inform sequencer to stop executing that thread.\n        this.sequencer.retireThread(thread);\n    }\n\n    /**\n     * Restart a thread in place, maintaining its position in the list of threads.\n     * This is used by `startHats` to and is necessary to ensure 2.0-like execution order.\n     * Test project: https://scratch.mit.edu/projects/130183108/\n     * @param {!Thread} thread Thread object to restart.\n     * @return {Thread} The restarted thread.\n     */\n    _restartThread (thread) {\n        const newThread = new Thread(thread.topBlock);\n        newThread.target = thread.target;\n        newThread.stackClick = thread.stackClick;\n        newThread.updateMonitor = thread.updateMonitor;\n        newThread.blockContainer = thread.blockContainer;\n        newThread.pushStack(thread.topBlock);\n        const i = this.threads.indexOf(thread);\n        if (i > -1) {\n            this.threads[i] = newThread;\n            return newThread;\n        }\n        this.threads.push(thread);\n        return thread;\n    }\n\n    /**\n     * Return whether a thread is currently active/running.\n     * @param {?Thread} thread Thread object to check.\n     * @return {boolean} True if the thread is active/running.\n     */\n    isActiveThread (thread) {\n        return (\n            thread.stack.length > 0 &&\n            thread.status !== Thread.STATUS_DONE &&\n            this.threads.indexOf(thread) > -1\n        );\n    }\n\n    /**\n     * Return whether a thread is waiting for more information or done.\n     * @param {?Thread} thread Thread object to check.\n     * @return {boolean} True if the thread is waiting\n     */\n    isWaitingThread (thread) {\n        return (\n            thread.status === Thread.STATUS_PROMISE_WAIT ||\n            thread.status === Thread.STATUS_YIELD_TICK ||\n            !this.isActiveThread(thread)\n        );\n    }\n\n    /**\n     * Toggle a script.\n     * @param {!string} topBlockId ID of block that starts the script.\n     * @param {?object} opts optional arguments to toggle script\n     * @param {?string} opts.target target ID for target to run script on. If not supplied, uses editing target.\n     * @param {?boolean} opts.stackClick true if the user activated the stack by clicking, false if not. This\n     *     determines whether we show a visual report when turning on the script.\n     */\n    toggleScript (topBlockId, opts) {\n        opts = Object.assign(\n            {\n                target: this._editingTarget,\n                stackClick: false\n            },\n            opts\n        );\n        // Remove any existing thread.\n        for (let i = 0; i < this.threads.length; i++) {\n            // Toggling a script that's already running turns it off\n            if (\n                this.threads[i].topBlock === topBlockId &&\n                this.threads[i].status !== Thread.STATUS_DONE\n            ) {\n                const blockContainer = opts.target.blocks;\n                const opcode = blockContainer.getOpcode(\n                    blockContainer.getBlock(topBlockId)\n                );\n\n                if (\n                    this.getIsEdgeActivatedHat(opcode) &&\n                    this.threads[i].stackClick !== opts.stackClick\n                ) {\n                    // Allow edge activated hat thread stack click to coexist with\n                    // edge activated hat thread that runs every frame\n                    continue;\n                }\n                this._stopThread(this.threads[i]);\n                return;\n            }\n        }\n        // Otherwise add it.\n        this._pushThread(topBlockId, opts.target, opts);\n    }\n\n    /**\n     * Enqueue a script that when finished will update the monitor for the block.\n     * @param {!string} topBlockId ID of block that starts the script.\n     * @param {?Target} optTarget target Target to run script on. If not supplied, uses editing target.\n     */\n    addMonitorScript (topBlockId, optTarget) {\n        if (!optTarget) optTarget = this._editingTarget;\n        for (let i = 0; i < this.threads.length; i++) {\n            // Don't re-add the script if it's already running\n            if (\n                this.threads[i].topBlock === topBlockId &&\n                this.threads[i].status !== Thread.STATUS_DONE &&\n                this.threads[i].updateMonitor\n            ) {\n                return;\n            }\n        }\n        // Otherwise add it.\n        this._pushThread(topBlockId, optTarget, {updateMonitor: true});\n    }\n\n    /**\n     * Run a function `f` for all scripts in a workspace.\n     * `f` will be called with two parameters:\n     *  - the top block ID of the script.\n     *  - the target that owns the script.\n     * @param {!Function} f Function to call for each script.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     */\n    allScriptsDo (f, optTarget) {\n        let targets = this.executableTargets;\n        if (optTarget) {\n            targets = [optTarget];\n        }\n        for (let t = targets.length - 1; t >= 0; t--) {\n            const target = targets[t];\n            const scripts = target.blocks.getScripts();\n            for (let j = 0; j < scripts.length; j++) {\n                const topBlockId = scripts[j];\n                f(topBlockId, target);\n            }\n        }\n    }\n\n    allScriptsByOpcodeDo (opcode, f, optTarget) {\n        let targets = this.executableTargets;\n        if (optTarget) {\n            targets = [optTarget];\n        }\n        for (let t = targets.length - 1; t >= 0; t--) {\n            const target = targets[t];\n            const scripts = BlocksRuntimeCache.getScripts(\n                target.blocks,\n                opcode\n            );\n            for (let j = 0; j < scripts.length; j++) {\n                f(scripts[j], target);\n            }\n        }\n    }\n\n    /**\n     * Start all relevant hats.\n     * @param {!string} requestedHatOpcode Opcode of hats to start.\n     * @param {object=} optMatchFields Optionally, fields to match on the hat.\n     * @param {Target=} optTarget Optionally, a target to restrict to.\n     * @return {Array.<Thread>} List of threads started by this function.\n     */\n    startHats (requestedHatOpcode, optMatchFields, optTarget) {\n        if (\n            !Object.prototype.hasOwnProperty.call(\n                this._hats,\n                requestedHatOpcode\n            )\n        ) {\n            // No known hat with this opcode.\n            return;\n        }\n        const instance = this;\n        const newThreads = [];\n        // Look up metadata for the relevant hat.\n        const hatMeta = instance._hats[requestedHatOpcode];\n\n        for (const opts in optMatchFields) {\n            if (!Object.prototype.hasOwnProperty.call(optMatchFields, opts)) {\n                continue;\n            }\n            optMatchFields[opts] = optMatchFields[opts].toUpperCase();\n        }\n\n        // Consider all scripts, looking for hats with opcode `requestedHatOpcode`.\n        this.allScriptsByOpcodeDo(\n            requestedHatOpcode,\n            (script, target) => {\n                const {blockId: topBlockId, fieldsOfInputs: hatFields} =\n                    script;\n\n                // Match any requested fields.\n                // For example: ensures that broadcasts match.\n                // This needs to happen before the block is evaluated\n                // (i.e., before the predicate can be run) because \"broadcast and wait\"\n                // needs to have a precise collection of started threads.\n                for (const matchField in optMatchFields) {\n                    if (\n                        hatFields[matchField].value !==\n                        optMatchFields[matchField]\n                    ) {\n                        // Field mismatch.\n                        return;\n                    }\n                }\n\n                if (hatMeta.restartExistingThreads) {\n                    // If `restartExistingThreads` is true, we should stop\n                    // any existing threads starting with the top block.\n                    for (let i = 0; i < this.threads.length; i++) {\n                        if (\n                            this.threads[i].target === target &&\n                            this.threads[i].topBlock === topBlockId &&\n                            // stack click threads and hat threads can coexist\n                            !this.threads[i].stackClick\n                        ) {\n                            newThreads.push(\n                                this._restartThread(this.threads[i])\n                            );\n                            return;\n                        }\n                    }\n                } else {\n                    // If `restartExistingThreads` is false, we should\n                    // give up if any threads with the top block are running.\n                    for (let j = 0; j < this.threads.length; j++) {\n                        if (\n                            this.threads[j].target === target &&\n                            this.threads[j].topBlock === topBlockId &&\n                            // stack click threads and hat threads can coexist\n                            !this.threads[j].stackClick &&\n                            this.threads[j].status !== Thread.STATUS_DONE\n                        ) {\n                            // Some thread is already running.\n                            return;\n                        }\n                    }\n                }\n                // Start the thread with this top block.\n                newThreads.push(this._pushThread(topBlockId, target));\n            },\n            optTarget\n        );\n        // For compatibility with Scratch 2, edge triggered hats need to be processed before\n        // threads are stepped. See ScratchRuntime.as for original implementation\n        newThreads.forEach(thread => {\n            execute(this.sequencer, thread);\n            thread.goToNextBlock();\n        });\n        return newThreads;\n    }\n\n    /**\n     * Dispose all targets. Return to clean state.\n     */\n    dispose () {\n        this.stopAll();\n        // Deleting each target's variable's monitors.\n        this.targets.forEach(target => {\n            if (target.isOriginal) target.deleteMonitors();\n        });\n\n        this.targets.map(this.disposeTarget, this);\n        this._monitorState = OrderedMap({});\n        this.emit(Runtime.RUNTIME_DISPOSED);\n        this.ioDevices.clock.resetProjectTimer();\n        // @todo clear out extensions? turboMode? etc.\n\n        // *********** Cloud *******************\n\n        // If the runtime currently has cloud data,\n        // emit a has cloud data update event resetting\n        // it to false\n        if (this.hasCloudData()) {\n            this.emit(Runtime.HAS_CLOUD_DATA_UPDATE, false);\n        }\n\n        this.ioDevices.cloud.clear();\n\n        // Reset runtime cloud data info\n        const newCloudDataManager = cloudDataManager();\n        this.hasCloudData = newCloudDataManager.hasCloudVariables;\n        this.canAddCloudVariable = newCloudDataManager.canAddCloudVariable;\n        this.addCloudVariable =\n            this._initializeAddCloudVariable(newCloudDataManager);\n        this.removeCloudVariable =\n            this._initializeRemoveCloudVariable(newCloudDataManager);\n    }\n\n    /**\n     * Add a target to the runtime. This tracks the sprite pane\n     * ordering of the target. The target still needs to be put\n     * into the correct execution order after calling this function.\n     * @param {Target} target target to add\n     */\n    addTarget (target) {\n        this.targets.push(target);\n        this.executableTargets.push(target);\n    }\n\n    /**\n     * Move a target in the execution order by a relative amount.\n     *\n     * A positve number will make the target execute earlier. A negative number\n     * will make the target execute later in the order.\n     *\n     * @param {Target} executableTarget target to move\n     * @param {number} delta number of positions to move target by\n     * @returns {number} new position in execution order\n     */\n    moveExecutable (executableTarget, delta) {\n        const oldIndex = this.executableTargets.indexOf(executableTarget);\n        this.executableTargets.splice(oldIndex, 1);\n        let newIndex = oldIndex + delta;\n        if (newIndex > this.executableTargets.length) {\n            newIndex = this.executableTargets.length;\n        }\n        if (newIndex <= 0) {\n            if (\n                this.executableTargets.length > 0 &&\n                this.executableTargets[0].isStage\n            ) {\n                newIndex = 1;\n            } else {\n                newIndex = 0;\n            }\n        }\n        this.executableTargets.splice(newIndex, 0, executableTarget);\n        return newIndex;\n    }\n\n    /**\n     * Set a target to execute at a specific position in the execution order.\n     *\n     * Infinity will set the target to execute first. 0 will set the target to\n     * execute last (before the stage).\n     *\n     * @param {Target} executableTarget target to move\n     * @param {number} newIndex position in execution order to place the target\n     * @returns {number} new position in the execution order\n     */\n    setExecutablePosition (executableTarget, newIndex) {\n        const oldIndex = this.executableTargets.indexOf(executableTarget);\n        return this.moveExecutable(executableTarget, newIndex - oldIndex);\n    }\n\n    /**\n     * Remove a target from the execution set.\n     * @param {Target} executableTarget target to remove\n     */\n    removeExecutable (executableTarget) {\n        const oldIndex = this.executableTargets.indexOf(executableTarget);\n        if (oldIndex > -1) {\n            this.executableTargets.splice(oldIndex, 1);\n        }\n    }\n\n    /**\n     * Dispose of a target.\n     * @param {!Target} disposingTarget Target to dispose of.\n     */\n    disposeTarget (disposingTarget) {\n        this.targets = this.targets.filter(target => {\n            if (disposingTarget !== target) return true;\n            // Allow target to do dispose actions.\n            target.dispose();\n            // Remove from list of targets.\n            return false;\n        });\n    }\n\n    /**\n     * Stop any threads acting on the target.\n     * @param {!Target} target Target to stop threads for.\n     * @param {Thread=} optThreadException Optional thread to skip.\n     */\n    stopForTarget (target, optThreadException) {\n        // Emit stop event to allow blocks to clean up any state.\n        this.emit(Runtime.STOP_FOR_TARGET, target, optThreadException);\n\n        // Stop any threads on the target.\n        for (let i = 0; i < this.threads.length; i++) {\n            if (this.threads[i] === optThreadException) {\n                continue;\n            }\n            if (this.threads[i].target === target) {\n                this._stopThread(this.threads[i]);\n            }\n        }\n    }\n\n    /**\n     * Reset the Run ID. Call this any time the project logically starts, stops, or changes identity.\n     */\n    resetRunId () {\n        if (!this.storage) {\n            // see also: attachStorage\n            return;\n        }\n\n        const newRunId = uuid.v1();\n        this.storage.scratchFetch.setMetadata(\n            this.storage.scratchFetch.RequestMetadata.RunId,\n            newRunId\n        );\n    }\n\n    /**\n     * Start all threads that start with the green flag.\n     */\n    greenFlag () {\n        this.stopAll();\n        this.emit(Runtime.PROJECT_START);\n        this.ioDevices.clock.resetProjectTimer();\n        this.targets.forEach(target => target.clearEdgeActivatedValues());\n        // Inform all targets of the green flag.\n        for (let i = 0; i < this.targets.length; i++) {\n            this.targets[i].onGreenFlag();\n        }\n        this.startHats('event_whenflagclicked');\n    }\n\n    /**\n     * Stop \"everything.\"\n     */\n    stopAll () {\n        // Emit stop event to allow blocks to clean up any state.\n        this.emit(Runtime.PROJECT_STOP_ALL);\n\n        // Dispose all clones.\n        const newTargets = [];\n        for (let i = 0; i < this.targets.length; i++) {\n            this.targets[i].onStopAll();\n            if (\n                Object.prototype.hasOwnProperty.call(\n                    this.targets[i],\n                    'isOriginal'\n                ) &&\n                !this.targets[i].isOriginal\n            ) {\n                this.targets[i].dispose();\n            } else {\n                newTargets.push(this.targets[i]);\n            }\n        }\n        this.targets = newTargets;\n        // Dispose of the active thread.\n        if (this.sequencer.activeThread !== null) {\n            this._stopThread(this.sequencer.activeThread);\n        }\n        // Remove all remaining threads from executing in the next tick.\n        this.threads = [];\n\n        this.resetRunId();\n    }\n\n    /**\n     * Repeatedly run `sequencer.stepThreads` and filter out\n     * inactive threads after each iteration.\n     */\n    _step () {\n        if (this.profiler !== null) {\n            if (stepProfilerId === -1) {\n                stepProfilerId = this.profiler.idByName('Runtime._step');\n            }\n            this.profiler.start(stepProfilerId);\n        }\n\n        // Clean up threads that were told to stop during or since the last step\n        this.threads = this.threads.filter(thread => !thread.isKilled);\n\n        // Find all edge-activated hats, and add them to threads to be evaluated.\n        for (const hatType in this._hats) {\n            if (!Object.prototype.hasOwnProperty.call(this._hats, hatType)) {\n                continue;\n            }\n            const hat = this._hats[hatType];\n            if (hat.edgeActivated) {\n                this.startHats(hatType);\n            }\n        }\n        this.redrawRequested = false;\n        this._pushMonitors();\n        if (this.profiler !== null) {\n            if (stepThreadsProfilerId === -1) {\n                stepThreadsProfilerId = this.profiler.idByName(\n                    'Sequencer.stepThreads'\n                );\n            }\n            this.profiler.start(stepThreadsProfilerId);\n        }\n        const doneThreads = this.sequencer.stepThreads();\n        if (this.profiler !== null) {\n            this.profiler.stop();\n        }\n        this._updateGlows(doneThreads);\n        // Add done threads so that even if a thread finishes within 1 frame, the green\n        // flag will still indicate that a script ran.\n        this._emitProjectRunStatus(\n            this.threads.length +\n                doneThreads.length -\n                this._getMonitorThreadCount([...this.threads, ...doneThreads])\n        );\n        // Store threads that completed this iteration for testing and other\n        // internal purposes.\n        this._lastStepDoneThreads = doneThreads;\n        if (this.renderer) {\n            // @todo: Only render when this.redrawRequested or clones rendered.\n            if (this.profiler !== null) {\n                if (rendererDrawProfilerId === -1) {\n                    rendererDrawProfilerId =\n                        this.profiler.idByName('RenderWebGL.draw');\n                }\n                this.profiler.start(rendererDrawProfilerId);\n            }\n            this.renderer.draw();\n            if (this.profiler !== null) {\n                this.profiler.stop();\n            }\n        }\n\n        if (this._refreshTargets) {\n            this.emit(\n                Runtime.TARGETS_UPDATE,\n                false /* Don't emit project changed */\n            );\n            this._refreshTargets = false;\n        }\n\n        if (!this._prevMonitorState.equals(this._monitorState)) {\n            this.emit(Runtime.MONITORS_UPDATE, this._monitorState);\n            this._prevMonitorState = this._monitorState;\n        }\n\n        if (this.profiler !== null) {\n            this.profiler.stop();\n            this.profiler.reportFrames();\n        }\n    }\n\n    /**\n     * Get the number of threads in the given array that are monitor threads (threads\n     * that update monitor values, and don't count as running a script).\n     * @param {!Array.<Thread>} threads The set of threads to look through.\n     * @return {number} The number of monitor threads in threads.\n     */\n    _getMonitorThreadCount (threads) {\n        let count = 0;\n        threads.forEach(thread => {\n            if (thread.updateMonitor) count++;\n        });\n        return count;\n    }\n\n    /**\n     * Queue monitor blocks to sequencer to be run.\n     */\n    _pushMonitors () {\n        this.monitorBlocks.runAllMonitored(this);\n    }\n\n    /**\n     * Set the current editing target known by the runtime.\n     * @param {!Target} editingTarget New editing target.\n     */\n    setEditingTarget (editingTarget) {\n        const oldEditingTarget = this._editingTarget;\n        this._editingTarget = editingTarget;\n        // Script glows must be cleared.\n        this._scriptGlowsPreviousFrame = [];\n        this._updateGlows();\n\n        if (oldEditingTarget !== this._editingTarget) {\n            this.requestToolboxExtensionsUpdate();\n        }\n    }\n\n    /**\n     * Set whether we are in 30 TPS compatibility mode.\n     * @param {boolean} compatibilityModeOn True iff in compatibility mode.\n     */\n    setCompatibilityMode (compatibilityModeOn) {\n        this.compatibilityMode = compatibilityModeOn;\n        if (this._steppingInterval) {\n            clearInterval(this._steppingInterval);\n            this._steppingInterval = null;\n            this.start();\n        }\n    }\n\n    /**\n     * Emit glows/glow clears for scripts after a single tick.\n     * Looks at `this.threads` and notices which have turned on/off new glows.\n     * @param {Array.<Thread>=} optExtraThreads Optional list of inactive threads.\n     */\n    _updateGlows (optExtraThreads) {\n        const searchThreads = [];\n        searchThreads.push(...this.threads);\n        if (optExtraThreads) {\n            searchThreads.push(...optExtraThreads);\n        }\n        // Set of scripts that request a glow this frame.\n        const requestedGlowsThisFrame = [];\n        // Final set of scripts glowing during this frame.\n        const finalScriptGlows = [];\n        // Find all scripts that should be glowing.\n        for (let i = 0; i < searchThreads.length; i++) {\n            const thread = searchThreads[i];\n            const target = thread.target;\n            if (target === this._editingTarget) {\n                const blockForThread = thread.blockGlowInFrame;\n                if (thread.requestScriptGlowInFrame || thread.stackClick) {\n                    let script =\n                        target.blocks.getTopLevelScript(blockForThread);\n                    if (!script) {\n                        // Attempt to find in flyout blocks.\n                        script =\n                            this.flyoutBlocks.getTopLevelScript(blockForThread);\n                    }\n                    if (script) {\n                        requestedGlowsThisFrame.push(script);\n                    }\n                }\n            }\n        }\n        // Compare to previous frame.\n        for (let j = 0; j < this._scriptGlowsPreviousFrame.length; j++) {\n            const previousFrameGlow = this._scriptGlowsPreviousFrame[j];\n            if (requestedGlowsThisFrame.indexOf(previousFrameGlow) < 0) {\n                // Glow turned off.\n                this.glowScript(previousFrameGlow, false);\n            } else {\n                // Still glowing.\n                finalScriptGlows.push(previousFrameGlow);\n            }\n        }\n        for (let k = 0; k < requestedGlowsThisFrame.length; k++) {\n            const currentFrameGlow = requestedGlowsThisFrame[k];\n            if (this._scriptGlowsPreviousFrame.indexOf(currentFrameGlow) < 0) {\n                // Glow turned on.\n                this.glowScript(currentFrameGlow, true);\n                finalScriptGlows.push(currentFrameGlow);\n            }\n        }\n        this._scriptGlowsPreviousFrame = finalScriptGlows;\n    }\n\n    /**\n     * Emit run start/stop after each tick. Emits when `this.threads.length` goes\n     * between non-zero and zero\n     *\n     * @param {number} nonMonitorThreadCount The new nonMonitorThreadCount\n     */\n    _emitProjectRunStatus (nonMonitorThreadCount) {\n        if (this._nonMonitorThreadCount === 0 && nonMonitorThreadCount > 0) {\n            this.emit(Runtime.PROJECT_RUN_START);\n        }\n        if (this._nonMonitorThreadCount > 0 && nonMonitorThreadCount === 0) {\n            this.emit(Runtime.PROJECT_RUN_STOP);\n        }\n        this._nonMonitorThreadCount = nonMonitorThreadCount;\n    }\n\n    /**\n     * \"Quiet\" a script's glow: stop the VM from generating glow/unglow events\n     * about that script. Use when a script has just been deleted, but we may\n     * still be tracking glow data about it.\n     * @param {!string} scriptBlockId Id of top-level block in script to quiet.\n     */\n    quietGlow (scriptBlockId) {\n        const index = this._scriptGlowsPreviousFrame.indexOf(scriptBlockId);\n        if (index > -1) {\n            this._scriptGlowsPreviousFrame.splice(index, 1);\n        }\n    }\n\n    /**\n     * Emit feedback for block glowing (used in the sequencer).\n     * @param {?string} blockId ID for the block to update glow\n     * @param {boolean} isGlowing True to turn on glow; false to turn off.\n     */\n    glowBlock (blockId, isGlowing) {\n        if (isGlowing) {\n            this.emit(Runtime.BLOCK_GLOW_ON, {id: blockId});\n        } else {\n            this.emit(Runtime.BLOCK_GLOW_OFF, {id: blockId});\n        }\n    }\n\n    /**\n     * Emit feedback for script glowing.\n     * @param {?string} topBlockId ID for the top block to update glow\n     * @param {boolean} isGlowing True to turn on glow; false to turn off.\n     */\n    glowScript (topBlockId, isGlowing) {\n        if (isGlowing) {\n            this.emit(Runtime.SCRIPT_GLOW_ON, {id: topBlockId});\n        } else {\n            this.emit(Runtime.SCRIPT_GLOW_OFF, {id: topBlockId});\n        }\n    }\n\n    /**\n     * Emit whether blocks are being dragged over gui\n     * @param {boolean} areBlocksOverGui True if blocks are dragged out of blocks workspace, false otherwise\n     */\n    emitBlockDragUpdate (areBlocksOverGui) {\n        this.emit(Runtime.BLOCK_DRAG_UPDATE, areBlocksOverGui);\n    }\n\n    /**\n     * Emit event to indicate that the block drag has ended with the blocks outside the blocks workspace\n     * @param {Array.<object>} blocks The set of blocks dragged to the GUI\n     * @param {string} topBlockId The original id of the top block being dragged\n     */\n    emitBlockEndDrag (blocks, topBlockId) {\n        this.emit(Runtime.BLOCK_DRAG_END, blocks, topBlockId);\n    }\n\n    /**\n     * Emit value for reporter to show in the blocks.\n     * @param {string} blockId ID for the block.\n     * @param {string} value Value to show associated with the block.\n     */\n    visualReport (blockId, value) {\n        this.emit(Runtime.VISUAL_REPORT, {id: blockId, value: String(value)});\n    }\n\n    /**\n     * Add a monitor to the state. If the monitor already exists in the state,\n     * updates those properties that are defined in the given monitor record.\n     * @param {!MonitorRecord} monitor Monitor to add.\n     */\n    requestAddMonitor (monitor) {\n        const id = monitor.get('id');\n        if (!this.requestUpdateMonitor(monitor)) {\n            // update monitor if it exists in the state\n            // if the monitor did not exist in the state, add it\n            this._monitorState = this._monitorState.set(id, monitor);\n        }\n    }\n\n    /**\n     * Update a monitor in the state and report success/failure of update.\n     * @param {!Map} monitor Monitor values to update. Values on the monitor with overwrite\n     *     values on the old monitor with the same ID. If a value isn't defined on the new monitor,\n     *     the old monitor will keep its old value.\n     * @return {boolean} true if monitor exists in the state and was updated, false if it did not exist.\n     */\n    requestUpdateMonitor (monitor) {\n        const id = monitor.get('id');\n        if (this._monitorState.has(id)) {\n            this._monitorState =\n                // Use mergeWith here to prevent undefined values from overwriting existing ones\n                this._monitorState.set(\n                    id,\n                    this._monitorState.get(id).mergeWith((prev, next) => {\n                        if (typeof next === 'undefined' || next === null) {\n                            return prev;\n                        }\n                        return next;\n                    }, monitor)\n                );\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Removes a monitor from the state. Does nothing if the monitor already does\n     * not exist in the state.\n     * @param {!string} monitorId ID of the monitor to remove.\n     */\n    requestRemoveMonitor (monitorId) {\n        this._monitorState = this._monitorState.delete(monitorId);\n    }\n\n    /**\n     * Hides a monitor and returns success/failure of action.\n     * @param {!string} monitorId ID of the monitor to hide.\n     * @return {boolean} true if monitor exists and was updated, false otherwise\n     */\n    requestHideMonitor (monitorId) {\n        return this.requestUpdateMonitor(\n            new Map([\n                ['id', monitorId],\n                ['visible', false]\n            ])\n        );\n    }\n\n    /**\n     * Shows a monitor and returns success/failure of action.\n     * not exist in the state.\n     * @param {!string} monitorId ID of the monitor to show.\n     * @return {boolean} true if monitor exists and was updated, false otherwise\n     */\n    requestShowMonitor (monitorId) {\n        return this.requestUpdateMonitor(\n            new Map([\n                ['id', monitorId],\n                ['visible', true]\n            ])\n        );\n    }\n\n    /**\n     * Removes all monitors with the given target ID from the state. Does nothing if\n     * the monitor already does not exist in the state.\n     * @param {!string} targetId Remove all monitors with given target ID.\n     */\n    requestRemoveMonitorByTargetId (targetId) {\n        this._monitorState = this._monitorState.filterNot(\n            value => value.targetId === targetId\n        );\n    }\n\n    /**\n     * Get a target by its id.\n     * @param {string} targetId Id of target to find.\n     * @return {?Target} The target, if found.\n     */\n    getTargetById (targetId) {\n        for (let i = 0; i < this.targets.length; i++) {\n            const target = this.targets[i];\n            if (target.id === targetId) {\n                return target;\n            }\n        }\n    }\n\n    /**\n     * Get the first original (non-clone-block-created) sprite given a name.\n     * @param {string} spriteName Name of sprite to look for.\n     * @return {?Target} Target representing a sprite of the given name.\n     */\n    getSpriteTargetByName (spriteName) {\n        for (let i = 0; i < this.targets.length; i++) {\n            const target = this.targets[i];\n            if (target.isStage) {\n                continue;\n            }\n            if (target.sprite && target.sprite.name === spriteName) {\n                return target;\n            }\n        }\n    }\n\n    /**\n     * Get a target by its drawable id.\n     * @param {number} drawableID drawable id of target to find\n     * @return {?Target} The target, if found\n     */\n    getTargetByDrawableId (drawableID) {\n        for (let i = 0; i < this.targets.length; i++) {\n            const target = this.targets[i];\n            if (target.drawableID === drawableID) return target;\n        }\n    }\n\n    /**\n     * Update the clone counter to track how many clones are created.\n     * @param {number} changeAmount How many clones have been created/destroyed.\n     */\n    changeCloneCounter (changeAmount) {\n        this._cloneCounter += changeAmount;\n    }\n\n    /**\n     * Return whether there are clones available.\n     * @return {boolean} True until the number of clones hits Runtime.MAX_CLONES.\n     */\n    clonesAvailable () {\n        return this._cloneCounter < Runtime.MAX_CLONES;\n    }\n\n    /**\n     * Handle that the project has loaded in the Virtual Machine.\n     */\n    handleProjectLoaded () {\n        this.emit(Runtime.PROJECT_LOADED);\n        this.resetRunId();\n    }\n\n    /**\n     * Report that the project has changed in a way that would affect serialization\n     */\n    emitProjectChanged () {\n        this.emit(Runtime.PROJECT_CHANGED);\n    }\n\n    /**\n     * Report that a new target has been created, possibly by cloning an existing target.\n     * @param {Target} newTarget - the newly created target.\n     * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n     * @fires Runtime#targetWasCreated\n     */\n    fireTargetWasCreated (newTarget, sourceTarget) {\n        this.emit('targetWasCreated', newTarget, sourceTarget);\n    }\n\n    /**\n     * Report that a clone target is being removed.\n     * @param {Target} target - the target being removed\n     * @fires Runtime#targetWasRemoved\n     */\n    fireTargetWasRemoved (target) {\n        this.emit('targetWasRemoved', target);\n    }\n\n    /**\n     * Get a target representing the Scratch stage, if one exists.\n     * @return {?Target} The target, if found.\n     */\n    getTargetForStage () {\n        for (let i = 0; i < this.targets.length; i++) {\n            const target = this.targets[i];\n            if (target.isStage) {\n                return target;\n            }\n        }\n    }\n\n    /**\n     * Get the editing target.\n     * @return {?Target} The editing target.\n     */\n    getEditingTarget () {\n        return this._editingTarget;\n    }\n\n    getAllVarNamesOfType (varType) {\n        let varNames = [];\n        for (const target of this.targets) {\n            const targetVarNames = target.getAllVariableNamesInScopeByType(\n                varType,\n                true\n            );\n            varNames = varNames.concat(targetVarNames);\n        }\n        return varNames;\n    }\n\n    /**\n     * Get the label or label function for an opcode\n     * @param {string} extendedOpcode - the opcode you want a label for\n     * @return {object} - object with label and category\n     * @property {string} category - the category for this opcode\n     * @property {Function} [labelFn] - function to generate the label for this opcode\n     * @property {string} [label] - the label for this opcode if `labelFn` is absent\n     */\n    getLabelForOpcode (extendedOpcode) {\n        const [category, opcode] = StringUtil.splitFirst(extendedOpcode, '_');\n        if (!(category && opcode)) return;\n\n        const categoryInfo = this._blockInfo.find(ci => ci.id === category);\n        if (!categoryInfo) return;\n\n        const block = categoryInfo.blocks.find(b => b.info.opcode === opcode);\n        if (!block) return;\n\n        // TODO: we may want to format the label in a locale-specific way.\n        return {\n            category: 'extension', // This assumes that all extensions have the same monitor color.\n            label: `${categoryInfo.name}: ${block.info.text}`\n        };\n    }\n\n    /**\n     * Create a new global variable avoiding conflicts with other variable names.\n     * @param {string} variableName The desired variable name for the new global variable.\n     * This can be turned into a fresh name as necessary.\n     * @param {string} optVarId An optional ID to use for the variable. A new one will be generated\n     * if a falsey value for this parameter is provided.\n     * @param {string} optVarType The type of the variable to create. Defaults to Variable.SCALAR_TYPE.\n     * @return {Variable} The new variable that was created.\n     */\n    createNewGlobalVariable (variableName, optVarId, optVarType) {\n        const varType =\n            typeof optVarType === 'string' ? optVarType : Variable.SCALAR_TYPE;\n        const allVariableNames = this.getAllVarNamesOfType(varType);\n        const newName = StringUtil.unusedName(variableName, allVariableNames);\n        const variable = new Variable(optVarId || uid(), newName, varType);\n        const stage = this.getTargetForStage();\n        stage.variables[variable.id] = variable;\n        return variable;\n    }\n\n    /**\n     * Tell the runtime to request a redraw.\n     * Use after a clone/sprite has completed some visible operation on the stage.\n     */\n    requestRedraw () {\n        this.redrawRequested = true;\n    }\n\n    /**\n     * Emit a targets update at the end of the step if the provided target is\n     * the original sprite\n     * @param {!Target} target Target requesting the targets update\n     */\n    requestTargetsUpdate (target) {\n        if (!target.isOriginal) return;\n        this._refreshTargets = true;\n    }\n\n    /**\n     * Emit an event that indicates that the blocks on the workspace need updating.\n     */\n    requestBlocksUpdate () {\n        this.emit(Runtime.BLOCKS_NEED_UPDATE);\n    }\n\n    /**\n     * Emit an event that indicates that the toolbox extension blocks need updating.\n     */\n    requestToolboxExtensionsUpdate () {\n        this.emit(Runtime.TOOLBOX_EXTENSIONS_NEED_UPDATE);\n    }\n\n    /**\n     * Set up timers to repeatedly step in a browser.\n     */\n    start () {\n        // Do not start if we are already running\n        if (this._steppingInterval) return;\n\n        let interval = Runtime.THREAD_STEP_INTERVAL;\n        if (this.compatibilityMode) {\n            interval = Runtime.THREAD_STEP_INTERVAL_COMPATIBILITY;\n        }\n        this.currentStepTime = interval;\n        this._steppingInterval = setInterval(() => {\n            this._step();\n        }, interval);\n        this.emit(Runtime.RUNTIME_STARTED);\n    }\n\n    /**\n     * Quit the Runtime, clearing any handles which might keep the process alive.\n     * Do not use the runtime after calling this method. This method is meant for test shutdown.\n     */\n    quit () {\n        clearInterval(this._steppingInterval);\n        this._steppingInterval = null;\n    }\n\n    /**\n     * Turn on profiling.\n     * @param {Profiler/FrameCallback} onFrame A callback handle passed a\n     * profiling frame when the profiler reports its collected data.\n     */\n    enableProfiling (onFrame) {\n        if (Profiler.available()) {\n            this.profiler = new Profiler(onFrame);\n        }\n    }\n\n    /**\n     * Turn off profiling.\n     */\n    disableProfiling () {\n        this.profiler = null;\n    }\n\n    /**\n     * Update a millisecond timestamp value that is saved on the Runtime.\n     * This value is helpful in certain instances for compatibility with Scratch 2,\n     * which sometimes uses a `currentMSecs` timestamp value in Interpreter.as\n     */\n    updateCurrentMSecs () {\n        this.currentMSecs = Date.now();\n    }\n}\n\n/**\n * Event fired after a new target has been created, possibly by cloning an existing target.\n *\n * @event Runtime#targetWasCreated\n * @param {Target} newTarget - the newly created target.\n * @param {Target} [sourceTarget] - the target used as a source for the new clone, if any.\n */\n\nmodule.exports = Runtime;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/runtime.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/scratch-blocks-constants.js":
/*!************************************************************!*\
  !*** ../scratch-vm/src/engine/scratch-blocks-constants.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n * These constants are copied from scratch-blocks/core/constants.js\n * @TODO find a way to require() these straight from scratch-blocks... maybe make a scratch-blocks/dist/constants.js?\n * @readonly\n * @enum {int}\n */\nconst ScratchBlocksConstants = {\n    /**\n     * ENUM for output shape: hexagonal (booleans/predicates).\n     * @const\n     */\n    OUTPUT_SHAPE_HEXAGONAL: 1,\n\n    /**\n     * ENUM for output shape: rounded (numbers).\n     * @const\n     */\n    OUTPUT_SHAPE_ROUND: 2,\n\n    /**\n     * ENUM for output shape: squared (any/all values; strings).\n     * @const\n     */\n    OUTPUT_SHAPE_SQUARE: 3\n};\n\nmodule.exports = ScratchBlocksConstants;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/scratch-blocks-constants.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/sequencer.js":
/*!*********************************************!*\
  !*** ../scratch-vm/src/engine/sequencer.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\nconst Thread = __webpack_require__(/*! ./thread */ \"../scratch-vm/src/engine/thread.js\");\nconst execute = __webpack_require__(/*! ./execute.js */ \"../scratch-vm/src/engine/execute.js\");\n\n/**\n * Profiler frame name for stepping a single thread.\n * @const {string}\n */\nconst stepThreadProfilerFrame = 'Sequencer.stepThread';\n\n/**\n * Profiler frame name for the inner loop of stepThreads.\n * @const {string}\n */\nconst stepThreadsInnerProfilerFrame = 'Sequencer.stepThreads#inner';\n\n/**\n * Profiler frame name for execute.\n * @const {string}\n */\nconst executeProfilerFrame = 'execute';\n\n/**\n * Profiler frame ID for stepThreadProfilerFrame.\n * @type {number}\n */\nlet stepThreadProfilerId = -1;\n\n/**\n * Profiler frame ID for stepThreadsInnerProfilerFrame.\n * @type {number}\n */\nlet stepThreadsInnerProfilerId = -1;\n\n/**\n * Profiler frame ID for executeProfilerFrame.\n * @type {number}\n */\nlet executeProfilerId = -1;\n\nclass Sequencer {\n    constructor (runtime) {\n        /**\n         * A utility timer for timing thread sequencing.\n         * @type {!Timer}\n         */\n        this.timer = new Timer();\n\n        /**\n         * Reference to the runtime owning this sequencer.\n         * @type {!Runtime}\n         */\n        this.runtime = runtime;\n\n        this.activeThread = null;\n    }\n\n    /**\n     * Time to run a warp-mode thread, in ms.\n     * @type {number}\n     */\n    static get WARP_TIME () {\n        return 500;\n    }\n\n    /**\n     * Step through all threads in `this.runtime.threads`, running them in order.\n     * @return {Array.<!Thread>} List of inactive threads after stepping.\n     */\n    stepThreads () {\n        // Work time is 75% of the thread stepping interval.\n        const WORK_TIME = 0.75 * this.runtime.currentStepTime;\n        // For compatibility with Scatch 2, update the millisecond clock\n        // on the Runtime once per step (see Interpreter.as in Scratch 2\n        // for original use of `currentMSecs`)\n        this.runtime.updateCurrentMSecs();\n        // Start counting toward WORK_TIME.\n        this.timer.start();\n        // Count of active threads.\n        let numActiveThreads = Infinity;\n        // Whether `stepThreads` has run through a full single tick.\n        let ranFirstTick = false;\n        const doneThreads = [];\n        // Conditions for continuing to stepping threads:\n        // 1. We must have threads in the list, and some must be active.\n        // 2. Time elapsed must be less than WORK_TIME.\n        // 3. Either turbo mode, or no redraw has been requested by a primitive.\n        while (this.runtime.threads.length > 0 &&\n               numActiveThreads > 0 &&\n               this.timer.timeElapsed() < WORK_TIME &&\n               (this.runtime.turboMode || !this.runtime.redrawRequested)) {\n            if (this.runtime.profiler !== null) {\n                if (stepThreadsInnerProfilerId === -1) {\n                    stepThreadsInnerProfilerId = this.runtime.profiler.idByName(stepThreadsInnerProfilerFrame);\n                }\n                this.runtime.profiler.start(stepThreadsInnerProfilerId);\n            }\n\n            numActiveThreads = 0;\n            let stoppedThread = false;\n            // Attempt to run each thread one time.\n            const threads = this.runtime.threads;\n            for (let i = 0; i < threads.length; i++) {\n                const activeThread = this.activeThread = threads[i];\n                // Check if the thread is done so it is not executed.\n                if (activeThread.stack.length === 0 ||\n                    activeThread.status === Thread.STATUS_DONE) {\n                    // Finished with this thread.\n                    stoppedThread = true;\n                    continue;\n                }\n                if (activeThread.status === Thread.STATUS_YIELD_TICK &&\n                    !ranFirstTick) {\n                    // Clear single-tick yield from the last call of `stepThreads`.\n                    activeThread.status = Thread.STATUS_RUNNING;\n                }\n                if (activeThread.status === Thread.STATUS_RUNNING ||\n                    activeThread.status === Thread.STATUS_YIELD) {\n                    // Normal-mode thread: step.\n                    if (this.runtime.profiler !== null) {\n                        if (stepThreadProfilerId === -1) {\n                            stepThreadProfilerId = this.runtime.profiler.idByName(stepThreadProfilerFrame);\n                        }\n\n                        // Increment the number of times stepThread is called.\n                        this.runtime.profiler.increment(stepThreadProfilerId);\n                    }\n                    this.stepThread(activeThread);\n                    activeThread.warpTimer = null;\n                    if (activeThread.isKilled) {\n                        i--; // if the thread is removed from the list (killed), do not increase index\n                    }\n                }\n                if (activeThread.status === Thread.STATUS_RUNNING) {\n                    numActiveThreads++;\n                }\n                // Check if the thread completed while it just stepped to make\n                // sure we remove it before the next iteration of all threads.\n                if (activeThread.stack.length === 0 ||\n                    activeThread.status === Thread.STATUS_DONE) {\n                    // Finished with this thread.\n                    stoppedThread = true;\n                }\n            }\n            // We successfully ticked once. Prevents running STATUS_YIELD_TICK\n            // threads on the next tick.\n            ranFirstTick = true;\n\n            if (this.runtime.profiler !== null) {\n                this.runtime.profiler.stop();\n            }\n\n            // Filter inactive threads from `this.runtime.threads`.\n            if (stoppedThread) {\n                let nextActiveThread = 0;\n                for (let i = 0; i < this.runtime.threads.length; i++) {\n                    const thread = this.runtime.threads[i];\n                    if (thread.stack.length !== 0 &&\n                        thread.status !== Thread.STATUS_DONE) {\n                        this.runtime.threads[nextActiveThread] = thread;\n                        nextActiveThread++;\n                    } else {\n                        doneThreads.push(thread);\n                    }\n                }\n                this.runtime.threads.length = nextActiveThread;\n            }\n        }\n\n        this.activeThread = null;\n\n        return doneThreads;\n    }\n\n    /**\n     * Step the requested thread for as long as necessary.\n     * @param {!Thread} thread Thread object to step.\n     */\n    stepThread (thread) {\n        let currentBlockId = thread.peekStack();\n        if (!currentBlockId) {\n            // A \"null block\" - empty branch.\n            thread.popStack();\n\n            // Did the null follow a hat block?\n            if (thread.stack.length === 0) {\n                thread.status = Thread.STATUS_DONE;\n                return;\n            }\n        }\n        // Save the current block ID to notice if we did control flow.\n        while ((currentBlockId = thread.peekStack())) {\n            let isWarpMode = thread.peekStackFrame().warpMode;\n            if (isWarpMode && !thread.warpTimer) {\n                // Initialize warp-mode timer if it hasn't been already.\n                // This will start counting the thread toward `Sequencer.WARP_TIME`.\n                thread.warpTimer = new Timer();\n                thread.warpTimer.start();\n            }\n            // Execute the current block.\n            if (this.runtime.profiler !== null) {\n                if (executeProfilerId === -1) {\n                    executeProfilerId = this.runtime.profiler.idByName(executeProfilerFrame);\n                }\n\n                // Increment the number of times execute is called.\n                this.runtime.profiler.increment(executeProfilerId);\n            }\n            if (thread.target === null) {\n                this.retireThread(thread);\n            } else {\n                execute(this, thread);\n            }\n            thread.blockGlowInFrame = currentBlockId;\n            // If the thread has yielded or is waiting, yield to other threads.\n            if (thread.status === Thread.STATUS_YIELD) {\n                // Mark as running for next iteration.\n                thread.status = Thread.STATUS_RUNNING;\n                // In warp mode, yielded blocks are re-executed immediately.\n                if (isWarpMode &&\n                    thread.warpTimer.timeElapsed() <= Sequencer.WARP_TIME) {\n                    continue;\n                }\n                return;\n            } else if (thread.status === Thread.STATUS_PROMISE_WAIT) {\n                // A promise was returned by the primitive. Yield the thread\n                // until the promise resolves. Promise resolution should reset\n                // thread.status to Thread.STATUS_RUNNING.\n                return;\n            } else if (thread.status === Thread.STATUS_YIELD_TICK) {\n                // stepThreads will reset the thread to Thread.STATUS_RUNNING\n                return;\n            }\n            // If no control flow has happened, switch to next block.\n            if (thread.peekStack() === currentBlockId) {\n                thread.goToNextBlock();\n            }\n            // If no next block has been found at this point, look on the stack.\n            while (!thread.peekStack()) {\n                thread.popStack();\n\n                if (thread.stack.length === 0) {\n                    // No more stack to run!\n                    thread.status = Thread.STATUS_DONE;\n                    return;\n                }\n\n                const stackFrame = thread.peekStackFrame();\n                isWarpMode = stackFrame.warpMode;\n\n                if (stackFrame.isLoop) {\n                    // The current level of the stack is marked as a loop.\n                    // Return to yield for the frame/tick in general.\n                    // Unless we're in warp mode - then only return if the\n                    // warp timer is up.\n                    if (!isWarpMode ||\n                        thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n                        // Don't do anything to the stack, since loops need\n                        // to be re-executed.\n                        return;\n                    }\n                    // Don't go to the next block for this level of the stack,\n                    // since loops need to be re-executed.\n                    continue;\n\n                } else if (stackFrame.waitingReporter) {\n                    // This level of the stack was waiting for a value.\n                    // This means a reporter has just returned - so don't go\n                    // to the next block for this level of the stack.\n                    return;\n                }\n                // Get next block of existing block on the stack.\n                thread.goToNextBlock();\n            }\n        }\n    }\n\n    /**\n     * Step a thread into a block's branch.\n     * @param {!Thread} thread Thread object to step to branch.\n     * @param {number} branchNum Which branch to step to (i.e., 1, 2).\n     * @param {boolean} isLoop Whether this block is a loop.\n     */\n    stepToBranch (thread, branchNum, isLoop) {\n        if (!branchNum) {\n            branchNum = 1;\n        }\n        const currentBlockId = thread.peekStack();\n        const branchId = thread.target.blocks.getBranch(\n            currentBlockId,\n            branchNum\n        );\n        thread.peekStackFrame().isLoop = isLoop;\n        if (branchId) {\n            // Push branch ID to the thread's stack.\n            thread.pushStack(branchId);\n        } else {\n            thread.pushStack(null);\n        }\n    }\n\n    /**\n     * Step a procedure.\n     * @param {!Thread} thread Thread object to step to procedure.\n     * @param {!string} procedureCode Procedure code of procedure to step to.\n     */\n    stepToProcedure (thread, procedureCode) {\n        const definition = thread.target.blocks.getProcedureDefinition(procedureCode);\n        if (!definition) {\n            return;\n        }\n        // Check if the call is recursive.\n        // If so, set the thread to yield after pushing.\n        const isRecursive = thread.isRecursiveCall(procedureCode);\n        // To step to a procedure, we put its definition on the stack.\n        // Execution for the thread will proceed through the definition hat\n        // and on to the main definition of the procedure.\n        // When that set of blocks finishes executing, it will be popped\n        // from the stack by the sequencer, returning control to the caller.\n        thread.pushStack(definition);\n        // In known warp-mode threads, only yield when time is up.\n        if (thread.peekStackFrame().warpMode &&\n            thread.warpTimer.timeElapsed() > Sequencer.WARP_TIME) {\n            thread.status = Thread.STATUS_YIELD;\n        } else {\n            // Look for warp-mode flag on definition, and set the thread\n            // to warp-mode if needed.\n            const definitionBlock = thread.target.blocks.getBlock(definition);\n            const innerBlock = thread.target.blocks.getBlock(\n                definitionBlock.inputs.custom_block.block);\n            let doWarp = false;\n            if (innerBlock && innerBlock.mutation) {\n                const warp = innerBlock.mutation.warp;\n                if (typeof warp === 'boolean') {\n                    doWarp = warp;\n                } else if (typeof warp === 'string') {\n                    doWarp = JSON.parse(warp);\n                }\n            }\n            if (doWarp) {\n                thread.peekStackFrame().warpMode = true;\n            } else if (isRecursive) {\n                // In normal-mode threads, yield any time we have a recursive call.\n                thread.status = Thread.STATUS_YIELD;\n            }\n        }\n    }\n\n    /**\n     * Retire a thread in the middle, without considering further blocks.\n     * @param {!Thread} thread Thread object to retire.\n     */\n    retireThread (thread) {\n        thread.stack = [];\n        thread.stackFrame = [];\n        thread.requestScriptGlowInFrame = false;\n        thread.status = Thread.STATUS_DONE;\n    }\n}\n\nmodule.exports = Sequencer;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/sequencer.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/stage-layering.js":
/*!**************************************************!*\
  !*** ../scratch-vm/src/engine/stage-layering.js ***!
  \**************************************************/
/***/ ((module) => {

eval("class StageLayering {\n    static get BACKGROUND_LAYER () {\n        return 'background';\n    }\n\n    static get VIDEO_LAYER () {\n        return 'video';\n    }\n\n    static get PEN_LAYER () {\n        return 'pen';\n    }\n\n    static get SPRITE_LAYER () {\n        return 'sprite';\n    }\n\n    // Order of layer groups relative to each other,\n    static get LAYER_GROUPS () {\n        return [\n            StageLayering.BACKGROUND_LAYER,\n            StageLayering.VIDEO_LAYER,\n            StageLayering.PEN_LAYER,\n            StageLayering.SPRITE_LAYER\n        ];\n    }\n}\n\nmodule.exports = StageLayering;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/stage-layering.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/target.js":
/*!******************************************!*\
  !*** ../scratch-vm/src/engine/target.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = __webpack_require__(/*! events */ \"events\");\n\nconst Blocks = __webpack_require__(/*! ./blocks */ \"../scratch-vm/src/engine/blocks.js\");\nconst Variable = __webpack_require__(/*! ../engine/variable */ \"../scratch-vm/src/engine/variable.js\");\nconst Comment = __webpack_require__(/*! ../engine/comment */ \"../scratch-vm/src/engine/comment.js\");\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\nconst {Map} = __webpack_require__(/*! immutable */ \"../scratch-vm/node_modules/immutable/dist/immutable.js\");\nconst log = __webpack_require__(/*! ../util/log */ \"../scratch-vm/src/util/log.js\");\nconst StringUtil = __webpack_require__(/*! ../util/string-util */ \"../scratch-vm/src/util/string-util.js\");\nconst VariableUtil = __webpack_require__(/*! ../util/variable-util */ \"../scratch-vm/src/util/variable-util.js\");\n\n/**\n * @fileoverview\n * A Target is an abstract \"code-running\" object for the Scratch VM.\n * Examples include sprites/clones or potentially physical-world devices.\n */\n\nclass Target extends EventEmitter {\n\n    /**\n     * @param {Runtime} runtime Reference to the runtime.\n     * @param {?Blocks} blocks Blocks instance for the blocks owned by this target.\n     * @constructor\n     */\n    constructor (runtime, blocks) {\n        super();\n\n        if (!blocks) {\n            blocks = new Blocks(runtime);\n        }\n\n        /**\n         * Reference to the runtime.\n         * @type {Runtime}\n         */\n        this.runtime = runtime;\n        /**\n         * A unique ID for this target.\n         * @type {string}\n         */\n        this.id = uid();\n        /**\n         * Blocks run as code for this target.\n         * @type {!Blocks}\n         */\n        this.blocks = blocks;\n        /**\n         * Dictionary of variables and their values for this target.\n         * Key is the variable id.\n         * @type {Object.<string,*>}\n         */\n        this.variables = {};\n        /**\n         * Dictionary of comments for this target.\n         * Key is the comment id.\n         * @type {Object.<string,*>}\n         */\n        this.comments = {};\n        /**\n         * Dictionary of custom state for this target.\n         * This can be used to store target-specific custom state for blocks which need it.\n         * TODO: do we want to persist this in SB3 files?\n         * @type {Object.<string,*>}\n         */\n        this._customState = {};\n\n        /**\n         * Currently known values for edge-activated hats.\n         * Keys are block ID for the hat; values are the currently known values.\n         * @type {Object.<string, *>}\n         */\n        this._edgeActivatedHatValues = {};\n    }\n\n    /**\n     * Called when the project receives a \"green flag.\"\n     * @abstract\n     */\n    onGreenFlag () {}\n\n    /**\n     * Return a human-readable name for this target.\n     * Target implementations should override this.\n     * @abstract\n     * @returns {string} Human-readable name for the target.\n     */\n    getName () {\n        return this.id;\n    }\n\n    /**\n     * Update an edge-activated hat block value.\n     * @param {!string} blockId ID of hat to store value for.\n     * @param {*} newValue Value to store for edge-activated hat.\n     * @return {*} The old value for the edge-activated hat.\n     */\n    updateEdgeActivatedValue (blockId, newValue) {\n        const oldValue = this._edgeActivatedHatValues[blockId];\n        this._edgeActivatedHatValues[blockId] = newValue;\n        return oldValue;\n    }\n\n    hasEdgeActivatedValue (blockId) {\n        return Object.prototype.hasOwnProperty.call(this._edgeActivatedHatValues, blockId);\n    }\n\n    /**\n     * Clear all edge-activaed hat values.\n     */\n    clearEdgeActivatedValues () {\n        this._edgeActivatedHatValues = {};\n    }\n\n    /**\n     * Look up a variable object, first by id, and then by name if the id is not found.\n     * Create a new variable if both lookups fail.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n    lookupOrCreateVariable (id, name) {\n        let variable = this.lookupVariableById(id);\n        if (variable) return variable;\n\n        variable = this.lookupVariableByNameAndType(name, Variable.SCALAR_TYPE);\n        if (variable) return variable;\n\n        // No variable with this name exists - create it locally.\n        const newVariable = new Variable(id, name, Variable.SCALAR_TYPE, false);\n        this.variables[id] = newVariable;\n        return newVariable;\n    }\n\n    /**\n     * Look up a broadcast message object with the given id and return it\n     * if it exists.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n    lookupBroadcastMsg (id, name) {\n        let broadcastMsg;\n        if (id) {\n            broadcastMsg = this.lookupVariableById(id);\n        } else if (name) {\n            broadcastMsg = this.lookupBroadcastByInputValue(name);\n        } else {\n            log.error('Cannot find broadcast message if neither id nor name are provided.');\n        }\n        if (broadcastMsg) {\n            if (name && (broadcastMsg.name.toLowerCase() !== name.toLowerCase())) {\n                log.error(`Found broadcast message with id: ${id}, but` +\n                    `its name, ${broadcastMsg.name} did not match expected name ${name}.`);\n            }\n            if (broadcastMsg.type !== Variable.BROADCAST_MESSAGE_TYPE) {\n                log.error(`Found variable with id: ${id}, but its type ${broadcastMsg.type}` +\n                    `did not match expected type ${Variable.BROADCAST_MESSAGE_TYPE}`);\n            }\n            return broadcastMsg;\n        }\n    }\n\n    /**\n     * Look up a broadcast message with the given name and return the variable\n     * if it exists. Does not create a new broadcast message variable if\n     * it doesn't exist.\n     * @param {string} name Name of the variable.\n     * @return {?Variable} Variable object.\n     */\n    lookupBroadcastByInputValue (name) {\n        const vars = this.variables;\n        for (const propName in vars) {\n            if ((vars[propName].type === Variable.BROADCAST_MESSAGE_TYPE) &&\n                (vars[propName].name.toLowerCase() === name.toLowerCase())) {\n                return vars[propName];\n            }\n        }\n    }\n\n    /**\n     * Look up a variable object.\n     * Search begins for local variables; then look for globals.\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @return {!Variable} Variable object.\n     */\n    lookupVariableById (id) {\n        // If we have a local copy, return it.\n        if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n            return this.variables[id];\n        }\n        // If the stage has a global copy, return it.\n        if (this.runtime && !this.isStage) {\n            const stage = this.runtime.getTargetForStage();\n            if (stage && Object.prototype.hasOwnProperty.call(stage.variables, id)) {\n                return stage.variables[id];\n            }\n        }\n    }\n\n    /**\n     * Look up a variable object by its name and variable type.\n     * Search begins with local variables; then global variables if a local one\n     * was not found.\n     * @param {string} name Name of the variable.\n     * @param {string} type Type of the variable. Defaults to Variable.SCALAR_TYPE.\n     * @param {?bool} skipStage Optional flag to skip checking the stage\n     * @return {?Variable} Variable object if found, or null if not.\n     */\n    lookupVariableByNameAndType (name, type, skipStage) {\n        if (typeof name !== 'string') return;\n        if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n        skipStage = skipStage || false;\n\n        for (const varId in this.variables) {\n            const currVar = this.variables[varId];\n            if (currVar.name === name && currVar.type === type) {\n                return currVar;\n            }\n        }\n\n        if (!skipStage && this.runtime && !this.isStage) {\n            const stage = this.runtime.getTargetForStage();\n            if (stage) {\n                for (const varId in stage.variables) {\n                    const currVar = stage.variables[varId];\n                    if (currVar.name === name && currVar.type === type) {\n                        return currVar;\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n    * Look up a list object for this target, and create it if one doesn't exist.\n    * Search begins for local lists; then look for globals.\n    * @param {!string} id Id of the list.\n    * @param {!string} name Name of the list.\n    * @return {!Varible} Variable object representing the found/created list.\n     */\n    lookupOrCreateList (id, name) {\n        let list = this.lookupVariableById(id);\n        if (list) return list;\n\n        list = this.lookupVariableByNameAndType(name, Variable.LIST_TYPE);\n        if (list) return list;\n\n        // No variable with this name exists - create it locally.\n        const newList = new Variable(id, name, Variable.LIST_TYPE, false);\n        this.variables[id] = newList;\n        return newList;\n    }\n\n    /**\n     * Creates a variable with the given id and name and adds it to the\n     * dictionary of variables.\n     * @param {string} id Id of variable\n     * @param {string} name Name of variable.\n     * @param {string} type Type of variable, '', 'broadcast_msg', or 'list'\n     * @param {boolean} isCloud Whether the variable to create has the isCloud flag set.\n     * Additional checks are made that the variable can be created as a cloud variable.\n     */\n    createVariable (id, name, type, isCloud) {\n        if (!Object.prototype.hasOwnProperty.call(this.variables, id)) {\n            const newVariable = new Variable(id, name, type, false);\n            if (isCloud && this.isStage && this.runtime.canAddCloudVariable()) {\n                newVariable.isCloud = true;\n                this.runtime.addCloudVariable();\n                this.runtime.ioDevices.cloud.requestCreateVariable(newVariable);\n            }\n            this.variables[id] = newVariable;\n        }\n    }\n\n    /**\n     * Creates a comment with the given properties.\n     * @param {string} id Id of the comment.\n     * @param {string} blockId Optional id of the block the comment is attached\n     * to if it is a block comment.\n     * @param {string} text The text the comment contains.\n     * @param {number} x The x coordinate of the comment on the workspace.\n     * @param {number} y The y coordinate of the comment on the workspace.\n     * @param {number} width The width of the comment when it is full size\n     * @param {number} height The height of the comment when it is full size\n     * @param {boolean} minimized Whether the comment is minimized.\n     */\n    createComment (id, blockId, text, x, y, width, height, minimized) {\n        if (!Object.prototype.hasOwnProperty.call(this.comments, id)) {\n            const newComment = new Comment(id, text, x, y,\n                width, height, minimized);\n            if (blockId) {\n                newComment.blockId = blockId;\n                const blockWithComment = this.blocks.getBlock(blockId);\n                if (blockWithComment) {\n                    blockWithComment.comment = id;\n                } else {\n                    log.warn(`Could not find block with id ${blockId\n                    } associated with commentId: ${id}`);\n                }\n            }\n            this.comments[id] = newComment;\n        }\n    }\n\n    /**\n     * Renames the variable with the given id to newName.\n     * @param {string} id Id of variable to rename.\n     * @param {string} newName New name for the variable.\n     */\n    renameVariable (id, newName) {\n        if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n            const variable = this.variables[id];\n            if (variable.id === id) {\n                const oldName = variable.name;\n                variable.name = newName;\n\n                if (this.runtime) {\n                    if (variable.isCloud && this.isStage) {\n                        this.runtime.ioDevices.cloud.requestRenameVariable(oldName, newName);\n                    }\n\n                    if (variable.type === Variable.SCALAR_TYPE) {\n                        // sensing__of may be referencing to this variable.\n                        // Change the reference.\n                        let blockUpdated = false;\n                        this.runtime.targets.forEach(t => {\n                            blockUpdated = t.blocks.updateSensingOfReference(\n                                oldName,\n                                newName,\n                                this.isStage ? '_stage_' : this.getName()\n                            ) || blockUpdated;\n                        });\n                        // Request workspace change only if sensing_of blocks were actually updated.\n                        if (blockUpdated) this.runtime.requestBlocksUpdate();\n                    }\n\n                    const blocks = this.runtime.monitorBlocks;\n                    blocks.changeBlock({\n                        id: id,\n                        element: 'field',\n                        name: variable.type === Variable.LIST_TYPE ? 'LIST' : 'VARIABLE',\n                        value: id\n                    }, this.runtime);\n                    const monitorBlock = blocks.getBlock(variable.id);\n                    if (monitorBlock) {\n                        this.runtime.requestUpdateMonitor(Map({\n                            id: id,\n                            params: blocks._getBlockParams(monitorBlock)\n                        }));\n                    }\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Removes the variable with the given id from the dictionary of variables.\n     * @param {string} id Id of variable to delete.\n     */\n    deleteVariable (id) {\n        if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n            // Get info about the variable before deleting it\n            const deletedVariableName = this.variables[id].name;\n            const deletedVariableWasCloud = this.variables[id].isCloud;\n            delete this.variables[id];\n            if (this.runtime) {\n                if (deletedVariableWasCloud && this.isStage) {\n                    this.runtime.ioDevices.cloud.requestDeleteVariable(deletedVariableName);\n                    this.runtime.removeCloudVariable();\n                }\n                this.runtime.monitorBlocks.deleteBlock(id);\n                this.runtime.requestRemoveMonitor(id);\n            }\n        }\n    }\n\n    /**\n     * Remove this target's monitors from the runtime state and remove the\n     * target-specific monitored blocks (e.g. local variables, global variables for the stage, x-position).\n     * NOTE: This does not delete any of the stage monitors like backdrop name.\n     */\n    deleteMonitors () {\n        this.runtime.requestRemoveMonitorByTargetId(this.id);\n        let targetSpecificMonitorBlockIds;\n        if (this.isStage) {\n            // This only deletes global variables and not other stage monitors like backdrop number.\n            targetSpecificMonitorBlockIds = Object.keys(this.variables);\n        } else {\n            targetSpecificMonitorBlockIds = Object.keys(this.runtime.monitorBlocks._blocks)\n                .filter(key => this.runtime.monitorBlocks._blocks[key].targetId === this.id);\n        }\n        for (const blockId of targetSpecificMonitorBlockIds) {\n            this.runtime.monitorBlocks.deleteBlock(blockId);\n        }\n    }\n\n    /**\n     * Create a clone of the variable with the given id from the dictionary of\n     * this target's variables.\n     * @param {string} id Id of variable to duplicate.\n     * @param {boolean=} optKeepOriginalId Optional flag to keep the original variable ID\n     * for the duplicate variable. This is necessary when cloning a sprite, for example.\n     * @return {?Variable} The duplicated variable, or null if\n     * the original variable was not found.\n     */\n    duplicateVariable (id, optKeepOriginalId) {\n        if (Object.prototype.hasOwnProperty.call(this.variables, id)) {\n            const originalVariable = this.variables[id];\n            const newVariable = new Variable(\n                optKeepOriginalId ? id : null, // conditionally keep original id or generate a new one\n                originalVariable.name,\n                originalVariable.type,\n                originalVariable.isCloud\n            );\n            if (newVariable.type === Variable.LIST_TYPE) {\n                newVariable.value = originalVariable.value.slice(0);\n            } else {\n                newVariable.value = originalVariable.value;\n            }\n            return newVariable;\n        }\n        return null;\n    }\n\n    /**\n     * Duplicate the dictionary of this target's variables as part of duplicating.\n     * this target or making a clone.\n     * @param {object=} optBlocks Optional block container for the target being duplicated.\n     * If provided, new variables will be generated with new UIDs and any variable references\n     * in this blocks container will be updated to refer to the corresponding new IDs.\n     * @return {object} The duplicated dictionary of variables\n     */\n    duplicateVariables (optBlocks) {\n        let allVarRefs;\n        if (optBlocks) {\n            allVarRefs = optBlocks.getAllVariableAndListReferences();\n        }\n        return Object.keys(this.variables).reduce((accum, varId) => {\n            const newVariable = this.duplicateVariable(varId, !optBlocks);\n            accum[newVariable.id] = newVariable;\n            if (optBlocks && allVarRefs) {\n                const currVarRefs = allVarRefs[varId];\n                if (currVarRefs) {\n                    this.mergeVariables(varId, newVariable.id, currVarRefs);\n                }\n            }\n            return accum;\n        }, {});\n    }\n\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     * @abstract\n     */\n    postSpriteInfo () {}\n\n    /**\n     * Retrieve custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to retrieve.\n     * @returns {*} the associated state, if any was found.\n     */\n    getCustomState (stateId) {\n        return this._customState[stateId];\n    }\n\n    /**\n     * Store custom state associated with this target and the provided state ID.\n     * @param {string} stateId - specify which piece of state to store on this target.\n     * @param {*} newValue - the state value to store.\n     */\n    setCustomState (stateId, newValue) {\n        this._customState[stateId] = newValue;\n    }\n\n    /**\n     * Call to destroy a target.\n     * @abstract\n     */\n    dispose () {\n        this._customState = {};\n\n        if (this.runtime) {\n            this.runtime.removeExecutable(this);\n        }\n    }\n\n    // Variable Conflict Resolution Helpers\n\n    /**\n     * Get the names of all the variables of the given type that are in scope for this target.\n     * For targets that are not the stage, this includes any target-specific\n     * variables as well as any stage variables unless the skipStage flag is true.\n     * For the stage, this is all stage variables.\n     * @param {string} type The variable type to search for; defaults to Variable.SCALAR_TYPE\n     * @param {?bool} skipStage Optional flag to skip the stage.\n     * @return {Array<string>} A list of variable names\n     */\n    getAllVariableNamesInScopeByType (type, skipStage) {\n        if (typeof type !== 'string') type = Variable.SCALAR_TYPE;\n        skipStage = skipStage || false;\n        const targetVariables = Object.values(this.variables)\n            .filter(v => v.type === type)\n            .map(variable => variable.name);\n        if (skipStage || this.isStage || !this.runtime) {\n            return targetVariables;\n        }\n        const stage = this.runtime.getTargetForStage();\n        const stageVariables = stage.getAllVariableNamesInScopeByType(type);\n        return targetVariables.concat(stageVariables);\n    }\n\n    /**\n     * Merge variable references with another variable.\n     * @param {string} idToBeMerged ID of the variable whose references need to be updated\n     * @param {string} idToMergeWith ID of the variable that the old references should be replaced with\n     * @param {?Array<Object>} optReferencesToUpdate Optional context of the change.\n     * Defaults to all the blocks in this target.\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n    mergeVariables (idToBeMerged, idToMergeWith, optReferencesToUpdate, optNewName) {\n        const referencesToChange = optReferencesToUpdate ||\n            // TODO should there be a separate helper function that traverses the blocks\n            // for all references for a given ID instead of doing the below..?\n            this.blocks.getAllVariableAndListReferences()[idToBeMerged];\n\n        VariableUtil.updateVariableIdentifiers(referencesToChange, idToMergeWith, optNewName);\n    }\n\n    /**\n     * Share a local variable (and given references for that variable) to the stage.\n     * @param {string} varId The ID of the variable to share.\n     * @param {Array<object>} varRefs The list of variable references being shared,\n     * that reference the given variable ID. The names and IDs of these variable\n     * references will be updated to refer to the new (or pre-existing) global variable.\n     */\n    shareLocalVariableToStage (varId, varRefs) {\n        if (!this.runtime) return;\n        const variable = this.variables[varId];\n        if (!variable) {\n            log.warn(`Cannot share a local variable to the stage if it's not local.`);\n            return;\n        }\n        const stage = this.runtime.getTargetForStage();\n        // If a local var is being shared with the stage,\n        // sharing will make the variable global, resulting in a conflict\n        // with the existing local variable. Preemptively Resolve this conflict\n        // by renaming the new global variable.\n\n        // First check if we've already done the local to global transition for this\n        // variable. If we have, merge it with the global variable we've already created.\n        const varIdForStage = `StageVarFromLocal_${varId}`;\n        let stageVar = stage.lookupVariableById(varIdForStage);\n        // If a global var doesn't already exist, create a new one with a fresh name.\n        // Use the ID we created above so that we can lookup this new variable in the\n        // future if we decide to share this same variable again.\n        if (!stageVar) {\n            const varName = variable.name;\n            const varType = variable.type;\n\n            const newStageName = `Stage: ${varName}`;\n            stageVar = this.runtime.createNewGlobalVariable(newStageName, varIdForStage, varType);\n        }\n        // Update all variable references to use the new name and ID\n        this.mergeVariables(varId, stageVar.id, varRefs, stageVar.name);\n    }\n\n    /**\n     * Share a local variable with a sprite, merging with one of the same name and\n     * type if it already exists on the sprite, or create a new one.\n     * @param {string} varId Id of the variable to share\n     * @param {Target} sprite The sprite to share the variable with\n     * @param {Array<object>} varRefs A list of all the variable references currently being shared.\n     */\n    shareLocalVariableToSprite (varId, sprite, varRefs) {\n        if (!this.runtime) return;\n        if (this.isStage) return;\n        const variable = this.variables[varId];\n        if (!variable) {\n            log.warn(`Tried to call 'shareLocalVariableToSprite' with a non-local variable.`);\n            return;\n        }\n        const varName = variable.name;\n        const varType = variable.type;\n        // Check if the receiving sprite already has a variable of the same name and type\n        // and use the existing variable, otherwise create a new one.\n        const existingLocalVar = sprite.lookupVariableByNameAndType(varName, varType);\n        let newVarId;\n        if (existingLocalVar) {\n            newVarId = existingLocalVar.id;\n        } else {\n            const newVar = new Variable(null, varName, varType);\n            newVarId = newVar.id;\n            sprite.variables[newVarId] = newVar;\n        }\n\n        // Merge with the local variable on the new sprite.\n        this.mergeVariables(varId, newVarId, varRefs);\n    }\n\n    /**\n     * Given a list of variable referencing fields, shares those variables with\n     * the target with the provided id, resolving any variable conflicts that arise\n     * using the following rules:\n     *\n     * If this target is the stage, exit. There are no conflicts that arise\n     * from sharing variables from the stage to another sprite. The variables\n     * already exist globally, so no further action is needed.\n     *\n     * If a variable being referenced is a global variable, do nothing. The\n     * global variable already exists so no further action is needed.\n     *\n     * If a variable being referenced is local, and\n     * 1) The receiving target is a sprite:\n     * create a new local variable or merge with an existing local variable\n     * of the same name and type. Update all the referencing fields\n     * for the original variable to reference the new variable.\n     * 2) The receiving target is the stage:\n     * Create a new global variable with a fresh name and update all the referencing\n     * fields to reference the new variable.\n     *\n     * @param {Array<object>} blocks The blocks containing\n     * potential conflicting references to variables.\n     * @param {Target} receivingTarget The target receiving the variables\n     */\n    resolveVariableSharingConflictsWithTarget (blocks, receivingTarget) {\n        if (this.isStage) return;\n\n        // Get all the variable references in the given list of blocks\n        const allVarListRefs = this.blocks.getAllVariableAndListReferences(blocks);\n\n        // For all the variables being referenced, check for which ones are local\n        // to this target, and resolve conflicts based on whether the receiving target\n        // is a sprite (with a conflicting local variable) or whether it is\n        // the stage (which cannot have local variables)\n        for (const varId in allVarListRefs) {\n            const currVar = this.variables[varId];\n            if (!currVar) continue; // The current variable is global, there shouldn't be any conflicts here, skip it.\n\n            // Get the list of references for the current variable id\n            const currVarListRefs = allVarListRefs[varId];\n\n            if (receivingTarget.isStage) {\n                this.shareLocalVariableToStage(varId, currVarListRefs);\n            } else {\n                this.shareLocalVariableToSprite(varId, receivingTarget, currVarListRefs);\n            }\n        }\n    }\n\n    /**\n     * Fixes up variable references in this target avoiding conflicts with\n     * pre-existing variables in the same scope.\n     * This is used when uploading this target as a new sprite into an existing\n     * project, where the new sprite may contain references\n     * to variable names that already exist as global variables in the project\n     * (and thus are in scope for variable references in the given sprite).\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable *does not* exist in this target (e.g. it was a global variable in the\n     * project the sprite was originally exported from), merge the variables. This entails\n     * fixing the variable references in this sprite to reference the id of the pre-existing global variable.\n     *\n     * If this target has a block that references an existing global variable and that\n     * variable does exist in the target itself (e.g. it's a local variable in the sprite being uploaded),\n     * then the local variable is renamed to distinguish itself from the pre-existing variable.\n     * All blocks that reference the local variable will be updated to use the new name.\n     */\n    // TODO (#1360) This function is too long, add some helpers for the different chunks and cases...\n    fixUpVariableReferences () {\n        if (!this.runtime) return; // There's no runtime context to conflict with\n        if (this.isStage) return; // Stage can't have variable conflicts with itself (and also can't be uploaded)\n        const stage = this.runtime.getTargetForStage();\n        if (!stage || !stage.variables) return;\n\n        const renameConflictingLocalVar = (id, name, type) => {\n            const conflict = stage.lookupVariableByNameAndType(name, type);\n            if (conflict) {\n                const newName = StringUtil.unusedName(\n                    `${this.getName()}: ${name}`,\n                    this.getAllVariableNamesInScopeByType(type));\n                this.renameVariable(id, newName);\n                return newName;\n            }\n            return null;\n        };\n\n        const allReferences = this.blocks.getAllVariableAndListReferences();\n        const unreferencedLocalVarIds = [];\n        if (Object.keys(this.variables).length > 0) {\n            for (const localVarId in this.variables) {\n                if (!Object.prototype.hasOwnProperty.call(this.variables, localVarId)) continue;\n                if (!allReferences[localVarId]) unreferencedLocalVarIds.push(localVarId);\n            }\n        }\n        const conflictIdsToReplace = Object.create(null);\n        const conflictNamesToReplace = Object.create(null);\n\n        // Cache the list of all variable names by type so that we don't need to\n        // re-calculate this in every iteration of the following loop.\n        const varNamesByType = {};\n        const allVarNames = type => {\n            const namesOfType = varNamesByType[type];\n            if (namesOfType) return namesOfType;\n            varNamesByType[type] = this.runtime.getAllVarNamesOfType(type);\n            return varNamesByType[type];\n        };\n\n        for (const varId in allReferences) {\n            // We don't care about which var ref we get, they should all have the same var info\n            const varRef = allReferences[varId][0];\n            const varName = varRef.referencingField.value;\n            const varType = varRef.type;\n            if (this.lookupVariableById(varId)) {\n                // Found a variable with the id in either the target or the stage,\n                // figure out which one.\n                if (Object.prototype.hasOwnProperty.call(this.variables, varId)) {\n                    // If the target has the variable, then check whether the stage\n                    // has one with the same name and type. If it does, then rename\n                    // this target specific variable so that there is a distinction.\n                    const newVarName = renameConflictingLocalVar(varId, varName, varType);\n\n                    if (newVarName) {\n                        // We are not calling this.blocks.updateBlocksAfterVarRename\n                        // here because it will search through all the blocks. We already\n                        // have access to all the references for this var id.\n                        allReferences[varId].map(ref => {\n                            ref.referencingField.value = newVarName;\n                            return ref;\n                        });\n                    }\n                }\n            } else {\n                // We didn't find the referenced variable id anywhere,\n                // Treat it as a reference to a global variable (from the original\n                // project this sprite was exported from).\n                // Check for whether a global variable of the same name and type exists,\n                // and if so, track it to merge with the existing global in a second pass of the blocks.\n                const existingVar = stage.lookupVariableByNameAndType(varName, varType);\n                if (existingVar) {\n                    if (!conflictIdsToReplace[varId]) {\n                        conflictIdsToReplace[varId] = existingVar.id;\n                    }\n                } else {\n                    // A global variable with the same name did not already exist,\n                    // create a new one such that it does not conflict with any\n                    // names of local variables of the same type.\n                    const allNames = allVarNames(varType);\n                    const freshName = StringUtil.unusedName(varName, allNames);\n                    stage.createVariable(varId, freshName, varType);\n                    if (!conflictNamesToReplace[varId]) {\n                        conflictNamesToReplace[varId] = freshName;\n                    }\n                }\n            }\n        }\n        // Rename any local variables that were missed above because they aren't\n        // referenced by any blocks\n        for (const id in unreferencedLocalVarIds) {\n            const varId = unreferencedLocalVarIds[id];\n            const name = this.variables[varId].name;\n            const type = this.variables[varId].type;\n            renameConflictingLocalVar(varId, name, type);\n        }\n        // Handle global var conflicts with existing global vars (e.g. a sprite is uploaded, and has\n        // blocks referencing some variable that the sprite does not own, and this\n        // variable conflicts with a global var)\n        // In this case, we want to merge the new variable referenes with the\n        // existing global variable\n        for (const conflictId in conflictIdsToReplace) {\n            const existingId = conflictIdsToReplace[conflictId];\n            const referencesToUpdate = allReferences[conflictId];\n            this.mergeVariables(conflictId, existingId, referencesToUpdate);\n        }\n\n        // Handle global var conflicts existing local vars (e.g a sprite is uploaded,\n        // and has blocks referencing some variable that the sprite does not own, and this\n        // variable conflcits with another sprite's local var).\n        // In this case, we want to go through the variable references and update\n        // the name of the variable in that reference.\n        for (const conflictId in conflictNamesToReplace) {\n            const newName = conflictNamesToReplace[conflictId];\n            const referencesToUpdate = allReferences[conflictId];\n            referencesToUpdate.map(ref => {\n                ref.referencingField.value = newName;\n                return ref;\n            });\n        }\n    }\n\n}\n\nmodule.exports = Target;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/target.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/thread.js":
/*!******************************************!*\
  !*** ../scratch-vm/src/engine/thread.js ***!
  \******************************************/
/***/ ((module) => {

eval("/**\n * Recycle bin for empty stackFrame objects\n * @type Array<_StackFrame>\n */\nconst _stackFrameFreeList = [];\n\n/**\n * A frame used for each level of the stack. A general purpose\n * place to store a bunch of execution context and parameters\n * @param {boolean} warpMode Whether this level of the stack is warping\n * @constructor\n * @private\n */\nclass _StackFrame {\n    constructor (warpMode) {\n        /**\n         * Whether this level of the stack is a loop.\n         * @type {boolean}\n         */\n        this.isLoop = false;\n\n        /**\n         * Whether this level is in warp mode.  Is set by some legacy blocks and\n         * \"turbo mode\"\n         * @type {boolean}\n         */\n        this.warpMode = warpMode;\n\n        /**\n         * Reported value from just executed block.\n         * @type {Any}\n         */\n        this.justReported = null;\n\n        /**\n         * The active block that is waiting on a promise.\n         * @type {string}\n         */\n        this.reporting = '';\n\n        /**\n         * Persists reported inputs during async block.\n         * @type {Object}\n         */\n        this.reported = null;\n\n        /**\n         * Name of waiting reporter.\n         * @type {string}\n         */\n        this.waitingReporter = null;\n\n        /**\n         * Procedure parameters.\n         * @type {Object}\n         */\n        this.params = null;\n\n        /**\n         * A context passed to block implementations.\n         * @type {Object}\n         */\n        this.executionContext = null;\n    }\n\n    /**\n     * Reset all properties of the frame to pristine null and false states.\n     * Used to recycle.\n     * @return {_StackFrame} this\n     */\n    reset () {\n\n        this.isLoop = false;\n        this.warpMode = false;\n        this.justReported = null;\n        this.reported = null;\n        this.waitingReporter = null;\n        this.params = null;\n        this.executionContext = null;\n\n        return this;\n    }\n\n    /**\n     * Reuse an active stack frame in the stack.\n     * @param {?boolean} warpMode defaults to current warpMode\n     * @returns {_StackFrame} this\n     */\n    reuse (warpMode = this.warpMode) {\n        this.reset();\n        this.warpMode = Boolean(warpMode);\n        return this;\n    }\n\n    /**\n     * Create or recycle a stack frame object.\n     * @param {boolean} warpMode Enable warpMode on this frame.\n     * @returns {_StackFrame} The clean stack frame with correct warpMode setting.\n     */\n    static create (warpMode) {\n        const stackFrame = _stackFrameFreeList.pop();\n        if (typeof stackFrame !== 'undefined') {\n            stackFrame.warpMode = Boolean(warpMode);\n            return stackFrame;\n        }\n        return new _StackFrame(warpMode);\n    }\n\n    /**\n     * Put a stack frame object into the recycle bin for reuse.\n     * @param {_StackFrame} stackFrame The frame to reset and recycle.\n     */\n    static release (stackFrame) {\n        if (typeof stackFrame !== 'undefined') {\n            _stackFrameFreeList.push(stackFrame.reset());\n        }\n    }\n}\n\n/**\n * A thread is a running stack context and all the metadata needed.\n * @param {?string} firstBlock First block to execute in the thread.\n * @constructor\n */\nclass Thread {\n    constructor (firstBlock) {\n        /**\n         * ID of top block of the thread\n         * @type {!string}\n         */\n        this.topBlock = firstBlock;\n\n        /**\n         * Stack for the thread. When the sequencer enters a control structure,\n         * the block is pushed onto the stack so we know where to exit.\n         * @type {Array.<string>}\n         */\n        this.stack = [];\n\n        /**\n         * Stack frames for the thread. Store metadata for the executing blocks.\n         * @type {Array.<_StackFrame>}\n         */\n        this.stackFrames = [];\n\n        /**\n         * Status of the thread, one of three states (below)\n         * @type {number}\n         */\n        this.status = 0; /* Thread.STATUS_RUNNING */\n\n        /**\n         * Whether the thread is killed in the middle of execution.\n         * @type {boolean}\n         */\n        this.isKilled = false;\n\n        /**\n         * Target of this thread.\n         * @type {?Target}\n         */\n        this.target = null;\n\n        /**\n         * The Blocks this thread will execute.\n         * @type {Blocks}\n         */\n        this.blockContainer = null;\n\n        /**\n         * Whether the thread requests its script to glow during this frame.\n         * @type {boolean}\n         */\n        this.requestScriptGlowInFrame = false;\n\n        /**\n         * Which block ID should glow during this frame, if any.\n         * @type {?string}\n         */\n        this.blockGlowInFrame = null;\n\n        /**\n         * A timer for when the thread enters warp mode.\n         * Substitutes the sequencer's count toward WORK_TIME on a per-thread basis.\n         * @type {?Timer}\n         */\n        this.warpTimer = null;\n\n        this.justReported = null;\n    }\n\n    /**\n     * Thread status for initialized or running thread.\n     * This is the default state for a thread - execution should run normally,\n     * stepping from block to block.\n     * @const\n     */\n    static get STATUS_RUNNING () {\n        return 0;\n    }\n\n    /**\n     * Threads are in this state when a primitive is waiting on a promise;\n     * execution is paused until the promise changes thread status.\n     * @const\n     */\n    static get STATUS_PROMISE_WAIT () {\n        return 1;\n    }\n\n    /**\n     * Thread status for yield.\n     * @const\n     */\n    static get STATUS_YIELD () {\n        return 2;\n    }\n\n    /**\n     * Thread status for a single-tick yield. This will be cleared when the\n     * thread is resumed.\n     * @const\n     */\n    static get STATUS_YIELD_TICK () {\n        return 3;\n    }\n\n    /**\n     * Thread status for a finished/done thread.\n     * Thread is in this state when there are no more blocks to execute.\n     * @const\n     */\n    static get STATUS_DONE () {\n        return 4;\n    }\n\n    /**\n     * Push stack and update stack frames appropriately.\n     * @param {string} blockId Block ID to push to stack.\n     */\n    pushStack (blockId) {\n        this.stack.push(blockId);\n        // Push an empty stack frame, if we need one.\n        // Might not, if we just popped the stack.\n        if (this.stack.length > this.stackFrames.length) {\n            const parent = this.stackFrames[this.stackFrames.length - 1];\n            this.stackFrames.push(_StackFrame.create(typeof parent !== 'undefined' && parent.warpMode));\n        }\n    }\n\n    /**\n     * Reset the stack frame for use by the next block.\n     * (avoids popping and re-pushing a new stack frame - keeps the warpmode the same\n     * @param {string} blockId Block ID to push to stack.\n     */\n    reuseStackForNextBlock (blockId) {\n        this.stack[this.stack.length - 1] = blockId;\n        this.stackFrames[this.stackFrames.length - 1].reuse();\n    }\n\n    /**\n     * Pop last block on the stack and its stack frame.\n     * @return {string} Block ID popped from the stack.\n     */\n    popStack () {\n        _StackFrame.release(this.stackFrames.pop());\n        return this.stack.pop();\n    }\n\n    /**\n     * Pop back down the stack frame until we hit a procedure call or the stack frame is emptied\n     */\n    stopThisScript () {\n        let blockID = this.peekStack();\n        while (blockID !== null) {\n            const block = this.target.blocks.getBlock(blockID);\n            if (typeof block !== 'undefined' && block.opcode === 'procedures_call') {\n                break;\n            }\n            this.popStack();\n            blockID = this.peekStack();\n        }\n\n        if (this.stack.length === 0) {\n            // Clean up!\n            this.requestScriptGlowInFrame = false;\n            this.status = Thread.STATUS_DONE;\n        }\n    }\n\n    /**\n     * Get top stack item.\n     * @return {?string} Block ID on top of stack.\n     */\n    peekStack () {\n        return this.stack.length > 0 ? this.stack[this.stack.length - 1] : null;\n    }\n\n\n    /**\n     * Get top stack frame.\n     * @return {?object} Last stack frame stored on this thread.\n     */\n    peekStackFrame () {\n        return this.stackFrames.length > 0 ? this.stackFrames[this.stackFrames.length - 1] : null;\n    }\n\n    /**\n     * Get stack frame above the current top.\n     * @return {?object} Second to last stack frame stored on this thread.\n     */\n    peekParentStackFrame () {\n        return this.stackFrames.length > 1 ? this.stackFrames[this.stackFrames.length - 2] : null;\n    }\n\n    /**\n     * Push a reported value to the parent of the current stack frame.\n     * @param {*} value Reported value to push.\n     */\n    pushReportedValue (value) {\n        this.justReported = typeof value === 'undefined' ? null : value;\n    }\n\n    /**\n     * Initialize procedure parameters on this stack frame.\n     */\n    initParams () {\n        const stackFrame = this.peekStackFrame();\n        if (stackFrame.params === null) {\n            stackFrame.params = {};\n        }\n    }\n\n    /**\n     * Add a parameter to the stack frame.\n     * Use when calling a procedure with parameter values.\n     * @param {!string} paramName Name of parameter.\n     * @param {*} value Value to set for parameter.\n     */\n    pushParam (paramName, value) {\n        const stackFrame = this.peekStackFrame();\n        stackFrame.params[paramName] = value;\n    }\n\n    /**\n     * Get a parameter at the lowest possible level of the stack.\n     * @param {!string} paramName Name of parameter.\n     * @return {*} value Value for parameter.\n     */\n    getParam (paramName) {\n        for (let i = this.stackFrames.length - 1; i >= 0; i--) {\n            const frame = this.stackFrames[i];\n            if (frame.params === null) {\n                continue;\n            }\n            if (Object.prototype.hasOwnProperty.call(frame.params, paramName)) {\n                return frame.params[paramName];\n            }\n            return null;\n        }\n        return null;\n    }\n\n    /**\n     * Whether the current execution of a thread is at the top of the stack.\n     * @return {boolean} True if execution is at top of the stack.\n     */\n    atStackTop () {\n        return this.peekStack() === this.topBlock;\n    }\n\n\n    /**\n     * Switch the thread to the next block at the current level of the stack.\n     * For example, this is used in a standard sequence of blocks,\n     * where execution proceeds from one block to the next.\n     */\n    goToNextBlock () {\n        const nextBlockId = this.target.blocks.getNextBlock(this.peekStack());\n        this.reuseStackForNextBlock(nextBlockId);\n    }\n\n    /**\n     * Attempt to determine whether a procedure call is recursive,\n     * by examining the stack.\n     * @param {!string} procedureCode Procedure code of procedure being called.\n     * @return {boolean} True if the call appears recursive.\n     */\n    isRecursiveCall (procedureCode) {\n        let callCount = 5; // Max number of enclosing procedure calls to examine.\n        const sp = this.stack.length - 1;\n        for (let i = sp - 1; i >= 0; i--) {\n            const block = this.target.blocks.getBlock(this.stack[i]);\n            if (block.opcode === 'procedures_call' &&\n                block.mutation.proccode === procedureCode) {\n                return true;\n            }\n            if (--callCount < 0) return false;\n        }\n        return false;\n    }\n}\n\nmodule.exports = Thread;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/thread.js?");

/***/ }),

/***/ "../scratch-vm/src/engine/variable.js":
/*!********************************************!*\
  !*** ../scratch-vm/src/engine/variable.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview\n * Object representing a Scratch variable.\n */\n\nconst uid = __webpack_require__(/*! ../util/uid */ \"../scratch-vm/src/util/uid.js\");\nconst xmlEscape = __webpack_require__(/*! ../util/xml-escape */ \"../scratch-vm/src/util/xml-escape.js\");\n\nclass Variable {\n    /**\n     * @param {string} id Id of the variable.\n     * @param {string} name Name of the variable.\n     * @param {string} type Type of the variable, one of '' or 'list'\n     * @param {boolean} isCloud Whether the variable is stored in the cloud.\n     * @constructor\n     */\n    constructor (id, name, type, isCloud) {\n        this.id = id || uid();\n        this.name = name;\n        this.type = type;\n        this.isCloud = isCloud;\n        switch (this.type) {\n        case Variable.SCALAR_TYPE:\n            this.value = 0;\n            break;\n        case Variable.LIST_TYPE:\n            this.value = [];\n            break;\n        case Variable.BROADCAST_MESSAGE_TYPE:\n            this.value = this.name;\n            break;\n        default:\n            throw new Error(`Invalid variable type: ${this.type}`);\n        }\n    }\n\n    toXML (isLocal) {\n        isLocal = (isLocal === true);\n        return `<variable type=\"${this.type}\" id=\"${this.id}\" islocal=\"${isLocal\n        }\" iscloud=\"${this.isCloud}\">${xmlEscape(this.name)}</variable>`;\n    }\n\n    /**\n     * Type representation for scalar variables.\n     * This is currently represented as ''\n     * for compatibility with blockly.\n     * @const {string}\n     */\n    static get SCALAR_TYPE () {\n        return '';\n    }\n\n    /**\n     * Type representation for list variables.\n     * @const {string}\n     */\n    static get LIST_TYPE () {\n        return 'list';\n    }\n\n    /**\n     * Type representation for list variables.\n     * @const {string}\n     */\n    static get BROADCAST_MESSAGE_TYPE () {\n        return 'broadcast_msg';\n    }\n}\n\nmodule.exports = Variable;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/engine/variable.js?");

/***/ }),

/***/ "../scratch-vm/src/extension-support/argument-type.js":
/*!************************************************************!*\
  !*** ../scratch-vm/src/extension-support/argument-type.js ***!
  \************************************************************/
/***/ ((module) => {

eval("/**\n * Block argument types\n * @enum {string}\n */\nconst ArgumentType = {\n    /**\n     * Numeric value with angle picker\n     */\n    ANGLE: 'angle',\n\n    /**\n     * Boolean value with hexagonal placeholder\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * Numeric value with color picker\n     */\n    COLOR: 'color',\n\n    /**\n     * Numeric value with text field\n     */\n    NUMBER: 'number',\n\n    /**\n     * String value with text field\n     */\n    STRING: 'string',\n\n    /**\n     * String value with matrix field\n     */\n    MATRIX: 'matrix',\n\n    /**\n     * MIDI note number with note picker (piano) field\n     */\n    NOTE: 'note',\n\n    /**\n     * Inline image on block (as part of the label)\n     */\n    IMAGE: 'image'\n};\n\nmodule.exports = ArgumentType;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/extension-support/argument-type.js?");

/***/ }),

/***/ "../scratch-vm/src/extension-support/block-type.js":
/*!*********************************************************!*\
  !*** ../scratch-vm/src/extension-support/block-type.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("/**\n * Types of block\n * @enum {string}\n */\nconst BlockType = {\n    /**\n     * Boolean reporter with hexagonal shape\n     */\n    BOOLEAN: 'Boolean',\n\n    /**\n     * A button (not an actual block) for some special action, like making a variable\n     */\n    BUTTON: 'button',\n\n    /**\n     * Command block\n     */\n    COMMAND: 'command',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * The thread continues with the next block whether or not a child branch ran.\n     */\n    CONDITIONAL: 'conditional',\n\n    /**\n     * Specialized hat block with no implementation function\n     * This stack only runs if the corresponding event is emitted by other code.\n     */\n    EVENT: 'event',\n\n    /**\n     * Hat block which conditionally starts a block stack\n     */\n    HAT: 'hat',\n\n    /**\n     * Specialized command block which may or may not run a child branch\n     * If a child branch runs, the thread evaluates the loop block again.\n     */\n    LOOP: 'loop',\n\n    /**\n     * General reporter with numeric or string value\n     */\n    REPORTER: 'reporter'\n};\n\nmodule.exports = BlockType;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/extension-support/block-type.js?");

/***/ }),

/***/ "../scratch-vm/src/extension-support/target-type.js":
/*!**********************************************************!*\
  !*** ../scratch-vm/src/extension-support/target-type.js ***!
  \**********************************************************/
/***/ ((module) => {

eval("/**\n * Default types of Target supported by the VM\n * @enum {string}\n */\nconst TargetType = {\n    /**\n     * Rendered target which can move, change costumes, etc.\n     */\n    SPRITE: 'sprite',\n\n    /**\n     * Rendered target which cannot move but can change backdrops\n     */\n    STAGE: 'stage'\n};\n\nmodule.exports = TargetType;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/extension-support/target-type.js?");

/***/ }),

/***/ "../scratch-vm/src/io/ble.js":
/*!***********************************!*\
  !*** ../scratch-vm/src/io/ble.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const JSONRPC = __webpack_require__(/*! ../util/jsonrpc */ \"../scratch-vm/src/util/jsonrpc.js\");\n\nclass BLE extends JSONRPC {\n\n    /**\n     * A BLE peripheral socket object.  It handles connecting, over web sockets, to\n     * BLE peripherals, and reading and writing data to them.\n     * @param {Runtime} runtime - the Runtime for sending/receiving GUI update events.\n     * @param {string} extensionId - the id of the extension using this socket.\n     * @param {object} peripheralOptions - the list of options for peripheral discovery.\n     * @param {object} connectCallback - a callback for connection.\n     * @param {object} resetCallback - a callback for resetting extension state.\n     */\n    constructor (runtime, extensionId, peripheralOptions, connectCallback, resetCallback = null) {\n        super();\n\n        this._socket = runtime.getScratchLinkSocket('BLE');\n        this._socket.setOnOpen(this.requestPeripheral.bind(this));\n        this._socket.setOnClose(this.handleDisconnectError.bind(this));\n        this._socket.setOnError(this._handleRequestError.bind(this));\n        this._socket.setHandleMessage(this._handleMessage.bind(this));\n\n        this._sendMessage = this._socket.sendMessage.bind(this._socket);\n\n        this._availablePeripherals = {};\n        this._connectCallback = connectCallback;\n        this._connected = false;\n        this._characteristicDidChangeCallback = null;\n        this._resetCallback = resetCallback;\n        this._discoverTimeoutID = null;\n        this._extensionId = extensionId;\n        this._peripheralOptions = peripheralOptions;\n        this._runtime = runtime;\n\n        this._socket.open();\n    }\n\n    /**\n     * Request connection to the peripheral.\n     * If the web socket is not yet open, request when the socket promise resolves.\n     */\n    requestPeripheral () {\n        this._availablePeripherals = {};\n        if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n        }\n        this._discoverTimeoutID = window.setTimeout(this._handleDiscoverTimeout.bind(this), 15000);\n        this.sendRemoteRequest('discover', this._peripheralOptions)\n            .catch(e => {\n                this._handleRequestError(e);\n            });\n    }\n\n    /**\n     * Try connecting to the input peripheral id, and then call the connect\n     * callback if connection is successful.\n     * @param {number} id - the id of the peripheral to connect to\n     */\n    connectPeripheral (id) {\n        this.sendRemoteRequest('connect', {peripheralId: id})\n            .then(() => {\n                this._connected = true;\n                this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTED);\n                this._connectCallback();\n            })\n            .catch(e => {\n                this._handleRequestError(e);\n            });\n    }\n\n    /**\n     * Close the websocket.\n     */\n    disconnect () {\n        if (this._connected) {\n            this._connected = false;\n        }\n\n        if (this._socket.isOpen()) {\n            this._socket.close();\n        }\n\n        if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n        }\n\n        // Sets connection status icon to orange\n        this._runtime.emit(this._runtime.constructor.PERIPHERAL_DISCONNECTED);\n    }\n\n    /**\n     * @return {bool} whether the peripheral is connected.\n     */\n    isConnected () {\n        return this._connected;\n    }\n\n    /**\n     * Start receiving notifications from the specified ble service.\n     * @param {number} serviceId - the ble service to read.\n     * @param {number} characteristicId - the ble characteristic to get notifications from.\n     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.\n     * @return {Promise} - a promise from the remote startNotifications request.\n     */\n    startNotifications (serviceId, characteristicId, onCharacteristicChanged = null) {\n        const params = {\n            serviceId,\n            characteristicId\n        };\n        this._characteristicDidChangeCallback = onCharacteristicChanged;\n        return this.sendRemoteRequest('startNotifications', params)\n            .catch(e => {\n                this.handleDisconnectError(e);\n            });\n    }\n\n    /**\n     * Read from the specified ble service.\n     * @param {number} serviceId - the ble service to read.\n     * @param {number} characteristicId - the ble characteristic to read.\n     * @param {boolean} optStartNotifications - whether to start receiving characteristic change notifications.\n     * @param {object} onCharacteristicChanged - callback for characteristic change notifications.\n     * @return {Promise} - a promise from the remote read request.\n     */\n    read (serviceId, characteristicId, optStartNotifications = false, onCharacteristicChanged = null) {\n        const params = {\n            serviceId,\n            characteristicId\n        };\n        if (optStartNotifications) {\n            params.startNotifications = true;\n        }\n        if (onCharacteristicChanged) {\n            this._characteristicDidChangeCallback = onCharacteristicChanged;\n        }\n        return this.sendRemoteRequest('read', params)\n            .catch(e => {\n                this.handleDisconnectError(e);\n            });\n    }\n\n    /**\n     * Write data to the specified ble service.\n     * @param {number} serviceId - the ble service to write.\n     * @param {number} characteristicId - the ble characteristic to write.\n     * @param {string} message - the message to send.\n     * @param {string} encoding - the message encoding type.\n     * @param {boolean} withResponse - if true, resolve after peripheral's response.\n     * @return {Promise} - a promise from the remote send request.\n     */\n    write (serviceId, characteristicId, message, encoding = null, withResponse = null) {\n        const params = {serviceId, characteristicId, message};\n        if (encoding) {\n            params.encoding = encoding;\n        }\n        if (withResponse !== null) {\n            params.withResponse = withResponse;\n        }\n        return this.sendRemoteRequest('write', params)\n            .catch(e => {\n                this.handleDisconnectError(e);\n            });\n    }\n\n    /**\n     * Handle a received call from the socket.\n     * @param {string} method - a received method label.\n     * @param {object} params - a received list of parameters.\n     * @return {object} - optional return value.\n     */\n    didReceiveCall (method, params) {\n        switch (method) {\n        case 'didDiscoverPeripheral':\n            this._availablePeripherals[params.peripheralId] = params;\n            this._runtime.emit(\n                this._runtime.constructor.PERIPHERAL_LIST_UPDATE,\n                this._availablePeripherals\n            );\n            if (this._discoverTimeoutID) {\n                window.clearTimeout(this._discoverTimeoutID);\n            }\n            break;\n        case 'userDidPickPeripheral':\n            this._availablePeripherals[params.peripheralId] = params;\n            this._runtime.emit(\n                this._runtime.constructor.USER_PICKED_PERIPHERAL,\n                this._availablePeripherals\n            );\n            if (this._discoverTimeoutID) {\n                window.clearTimeout(this._discoverTimeoutID);\n            }\n            break;\n        case 'userDidNotPickPeripheral':\n            this._runtime.emit(\n                this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT\n            );\n            if (this._discoverTimeoutID) {\n                window.clearTimeout(this._discoverTimeoutID);\n            }\n            break;\n        case 'characteristicDidChange':\n            if (this._characteristicDidChangeCallback) {\n                this._characteristicDidChangeCallback(params.message);\n            }\n            break;\n        case 'ping':\n            return 42;\n        }\n    }\n\n    /**\n     * Handle an error resulting from losing connection to a peripheral.\n     *\n     * This could be due to:\n     * - battery depletion\n     * - going out of bluetooth range\n     * - being powered down\n     *\n     * Disconnect the socket, and if the extension using this socket has a\n     * reset callback, call it. Finally, emit an error to the runtime.\n     */\n    handleDisconnectError (/* e */) {\n        // log.error(`BLE error: ${JSON.stringify(e)}`);\n\n        if (!this._connected) return;\n\n        this.disconnect();\n\n        if (this._resetCallback) {\n            this._resetCallback();\n        }\n\n        this._runtime.emit(this._runtime.constructor.PERIPHERAL_CONNECTION_LOST_ERROR, {\n            message: `Scratch lost connection to`,\n            extensionId: this._extensionId\n        });\n    }\n\n    _handleRequestError (/* e */) {\n        // log.error(`BLE error: ${JSON.stringify(e)}`);\n\n        this._runtime.emit(this._runtime.constructor.PERIPHERAL_REQUEST_ERROR, {\n            message: `Scratch lost connection to`,\n            extensionId: this._extensionId\n        });\n    }\n\n    _handleDiscoverTimeout () {\n        if (this._discoverTimeoutID) {\n            window.clearTimeout(this._discoverTimeoutID);\n        }\n        this._runtime.emit(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT);\n    }\n}\n\nmodule.exports = BLE;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/ble.js?");

/***/ }),

/***/ "../scratch-vm/src/io/clock.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/io/clock.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\n\nclass Clock {\n    constructor (runtime) {\n        this._projectTimer = new Timer({now: () => runtime.currentMSecs});\n        this._projectTimer.start();\n        this._pausedTime = null;\n        this._paused = false;\n        /**\n         * Reference to the owning Runtime.\n         * @type{!Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    projectTimer () {\n        if (this._paused) {\n            return this._pausedTime / 1000;\n        }\n        return this._projectTimer.timeElapsed() / 1000;\n    }\n\n    pause () {\n        this._paused = true;\n        this._pausedTime = this._projectTimer.timeElapsed();\n    }\n\n    resume () {\n        this._paused = false;\n        const dt = this._projectTimer.timeElapsed() - this._pausedTime;\n        this._projectTimer.startTime += dt;\n    }\n\n    resetProjectTimer () {\n        this._projectTimer.start();\n    }\n}\n\nmodule.exports = Clock;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/clock.js?");

/***/ }),

/***/ "../scratch-vm/src/io/cloud.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/io/cloud.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Variable = __webpack_require__(/*! ../engine/variable */ \"../scratch-vm/src/engine/variable.js\");\nconst log = __webpack_require__(/*! ../util/log */ \"../scratch-vm/src/util/log.js\");\n\nclass Cloud {\n    /**\n     * @typedef updateVariable\n     * @param {string} name The name of the cloud variable to update on the server\n     * @param {(string | number)} value The value to update the cloud variable with.\n     */\n\n    /**\n     * A cloud data provider, responsible for managing the connection to the\n     * cloud data server and for posting data about cloud data activity to\n     * this IO device.\n     * @typedef {object} CloudProvider\n     * @property {updateVariable} updateVariable A function which sends a cloud variable\n     * update to the cloud data server.\n     * @property {Function} requestCloseConnection A function which closes\n     * the connection to the cloud data server.\n     */\n\n    /**\n     * Part of a cloud io data post indicating a cloud variable update.\n     * @typedef {object} VarUpdateData\n     * @property {string} name The name of the variable to update\n     * @property {(number | string)} value The scalar value to update the variable with\n     */\n\n    /**\n     * A cloud io data post message.\n     * @typedef {object} CloudIOData\n     * @property {VarUpdateData} varUpdate A {@link VarUpdateData} message indicating\n     * a cloud variable update\n     */\n\n    /**\n     * Cloud IO Device responsible for sending and receiving messages from\n     * cloud provider (mananging the cloud server connection) and interacting\n     * with cloud variables in the current project.\n     * @param {Runtime} runtime The runtime context for this cloud io device.\n     */\n    constructor (runtime) {\n        /**\n         * Reference to the cloud data provider, responsible for mananging\n         * the web socket connection to the cloud data server.\n         * @type {?CloudProvider}\n         */\n        this.provider = null;\n\n        /**\n         * Reference to the runtime that owns this cloud io device.\n         * @type {!Runtime}\n         */\n        this.runtime = runtime;\n\n        /**\n         * Reference to the stage target which owns the cloud variables\n         * in the project.\n         * @type {?Target}\n         */\n        this.stage = null;\n    }\n\n    /**\n     * Set a reference to the cloud data provider.\n     * @param {CloudProvider} provider The cloud data provider\n     */\n    setProvider (provider) {\n        this.provider = provider;\n    }\n\n    /**\n     * Set a reference to the stage target which owns the\n     * cloud variables in the project.\n     * @param {Target} stage The stage target\n     */\n    setStage (stage) {\n        this.stage = stage;\n    }\n\n    /**\n     * Handle incoming data to this io device.\n     * @param {CloudIOData} data The {@link CloudIOData} object to process\n     */\n    postData (data) {\n        if (data.varUpdate) {\n            this.updateCloudVariable(data.varUpdate);\n        }\n    }\n\n    requestCreateVariable (variable) {\n        if (this.runtime.canAddCloudVariable()) {\n            if (this.provider) {\n                this.provider.createVariable(variable.name, variable.value);\n                // We'll set the cloud flag and update the\n                // cloud variable limit when we actually\n                // get a confirmation from the cloud data server\n            }\n        } // TODO else track creation for later\n    }\n\n    /**\n     * Request the cloud data provider to update the given variable with\n     * the given value. Does nothing if this io device does not have a provider set.\n     * @param {string} name The name of the variable to update\n     * @param {string | number} value The value to update the variable with\n     */\n    requestUpdateVariable (name, value) {\n        if (this.provider) {\n            this.provider.updateVariable(name, value);\n        }\n    }\n\n    /**\n     * Request the cloud data provider to rename the variable with the given name\n     * to the given new name. Does nothing if this io device does not have a provider set.\n     * @param {string} oldName The name of the variable to rename\n     * @param {string | number} newName The new name for the variable\n     */\n    requestRenameVariable (oldName, newName) {\n        if (this.provider) {\n            this.provider.renameVariable(oldName, newName);\n        }\n    }\n\n    /**\n     * Request the cloud data provider to delete the variable with the given name\n     * Does nothing if this io device does not have a provider set.\n     * @param {string} name The name of the variable to delete\n     */\n    requestDeleteVariable (name) {\n        if (this.provider) {\n            this.provider.deleteVariable(name);\n        }\n    }\n\n    /**\n     * Update a cloud variable in the runtime based on the message received\n     * from the cloud provider.\n     * @param {VarData} varUpdate A {@link VarData} object describing\n     * a cloud variable update received from the cloud data provider.\n     */\n    updateCloudVariable (varUpdate) {\n        const varName = varUpdate.name;\n\n        const variable = this.stage.lookupVariableByNameAndType(varName, Variable.SCALAR_TYPE);\n        if (!variable || !variable.isCloud) {\n            log.warn(`Received an update for a cloud variable that does not exist: ${varName}`);\n            return;\n        }\n\n        variable.value = varUpdate.value;\n    }\n\n    /**\n     * Request the cloud data provider to close the web socket connection and\n     * clear this io device of references to the cloud data provider and the\n     * stage.\n     */\n    clear () {\n        if (!this.provider) return;\n\n        this.provider.requestCloseConnection();\n        this.provider = null;\n        this.stage = null;\n    }\n}\n\nmodule.exports = Cloud;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/cloud.js?");

/***/ }),

/***/ "../scratch-vm/src/io/keyboard.js":
/*!****************************************!*\
  !*** ../scratch-vm/src/io/keyboard.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\n\n/**\n * Names used internally for keys used in scratch, also known as \"scratch keys\".\n * @enum {string}\n */\nconst KEY_NAME = {\n    SPACE: 'space',\n    LEFT: 'left arrow',\n    UP: 'up arrow',\n    RIGHT: 'right arrow',\n    DOWN: 'down arrow',\n    ENTER: 'enter'\n};\n\n/**\n * An array of the names of scratch keys.\n * @type {Array<string>}\n */\nconst KEY_NAME_LIST = Object.keys(KEY_NAME).map(name => KEY_NAME[name]);\n\nclass Keyboard {\n    constructor (runtime) {\n        /**\n         * List of currently pressed scratch keys.\n         * A scratch key is:\n         * A key you can press on a keyboard, excluding modifier keys.\n         * An uppercase string of length one;\n         *     except for special key names for arrow keys and space (e.g. 'left arrow').\n         * Can be a non-english unicode letter like: æ ø ש נ 手 廿.\n         * @type{Array.<string>}\n         */\n        this._keysPressed = [];\n        /**\n         * Reference to the owning Runtime.\n         * Can be used, for example, to activate hats.\n         * @type{!Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Convert from a keyboard event key name to a Scratch key name.\n     * @param  {string} keyString the input key string.\n     * @return {string} the corresponding Scratch key, or an empty string.\n     */\n    _keyStringToScratchKey (keyString) {\n        keyString = Cast.toString(keyString);\n        // Convert space and arrow keys to their Scratch key names.\n        switch (keyString) {\n        case ' ': return KEY_NAME.SPACE;\n        case 'ArrowLeft':\n        case 'Left': return KEY_NAME.LEFT;\n        case 'ArrowUp':\n        case 'Up': return KEY_NAME.UP;\n        case 'Right':\n        case 'ArrowRight': return KEY_NAME.RIGHT;\n        case 'Down':\n        case 'ArrowDown': return KEY_NAME.DOWN;\n        case 'Enter': return KEY_NAME.ENTER;\n        }\n        // Ignore modifier keys\n        if (keyString.length > 1) {\n            return '';\n        }\n        return keyString.toUpperCase();\n    }\n\n    /**\n     * Convert from a block argument to a Scratch key name.\n     * @param  {string} keyArg the input arg.\n     * @return {string} the corresponding Scratch key.\n     */\n    _keyArgToScratchKey (keyArg) {\n        // If a number was dropped in, try to convert from ASCII to Scratch key.\n        if (typeof keyArg === 'number') {\n            // Check for the ASCII range containing numbers, some punctuation,\n            // and uppercase letters.\n            if (keyArg >= 48 && keyArg <= 90) {\n                return String.fromCharCode(keyArg);\n            }\n            switch (keyArg) {\n            case 32: return KEY_NAME.SPACE;\n            case 37: return KEY_NAME.LEFT;\n            case 38: return KEY_NAME.UP;\n            case 39: return KEY_NAME.RIGHT;\n            case 40: return KEY_NAME.DOWN;\n            }\n        }\n\n        keyArg = Cast.toString(keyArg);\n\n        // If the arg matches a special key name, return it.\n        if (KEY_NAME_LIST.includes(keyArg)) {\n            return keyArg;\n        }\n\n        // Use only the first character.\n        if (keyArg.length > 1) {\n            keyArg = keyArg[0];\n        }\n\n        // Check for the space character.\n        if (keyArg === ' ') {\n            return KEY_NAME.SPACE;\n        }\n\n        return keyArg.toUpperCase();\n    }\n\n    /**\n     * Keyboard DOM event handler.\n     * @param  {object} data Data from DOM event.\n     */\n    postData (data) {\n        if (!data.key) return;\n        const scratchKey = this._keyStringToScratchKey(data.key);\n        if (scratchKey === '') return;\n        const index = this._keysPressed.indexOf(scratchKey);\n        if (data.isDown) {\n            this.runtime.emit('KEY_PRESSED', scratchKey);\n            // If not already present, add to the list.\n            if (index < 0) {\n                this._keysPressed.push(scratchKey);\n            }\n        } else if (index > -1) {\n            // If already present, remove from the list.\n            this._keysPressed.splice(index, 1);\n        }\n    }\n\n    /**\n     * Get key down state for a specified key.\n     * @param  {Any} keyArg key argument.\n     * @return {boolean} Is the specified key down?\n     */\n    getKeyIsDown (keyArg) {\n        if (keyArg === 'any') {\n            return this._keysPressed.length > 0;\n        }\n        const scratchKey = this._keyArgToScratchKey(keyArg);\n        return this._keysPressed.indexOf(scratchKey) > -1;\n    }\n}\n\nmodule.exports = Keyboard;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/keyboard.js?");

/***/ }),

/***/ "../scratch-vm/src/io/mouse.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/io/mouse.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MathUtil = __webpack_require__(/*! ../util/math-util */ \"../scratch-vm/src/util/math-util.js\");\n\nclass Mouse {\n    constructor (runtime) {\n        this._x = 0;\n        this._y = 0;\n        this._isDown = false;\n        /**\n         * Reference to the owning Runtime.\n         * Can be used, for example, to activate hats.\n         * @type{!Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Activate \"event_whenthisspriteclicked\" hats.\n     * @param  {Target} target to trigger hats on.\n     * @private\n     */\n    _activateClickHats (target) {\n        // Activate both \"this sprite clicked\" and \"stage clicked\"\n        // They were separated into two opcodes for labeling,\n        // but should act the same way.\n        // Intentionally not checking isStage to make it work when sharing blocks.\n        // @todo the blocks should be converted from one to another when shared\n        this.runtime.startHats('event_whenthisspriteclicked',\n            null, target);\n        this.runtime.startHats('event_whenstageclicked',\n            null, target);\n    }\n\n    /**\n     * Find a target by XY location\n     * @param  {number} x X position to be sent to the renderer.\n     * @param  {number} y Y position to be sent to the renderer.\n     * @return {Target} the target at that location\n     * @private\n     */\n    _pickTarget (x, y) {\n        if (this.runtime.renderer) {\n            const drawableID = this.runtime.renderer.pick(x, y);\n            for (let i = 0; i < this.runtime.targets.length; i++) {\n                const target = this.runtime.targets[i];\n                if (Object.prototype.hasOwnProperty.call(target, 'drawableID') &&\n                    target.drawableID === drawableID) {\n                    return target;\n                }\n            }\n        }\n        // Return the stage if no target was found\n        return this.runtime.getTargetForStage();\n    }\n\n    /**\n     * Mouse DOM event handler.\n     * @param  {object} data Data from DOM event.\n     */\n    postData (data) {\n        if (data.x) {\n            this._clientX = data.x;\n            this._scratchX = Math.round(MathUtil.clamp(\n                480 * ((data.x / data.canvasWidth) - 0.5),\n                -240,\n                240\n            ));\n        }\n        if (data.y) {\n            this._clientY = data.y;\n            this._scratchY = Math.round(MathUtil.clamp(\n                -360 * ((data.y / data.canvasHeight) - 0.5),\n                -180,\n                180\n            ));\n        }\n        if (typeof data.isDown !== 'undefined') {\n            const previousDownState = this._isDown;\n            this._isDown = data.isDown;\n\n            // Do not trigger if down state has not changed\n            if (previousDownState === this._isDown) return;\n\n            // Never trigger click hats at the end of a drag\n            if (data.wasDragged) return;\n\n            // Do not activate click hats for clicks outside canvas bounds\n            if (!(data.x > 0 && data.x < data.canvasWidth &&\n                data.y > 0 && data.y < data.canvasHeight)) return;\n\n            const target = this._pickTarget(data.x, data.y);\n            const isNewMouseDown = !previousDownState && this._isDown;\n            const isNewMouseUp = previousDownState && !this._isDown;\n\n            // Draggable targets start click hats on mouse up.\n            // Non-draggable targets start click hats on mouse down.\n            if (target.draggable && isNewMouseUp) {\n                this._activateClickHats(target);\n            } else if (!target.draggable && isNewMouseDown) {\n                this._activateClickHats(target);\n            }\n        }\n    }\n\n    /**\n     * Get the X position of the mouse in client coordinates.\n     * @return {number} Non-clamped X position of the mouse cursor.\n     */\n    getClientX () {\n        return this._clientX;\n    }\n\n    /**\n     * Get the Y position of the mouse in client coordinates.\n     * @return {number} Non-clamped Y position of the mouse cursor.\n     */\n    getClientY () {\n        return this._clientY;\n    }\n\n    /**\n     * Get the X position of the mouse in scratch coordinates.\n     * @return {number} Clamped and integer rounded X position of the mouse cursor.\n     */\n    getScratchX () {\n        return this._scratchX;\n    }\n\n    /**\n     * Get the Y position of the mouse in scratch coordinates.\n     * @return {number} Clamped and integer rounded Y position of the mouse cursor.\n     */\n    getScratchY () {\n        return this._scratchY;\n    }\n\n    /**\n     * Get the down state of the mouse.\n     * @return {boolean} Is the mouse down?\n     */\n    getIsDown () {\n        return this._isDown;\n    }\n}\n\nmodule.exports = Mouse;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/mouse.js?");

/***/ }),

/***/ "../scratch-vm/src/io/mouseWheel.js":
/*!******************************************!*\
  !*** ../scratch-vm/src/io/mouseWheel.js ***!
  \******************************************/
/***/ ((module) => {

eval("class MouseWheel {\n    constructor (runtime) {\n        /**\n         * Reference to the owning Runtime.\n         * @type{!Runtime}\n         */\n        this.runtime = runtime;\n    }\n\n    /**\n     * Mouse wheel DOM event handler.\n     * @param  {object} data Data from DOM event.\n     */\n    postData (data) {\n        const matchFields = {};\n        if (data.deltaY < 0) {\n            matchFields.KEY_OPTION = 'up arrow';\n        } else if (data.deltaY > 0) {\n            matchFields.KEY_OPTION = 'down arrow';\n        } else {\n            return;\n        }\n\n        this.runtime.startHats('event_whenkeypressed', matchFields);\n    }\n}\n\nmodule.exports = MouseWheel;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/mouseWheel.js?");

/***/ }),

/***/ "../scratch-vm/src/io/userData.js":
/*!****************************************!*\
  !*** ../scratch-vm/src/io/userData.js ***!
  \****************************************/
/***/ ((module) => {

eval("class UserData {\n    constructor () {\n        this._username = '';\n    }\n\n    /**\n     * Handler for updating the username\n     * @param {object} data Data posted to this ioDevice.\n     * @property {!string} username The new username.\n     */\n    postData (data) {\n        this._username = data.username;\n    }\n\n    /**\n     * Getter for username. Initially empty string, until set via postData.\n     * @returns {!string} The current username\n     */\n    getUsername () {\n        return this._username;\n    }\n}\n\nmodule.exports = UserData;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/userData.js?");

/***/ }),

/***/ "../scratch-vm/src/io/video.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/io/video.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const StageLayering = __webpack_require__(/*! ../engine/stage-layering */ \"../scratch-vm/src/engine/stage-layering.js\");\n\nclass Video {\n    constructor (runtime) {\n        this.runtime = runtime;\n\n        /**\n         * @typedef VideoProvider\n         * @property {Function} enableVideo - Requests camera access from the user, and upon success,\n         * enables the video feed\n         * @property {Function} disableVideo - Turns off the video feed\n         * @property {Function} getFrame - Return frame data from the video feed in\n         * specified dimensions, format, and mirroring.\n         */\n        this.provider = null;\n\n        /**\n         * Id representing a Scratch Renderer skin the video is rendered to for\n         * previewing.\n         * @type {number}\n         */\n        this._skinId = -1;\n\n        /**\n         * Id for a drawable using the video's skin that will render as a video\n         * preview.\n         * @type {Drawable}\n         */\n        this._drawable = -1;\n\n        /**\n         * Store the last state of the video transparency ghost effect\n         * @type {number}\n         */\n        this._ghost = 0;\n\n        /**\n         * Store a flag that allows the preview to be forced transparent.\n         * @type {number}\n         */\n        this._forceTransparentPreview = false;\n    }\n\n    static get FORMAT_IMAGE_DATA () {\n        return 'image-data';\n    }\n\n    static get FORMAT_CANVAS () {\n        return 'canvas';\n    }\n\n    /**\n     * Dimensions the video stream is analyzed at after its rendered to the\n     * sample canvas.\n     * @type {Array.<number>}\n     */\n    static get DIMENSIONS () {\n        return [480, 360];\n    }\n\n    /**\n     * Order preview drawable is inserted at in the renderer.\n     * @type {number}\n     */\n    static get ORDER () {\n        return 1;\n    }\n\n    /**\n     * Set a video provider for this device. A default implementation of\n     * a video provider can be found in scratch-gui/src/lib/video/video-provider\n     * @param {VideoProvider} provider - Video provider to use\n     */\n    setProvider (provider) {\n        this.provider = provider;\n    }\n\n    /**\n     * Request video be enabled.  Sets up video, creates video skin and enables preview.\n     *\n     * ioDevices.video.requestVideo()\n     *\n     * @return {Promise.<Video>} resolves a promise to this IO device when video is ready.\n     */\n    enableVideo () {\n        if (!this.provider) return null;\n        return this.provider.enableVideo().then(() => this._setupPreview());\n    }\n\n    /**\n     * Disable video stream (turn video off)\n     * @return {void}\n     */\n    disableVideo () {\n        this._disablePreview();\n        if (!this.provider) return null;\n        this.provider.disableVideo();\n    }\n\n    /**\n     * Return frame data from the video feed in a specified dimensions, format, and mirroring.\n     *\n     * @param {object} frameInfo A descriptor of the frame you would like to receive.\n     * @param {Array.<number>} frameInfo.dimensions [width, height] array of numbers.  Defaults to [480,360]\n     * @param {boolean} frameInfo.mirror If you specificly want a mirror/non-mirror frame, defaults to the global\n     *                                   mirror state (ioDevices.video.mirror)\n     * @param {string} frameInfo.format Requested video format, available formats are 'image-data' and 'canvas'.\n     * @param {number} frameInfo.cacheTimeout Will reuse previous image data if the time since capture is less than\n     *                                        the cacheTimeout.  Defaults to 16ms.\n     *\n     * @return {ArrayBuffer|Canvas|string|null} Frame data in requested format, null when errors.\n     */\n    getFrame ({\n        dimensions = Video.DIMENSIONS,\n        mirror = this.mirror,\n        format = Video.FORMAT_IMAGE_DATA,\n        cacheTimeout = this._frameCacheTimeout\n    }) {\n        if (this.provider) return this.provider.getFrame({dimensions, mirror, format, cacheTimeout});\n        return null;\n    }\n\n    /**\n     * Set the preview ghost effect\n     * @param {number} ghost from 0 (visible) to 100 (invisible) - ghost effect\n     */\n    setPreviewGhost (ghost) {\n        this._ghost = ghost;\n        // Confirm that the default value has been changed to a valid id for the drawable\n        if (this._drawable !== -1) {\n            this.runtime.renderer.updateDrawableEffect(\n                this._drawable,\n                'ghost',\n                this._forceTransparentPreview ? 100 : ghost\n            );\n        }\n    }\n\n    _disablePreview () {\n        if (this._skinId !== -1) {\n            this.runtime.renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);\n            this.runtime.renderer.updateDrawableVisible(this._drawable, false);\n        }\n        this._renderPreviewFrame = null;\n    }\n\n    _setupPreview () {\n        const {renderer} = this.runtime;\n        if (!renderer) return;\n\n        if (this._skinId === -1 && this._drawable === -1) {\n            this._skinId = renderer.createBitmapSkin(new ImageData(...Video.DIMENSIONS), 1);\n            this._drawable = renderer.createDrawable(StageLayering.VIDEO_LAYER);\n            renderer.updateDrawableSkinId(this._drawable, this._skinId);\n        }\n\n        // if we haven't already created and started a preview frame render loop, do so\n        if (!this._renderPreviewFrame) {\n            renderer.updateDrawableEffect(this._drawable, 'ghost', this._forceTransparentPreview ? 100 : this._ghost);\n            renderer.updateDrawableVisible(this._drawable, true);\n\n            this._renderPreviewFrame = () => {\n                clearTimeout(this._renderPreviewTimeout);\n                if (!this._renderPreviewFrame) {\n                    return;\n                }\n\n                this._renderPreviewTimeout = setTimeout(this._renderPreviewFrame, this.runtime.currentStepTime);\n\n                const imageData = this.getFrame({\n                    format: Video.FORMAT_IMAGE_DATA,\n                    cacheTimeout: this.runtime.currentStepTime\n                });\n\n                if (!imageData) {\n                    renderer.updateBitmapSkin(this._skinId, new ImageData(...Video.DIMENSIONS), 1);\n                    return;\n                }\n\n                renderer.updateBitmapSkin(this._skinId, imageData, 1);\n                this.runtime.requestRedraw();\n            };\n\n            this._renderPreviewFrame();\n        }\n    }\n\n    get videoReady () {\n        if (this.provider) return this.provider.videoReady;\n        return false;\n    }\n\n    /**\n     * Method implemented by all IO devices to allow external changes.\n     * The only change available externally is hiding the preview, used e.g. to\n     * prevent drawing the preview into project thumbnails.\n     * @param {object} - data passed to this IO device.\n     * @property {boolean} forceTransparentPreview - whether the preview should be forced transparent.\n     */\n    postData ({forceTransparentPreview}) {\n        this._forceTransparentPreview = forceTransparentPreview;\n        // Setting the ghost to the current value will pick up the forceTransparentPreview\n        // flag and override the current ghost. The complexity is to prevent blocks\n        // from overriding forceTransparentPreview\n        this.setPreviewGhost(this._ghost);\n    }\n}\n\n\nmodule.exports = Video;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/io/video.js?");

/***/ }),

/***/ "../scratch-vm/src/sprites/rendered-target.js":
/*!****************************************************!*\
  !*** ../scratch-vm/src/sprites/rendered-target.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const MathUtil = __webpack_require__(/*! ../util/math-util */ \"../scratch-vm/src/util/math-util.js\");\nconst StringUtil = __webpack_require__(/*! ../util/string-util */ \"../scratch-vm/src/util/string-util.js\");\nconst Cast = __webpack_require__(/*! ../util/cast */ \"../scratch-vm/src/util/cast.js\");\nconst Clone = __webpack_require__(/*! ../util/clone */ \"../scratch-vm/src/util/clone.js\");\nconst Target = __webpack_require__(/*! ../engine/target */ \"../scratch-vm/src/engine/target.js\");\nconst StageLayering = __webpack_require__(/*! ../engine/stage-layering */ \"../scratch-vm/src/engine/stage-layering.js\");\n\n/**\n * Rendered target: instance of a sprite (clone), or the stage.\n */\nclass RenderedTarget extends Target {\n    /**\n     * @param {!Sprite} sprite Reference to the parent sprite.\n     * @param {Runtime} runtime Reference to the runtime.\n     * @constructor\n     */\n    constructor (sprite, runtime) {\n        super(runtime, sprite.blocks);\n\n        /**\n         * Reference to the sprite that this is a render of.\n         * @type {!Sprite}\n         */\n        this.sprite = sprite;\n        /**\n         * Reference to the global renderer for this VM, if one exists.\n         * @type {?RenderWebGL}\n         */\n        this.renderer = null;\n        if (this.runtime) {\n            this.renderer = this.runtime.renderer;\n        }\n        /**\n         * ID of the drawable for this rendered target,\n         * returned by the renderer, if rendered.\n         * @type {?Number}\n         */\n        this.drawableID = null;\n\n        /**\n         * Drag state of this rendered target. If true, x/y position can't be\n         * changed by blocks.\n         * @type {boolean}\n         */\n        this.dragging = false;\n\n        /**\n         * Map of current graphic effect values.\n         * @type {!Object.<string, number>}\n         */\n        this.effects = {\n            color: 0,\n            fisheye: 0,\n            whirl: 0,\n            pixelate: 0,\n            mosaic: 0,\n            brightness: 0,\n            ghost: 0\n        };\n\n        /**\n         * Whether this represents an \"original\" non-clone rendered-target for a sprite,\n         * i.e., created by the editor and not clone blocks.\n         * @type {boolean}\n         */\n        this.isOriginal = true;\n\n        /**\n         * Whether this rendered target represents the Scratch stage.\n         * @type {boolean}\n         */\n        this.isStage = false;\n\n        /**\n         * Scratch X coordinate. Currently should range from -240 to 240.\n         * @type {Number}\n         */\n        this.x = 0;\n\n        /**\n         * Scratch Y coordinate. Currently should range from -180 to 180.\n         * @type {number}\n         */\n        this.y = 0;\n\n        /**\n         * Scratch direction. Currently should range from -179 to 180.\n         * @type {number}\n         */\n        this.direction = 90;\n\n        /**\n         * Whether the rendered target is draggable on the stage\n         * @type {boolean}\n         */\n        this.draggable = false;\n\n        /**\n         * Whether the rendered target is currently visible.\n         * @type {boolean}\n         */\n        this.visible = true;\n\n        /**\n         * Size of rendered target as a percent of costume size.\n         * @type {number}\n         */\n        this.size = 100;\n\n        /**\n         * Currently selected costume index.\n         * @type {number}\n         */\n        this.currentCostume = 0;\n\n        /**\n         * Current rotation style.\n         * @type {!string}\n         */\n        this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n\n        /**\n         * Loudness for sound playback for this target, as a percentage.\n         * @type {number}\n         */\n        this.volume = 100;\n\n        /**\n         * Current tempo (used by the music extension).\n         * This property is global to the project and stored in the stage.\n         * @type {number}\n         */\n        this.tempo = 60;\n\n        /**\n         * The transparency of the video (used by extensions with camera input).\n         * This property is global to the project and stored in the stage.\n         * @type {number}\n         */\n        this.videoTransparency = 50;\n\n        /**\n         * The state of the video input (used by extensions with camera input).\n         * This property is global to the project and stored in the stage.\n         *\n         * Defaults to ON. This setting does not turn the video by itself. A\n         * video extension once loaded will set the video device to this\n         * setting. Set to ON when a video extension is added in the editor the\n         * video will start ON. If the extension is loaded as part of loading a\n         * saved project the extension will see the value set when the stage\n         * was loaded from the saved values including the video state.\n         *\n         * @type {string}\n         */\n        this.videoState = RenderedTarget.VIDEO_STATE.ON;\n\n        /**\n         * The language to use for speech synthesis, in the text2speech extension.\n         * It is initialized to null so that on extension load, we can check for\n         * this and try setting it using the editor locale.\n         * @type {string}\n         */\n        this.textToSpeechLanguage = null;\n    }\n\n    /**\n     * Create a drawable with the this.renderer.\n     * @param {boolean} layerGroup The layer group this drawable should be added to\n     */\n    initDrawable (layerGroup) {\n        if (this.renderer) {\n            this.drawableID = this.renderer.createDrawable(layerGroup);\n        }\n        // If we're a clone, start the hats.\n        if (!this.isOriginal) {\n            this.runtime.startHats(\n                'control_start_as_clone', null, this\n            );\n        }\n    }\n\n    get audioPlayer () {\n        /* eslint-disable no-console */\n        console.warn('get audioPlayer deprecated, please update to use .sprite.soundBank methods');\n        console.warn(new Error('stack for debug').stack);\n        /* eslint-enable no-console */\n        const bank = this.sprite.soundBank;\n        const audioPlayerProxy = {\n            playSound: soundId => bank.play(this, soundId)\n        };\n\n        Object.defineProperty(this, 'audioPlayer', {\n            configurable: false,\n            enumerable: true,\n            writable: false,\n            value: audioPlayerProxy\n        });\n\n        return audioPlayerProxy;\n    }\n\n    /**\n     * Initialize the audio player for this sprite or clone.\n     */\n    initAudio () {\n    }\n\n    /**\n     * Event which fires when a target moves.\n     * @type {string}\n     */\n    static get EVENT_TARGET_MOVED () {\n        return 'TARGET_MOVED';\n    }\n\n    /**\n     * Event which fires when a target changes visually, for updating say bubbles.\n     * @type {string}\n     */\n    static get EVENT_TARGET_VISUAL_CHANGE () {\n        return 'EVENT_TARGET_VISUAL_CHANGE';\n    }\n\n    /**\n     * Rotation style for \"all around\"/spinning.\n     * @type {string}\n     */\n    static get ROTATION_STYLE_ALL_AROUND () {\n        return 'all around';\n    }\n\n    /**\n     * Rotation style for \"left-right\"/flipping.\n     * @type {string}\n     */\n    static get ROTATION_STYLE_LEFT_RIGHT () {\n        return 'left-right';\n    }\n\n    /**\n     * Rotation style for \"no rotation.\"\n     * @type {string}\n     */\n    static get ROTATION_STYLE_NONE () {\n        return \"don't rotate\";\n    }\n\n    /**\n     * Available states for video input.\n     * @enum {string}\n     */\n    static get VIDEO_STATE () {\n        return {\n            OFF: 'off',\n            ON: 'on',\n            ON_FLIPPED: 'on-flipped'\n        };\n    }\n\n    /**\n     * Set the X and Y coordinates.\n     * @param {!number} x New X coordinate, in Scratch coordinates.\n     * @param {!number} y New Y coordinate, in Scratch coordinates.\n     * @param {?boolean} force Force setting X/Y, in case of dragging\n     */\n    setXY (x, y, force) {\n        if (this.isStage) return;\n        if (this.dragging && !force) return;\n        const oldX = this.x;\n        const oldY = this.y;\n        if (this.renderer) {\n            const position = this.renderer.getFencedPositionOfDrawable(this.drawableID, [x, y]);\n            this.x = position[0];\n            this.y = position[1];\n\n            this.renderer.updateDrawablePosition(this.drawableID, position);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        } else {\n            this.x = x;\n            this.y = y;\n        }\n        this.emit(RenderedTarget.EVENT_TARGET_MOVED, this, oldX, oldY, force);\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Get the rendered direction and scale, after applying rotation style.\n     * @return {object<string, number>} Direction and scale to render.\n     */\n    _getRenderedDirectionAndScale () {\n        // Default: no changes to `this.direction` or `this.scale`.\n        let finalDirection = this.direction;\n        let finalScale = [this.size, this.size];\n        if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n            // Force rendered direction to be 90.\n            finalDirection = 90;\n        } else if (this.rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n            // Force rendered direction to be 90, and flip drawable if needed.\n            finalDirection = 90;\n            const scaleFlip = (this.direction < 0) ? -1 : 1;\n            finalScale = [scaleFlip * this.size, this.size];\n        }\n        return {direction: finalDirection, scale: finalScale};\n    }\n\n    /**\n     * Set the direction.\n     * @param {!number} direction New direction.\n     */\n    setDirection (direction) {\n        if (this.isStage) {\n            return;\n        }\n        if (!isFinite(direction)) {\n            return;\n        }\n        // Keep direction between -179 and +180.\n        this.direction = MathUtil.wrapClamp(direction, -179, 180);\n        if (this.renderer) {\n            const {direction: renderedDirection, scale} = this._getRenderedDirectionAndScale();\n            this.renderer.updateDrawableDirectionScale(this.drawableID, renderedDirection, scale);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set draggability; i.e., whether it's able to be dragged in the player\n     * @param {!boolean} draggable True if should be draggable.\n     */\n    setDraggable (draggable) {\n        if (this.isStage) return;\n        this.draggable = !!draggable;\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set visibility; i.e., whether it's shown or hidden.\n     * @param {!boolean} visible True if should be shown.\n     */\n    setVisible (visible) {\n        if (this.isStage) {\n            return;\n        }\n        this.visible = !!visible;\n        if (this.renderer) {\n            this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set size, as a percentage of the costume size.\n     * @param {!number} size Size of rendered target, as % of costume size.\n     */\n    setSize (size) {\n        if (this.isStage) {\n            return;\n        }\n        if (this.renderer) {\n            // Clamp to scales relative to costume and stage size.\n            // See original ScratchSprite.as:setSize.\n            const costumeSize = this.renderer.getCurrentSkinSize(this.drawableID);\n            const origW = costumeSize[0];\n            const origH = costumeSize[1];\n            const minScale = Math.min(1, Math.max(5 / origW, 5 / origH));\n            const maxScale = Math.min(\n                (1.5 * this.runtime.constructor.STAGE_WIDTH) / origW,\n                (1.5 * this.runtime.constructor.STAGE_HEIGHT) / origH\n            );\n            this.size = MathUtil.clamp(size / 100, minScale, maxScale) * 100;\n            const {direction, scale} = this._getRenderedDirectionAndScale();\n            this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Set a particular graphic effect value.\n     * @param {!string} effectName Name of effect (see `RenderedTarget.prototype.effects`).\n     * @param {!number} value Numerical magnitude of effect.\n     */\n    setEffect (effectName, value) {\n        if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) return;\n        this.effects[effectName] = value;\n        if (this.renderer) {\n            this.renderer.updateDrawableEffect(this.drawableID, effectName, value);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n    }\n\n    /**\n     * Clear all graphic effects on this rendered target.\n     */\n    clearEffects () {\n        for (const effectName in this.effects) {\n            if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;\n            this.effects[effectName] = 0;\n        }\n        if (this.renderer) {\n            for (const effectName in this.effects) {\n                if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;\n                this.renderer.updateDrawableEffect(this.drawableID, effectName, 0);\n            }\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n    }\n\n    /**\n     * Set the current costume.\n     * @param {number} index New index of costume.\n     */\n    setCostume (index) {\n        // Keep the costume index within possible values.\n        index = Math.round(index);\n        if ([Infinity, -Infinity, NaN].includes(index)) index = 0;\n\n        this.currentCostume = MathUtil.wrapClamp(\n            index, 0, this.sprite.costumes.length - 1\n        );\n        if (this.renderer) {\n            const costume = this.getCostumes()[this.currentCostume];\n            this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Add a costume, taking care to avoid duplicate names.\n     * @param {!object} costumeObject Object representing the costume.\n     * @param {?int} index Index at which to add costume\n     */\n    addCostume (costumeObject, index) {\n        if (typeof index === 'number' && !isNaN(index)) {\n            this.sprite.addCostumeAt(costumeObject, index);\n        } else {\n            this.sprite.addCostumeAt(costumeObject, this.sprite.costumes.length);\n        }\n    }\n\n    /**\n     * Rename a costume, taking care to avoid duplicate names.\n     * @param {int} costumeIndex - the index of the costume to be renamed.\n     * @param {string} newName - the desired new name of the costume (will be modified if already in use).\n     */\n    renameCostume (costumeIndex, newName) {\n        const usedNames = this.sprite.costumes\n            .filter((costume, index) => costumeIndex !== index)\n            .map(costume => costume.name);\n        const oldName = this.getCostumes()[costumeIndex].name;\n        const newUnusedName = StringUtil.unusedName(newName, usedNames);\n        this.getCostumes()[costumeIndex].name = newUnusedName;\n\n        if (this.isStage) {\n            // Since this is a backdrop, go through all targets and\n            // update any blocks referencing the old backdrop name\n            const targets = this.runtime.targets;\n            for (let i = 0; i < targets.length; i++) {\n                const currTarget = targets[i];\n                currTarget.blocks.updateAssetName(oldName, newUnusedName, 'backdrop');\n            }\n        } else {\n            this.blocks.updateAssetName(oldName, newUnusedName, 'costume');\n        }\n\n    }\n\n    /**\n     * Delete a costume by index.\n     * @param {number} index Costume index to be deleted\n     * @return {?object} The costume that was deleted or null\n     * if the index was out of bounds of the costumes list or\n     * this target only has one costume.\n     */\n    deleteCostume (index) {\n        const originalCostumeCount = this.sprite.costumes.length;\n        if (originalCostumeCount === 1) return null;\n\n        if (index < 0 || index >= originalCostumeCount) {\n            return null;\n        }\n\n        const deletedCostume = this.sprite.deleteCostumeAt(index);\n\n        if (index === this.currentCostume && index === originalCostumeCount - 1) {\n            this.setCostume(index - 1);\n        } else if (index < this.currentCostume) {\n            this.setCostume(this.currentCostume - 1);\n        } else {\n            this.setCostume(this.currentCostume);\n        }\n\n        this.runtime.requestTargetsUpdate(this);\n        return deletedCostume;\n    }\n\n    /**\n     * Add a sound, taking care to avoid duplicate names.\n     * @param {!object} soundObject Object representing the sound.\n     * @param {?int} index Index at which to add costume\n     */\n    addSound (soundObject, index) {\n        const usedNames = this.sprite.sounds.map(sound => sound.name);\n        soundObject.name = StringUtil.unusedName(soundObject.name, usedNames);\n        if (typeof index === 'number' && !isNaN(index)) {\n            this.sprite.sounds.splice(index, 0, soundObject);\n        } else {\n            this.sprite.sounds.push(soundObject);\n        }\n    }\n\n    /**\n     * Rename a sound, taking care to avoid duplicate names.\n     * @param {int} soundIndex - the index of the sound to be renamed.\n     * @param {string} newName - the desired new name of the sound (will be modified if already in use).\n     */\n    renameSound (soundIndex, newName) {\n        const usedNames = this.sprite.sounds\n            .filter((sound, index) => soundIndex !== index)\n            .map(sound => sound.name);\n        const oldName = this.sprite.sounds[soundIndex].name;\n        const newUnusedName = StringUtil.unusedName(newName, usedNames);\n        this.sprite.sounds[soundIndex].name = newUnusedName;\n        this.blocks.updateAssetName(oldName, newUnusedName, 'sound');\n    }\n\n    /**\n     * Delete a sound by index.\n     * @param {number} index Sound index to be deleted\n     * @return {object} The deleted sound object, or null if no sound was deleted.\n     */\n    deleteSound (index) {\n        // Make sure the sound index is not out of bounds\n        if (index < 0 || index >= this.sprite.sounds.length) {\n            return null;\n        }\n        // Delete the sound at the given index\n        const deletedSound = this.sprite.sounds.splice(index, 1)[0];\n        this.runtime.requestTargetsUpdate(this);\n        return deletedSound;\n    }\n\n    /**\n     * Update the rotation style.\n     * @param {!string} rotationStyle New rotation style.\n     */\n    setRotationStyle (rotationStyle) {\n        if (rotationStyle === RenderedTarget.ROTATION_STYLE_NONE) {\n            this.rotationStyle = RenderedTarget.ROTATION_STYLE_NONE;\n        } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_ALL_AROUND) {\n            this.rotationStyle = RenderedTarget.ROTATION_STYLE_ALL_AROUND;\n        } else if (rotationStyle === RenderedTarget.ROTATION_STYLE_LEFT_RIGHT) {\n            this.rotationStyle = RenderedTarget.ROTATION_STYLE_LEFT_RIGHT;\n        }\n        if (this.renderer) {\n            const {direction, scale} = this._getRenderedDirectionAndScale();\n            this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Get a costume index of this rendered target, by name of the costume.\n     * @param {?string} costumeName Name of a costume.\n     * @return {number} Index of the named costume, or -1 if not present.\n     */\n    getCostumeIndexByName (costumeName) {\n        for (let i = 0; i < this.sprite.costumes.length; i++) {\n            if (this.getCostumes()[i].name === costumeName) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Get a costume of this rendered target by id.\n     * @return {object} current costume\n     */\n    getCurrentCostume () {\n        return this.getCostumes()[this.currentCostume];\n    }\n\n    /**\n     * Get full costume list\n     * @return {object[]} list of costumes\n     */\n    getCostumes () {\n        return this.sprite.costumes;\n    }\n\n    /**\n     * Reorder costume list by moving costume at costumeIndex to newIndex.\n     * @param {!number} costumeIndex Index of the costume to move.\n     * @param {!number} newIndex New index for that costume.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n    reorderCostume (costumeIndex, newIndex) {\n        newIndex = MathUtil.clamp(newIndex, 0, this.sprite.costumes.length - 1);\n        costumeIndex = MathUtil.clamp(costumeIndex, 0, this.sprite.costumes.length - 1);\n\n        if (newIndex === costumeIndex) return false;\n\n        const currentCostume = this.getCurrentCostume();\n        const costume = this.sprite.costumes[costumeIndex];\n\n        // Use the sprite method for deleting costumes because setCostume is handled manually\n        this.sprite.deleteCostumeAt(costumeIndex);\n\n        this.addCostume(costume, newIndex);\n        this.currentCostume = this.getCostumeIndexByName(currentCostume.name);\n        return true;\n    }\n\n    /**\n     * Reorder sound list by moving sound at soundIndex to newIndex.\n     * @param {!number} soundIndex Index of the sound to move.\n     * @param {!number} newIndex New index for that sound.\n     * @returns {boolean} If a change occurred (i.e. if the indices do not match)\n     */\n    reorderSound (soundIndex, newIndex) {\n        newIndex = MathUtil.clamp(newIndex, 0, this.sprite.sounds.length - 1);\n        soundIndex = MathUtil.clamp(soundIndex, 0, this.sprite.sounds.length - 1);\n\n        if (newIndex === soundIndex) return false;\n\n        const sound = this.sprite.sounds[soundIndex];\n        this.deleteSound(soundIndex);\n        this.addSound(sound, newIndex);\n        return true;\n    }\n\n    /**\n     * Get full sound list\n     * @return {object[]} list of sounds\n     */\n    getSounds () {\n        return this.sprite.sounds;\n    }\n\n    /**\n     * Update all drawable properties for this rendered target.\n     * Use when a batch has changed, e.g., when the drawable is first created.\n     */\n    updateAllDrawableProperties () {\n        if (this.renderer) {\n            const {direction, scale} = this._getRenderedDirectionAndScale();\n            this.renderer.updateDrawablePosition(this.drawableID, [this.x, this.y]);\n            this.renderer.updateDrawableDirectionScale(this.drawableID, direction, scale);\n            this.renderer.updateDrawableVisible(this.drawableID, this.visible);\n\n            const costume = this.getCostumes()[this.currentCostume];\n            this.renderer.updateDrawableSkinId(this.drawableID, costume.skinId);\n\n            for (const effectName in this.effects) {\n                if (!Object.prototype.hasOwnProperty.call(this.effects, effectName)) continue;\n                this.renderer.updateDrawableEffect(this.drawableID, effectName, this.effects[effectName]);\n            }\n\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n        this.runtime.requestTargetsUpdate(this);\n    }\n\n    /**\n     * Return the human-readable name for this rendered target, e.g., the sprite's name.\n     * @override\n     * @returns {string} Human-readable name.\n     */\n    getName () {\n        return this.sprite.name;\n    }\n\n    /**\n     * Return whether this rendered target is a sprite (not a clone, not the stage).\n     * @return {boolean} True if not a clone and not the stage.\n     */\n    isSprite () {\n        return !this.isStage && this.isOriginal;\n    }\n\n    /**\n     * Return the rendered target's tight bounding box.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n    getBounds () {\n        if (this.renderer) {\n            return this.runtime.renderer.getBounds(this.drawableID);\n        }\n        return null;\n    }\n\n    /**\n     * Return the bounding box around a slice of the top 8px of the rendered target.\n     * Includes top, left, bottom, right attributes in Scratch coordinates.\n     * @return {?object} Tight bounding box, or null.\n     */\n    getBoundsForBubble () {\n        if (this.renderer) {\n            return this.runtime.renderer.getBoundsForBubble(this.drawableID);\n        }\n        return null;\n    }\n\n    /**\n     * Return whether this target is touching the mouse, an edge, or a sprite.\n     * @param {string} requestedObject an id for mouse or edge, or a sprite name.\n     * @return {boolean} True if the sprite is touching the object.\n     */\n    isTouchingObject (requestedObject) {\n        if (requestedObject === '_mouse_') {\n            if (!this.runtime.ioDevices.mouse) return false;\n            const mouseX = this.runtime.ioDevices.mouse.getClientX();\n            const mouseY = this.runtime.ioDevices.mouse.getClientY();\n            return this.isTouchingPoint(mouseX, mouseY);\n        } else if (requestedObject === '_edge_') {\n            return this.isTouchingEdge();\n        }\n        return this.isTouchingSprite(requestedObject);\n    }\n\n    /**\n     * Return whether touching a point.\n     * @param {number} x X coordinate of test point.\n     * @param {number} y Y coordinate of test point.\n     * @return {boolean} True iff the rendered target is touching the point.\n     */\n    isTouchingPoint (x, y) {\n        if (this.renderer) {\n            return this.renderer.drawableTouching(this.drawableID, x, y);\n        }\n        return false;\n    }\n\n    /**\n     * Return whether touching a stage edge.\n     * @return {boolean} True iff the rendered target is touching the stage edge.\n     */\n    isTouchingEdge () {\n        if (this.renderer) {\n            const stageWidth = this.runtime.constructor.STAGE_WIDTH;\n            const stageHeight = this.runtime.constructor.STAGE_HEIGHT;\n            const bounds = this.getBounds();\n            if (bounds.left < -stageWidth / 2 ||\n                bounds.right > stageWidth / 2 ||\n                bounds.top > stageHeight / 2 ||\n                bounds.bottom < -stageHeight / 2) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return whether touching any of a named sprite's clones.\n     * @param {string} spriteName Name of the sprite.\n     * @return {boolean} True iff touching a clone of the sprite.\n     */\n    isTouchingSprite (spriteName) {\n        spriteName = Cast.toString(spriteName);\n        const firstClone = this.runtime.getSpriteTargetByName(spriteName);\n        if (!firstClone || !this.renderer) {\n            return false;\n        }\n        // Filter out dragging targets. This means a sprite that is being dragged\n        // can detect other sprites using touching <sprite>, but cannot be detected\n        // by other sprites while it is being dragged. This matches Scratch 2.0 behavior.\n        const drawableCandidates = firstClone.sprite.clones.filter(clone => !clone.dragging)\n            .map(clone => clone.drawableID);\n        return this.renderer.isTouchingDrawables(\n            this.drawableID, drawableCandidates);\n    }\n\n    /**\n     * Return whether touching a color.\n     * @param {Array.<number>} rgb [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the rendered target is touching the color.\n     */\n    isTouchingColor (rgb) {\n        if (this.renderer) {\n            return this.renderer.isTouchingColor(this.drawableID, rgb);\n        }\n        return false;\n    }\n\n    /**\n     * Return whether rendered target's color is touching a color.\n     * @param {object} targetRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @param {object} maskRgb {Array.<number>} [r,g,b], values between 0-255.\n     * @return {Promise.<boolean>} True iff the color is touching the color.\n     */\n    colorIsTouchingColor (targetRgb, maskRgb) {\n        if (this.renderer) {\n            return this.renderer.isTouchingColor(\n                this.drawableID,\n                targetRgb,\n                maskRgb\n            );\n        }\n        return false;\n    }\n\n    getLayerOrder () {\n        if (this.renderer) {\n            return this.renderer.getDrawableOrder(this.drawableID);\n        }\n        return null;\n    }\n\n    /**\n     * Move to the front layer.\n     */\n    goToFront () { // This should only ever be used for sprites\n        if (this.renderer) {\n            // Let the renderer re-order the sprite based on its knowledge\n            // of what layers are present\n            this.renderer.setDrawableOrder(this.drawableID, Infinity, StageLayering.SPRITE_LAYER);\n        }\n\n        this.runtime.setExecutablePosition(this, Infinity);\n    }\n\n    /**\n     * Move to the back layer.\n     */\n    goToBack () { // This should only ever be used for sprites\n        if (this.renderer) {\n            // Let the renderer re-order the sprite based on its knowledge\n            // of what layers are present\n            this.renderer.setDrawableOrder(this.drawableID, -Infinity, StageLayering.SPRITE_LAYER, false);\n        }\n\n        this.runtime.setExecutablePosition(this, -Infinity);\n    }\n\n    /**\n     * Move forward a number of layers.\n     * @param {number} nLayers How many layers to go forward.\n     */\n    goForwardLayers (nLayers) {\n        if (this.renderer) {\n            this.renderer.setDrawableOrder(this.drawableID, nLayers, StageLayering.SPRITE_LAYER, true);\n        }\n\n        this.runtime.moveExecutable(this, nLayers);\n    }\n\n    /**\n     * Move backward a number of layers.\n     * @param {number} nLayers How many layers to go backward.\n     */\n    goBackwardLayers (nLayers) {\n        if (this.renderer) {\n            this.renderer.setDrawableOrder(this.drawableID, -nLayers, StageLayering.SPRITE_LAYER, true);\n        }\n\n        this.runtime.moveExecutable(this, -nLayers);\n    }\n\n    /**\n     * Move behind some other rendered target.\n     * @param {!RenderedTarget} other Other rendered target to move behind.\n     */\n    goBehindOther (other) {\n        if (this.renderer) {\n            const otherLayer = this.renderer.setDrawableOrder(\n                other.drawableID, 0, StageLayering.SPRITE_LAYER, true);\n            this.renderer.setDrawableOrder(this.drawableID, otherLayer, StageLayering.SPRITE_LAYER);\n        }\n\n        const executionPosition = this.runtime.executableTargets.indexOf(other);\n        this.runtime.setExecutablePosition(this, executionPosition);\n    }\n\n    /**\n     * Keep a desired position within a fence.\n     * @param {number} newX New desired X position.\n     * @param {number} newY New desired Y position.\n     * @param {object=} optFence Optional fence with left, right, top bottom.\n     * @return {Array.<number>} Fenced X and Y coordinates.\n     */\n    keepInFence (newX, newY, optFence) {\n        let fence = optFence;\n        if (!fence) {\n            fence = {\n                left: -this.runtime.constructor.STAGE_WIDTH / 2,\n                right: this.runtime.constructor.STAGE_WIDTH / 2,\n                top: this.runtime.constructor.STAGE_HEIGHT / 2,\n                bottom: -this.runtime.constructor.STAGE_HEIGHT / 2\n            };\n        }\n        const bounds = this.getBounds();\n        if (!bounds) return;\n        // Adjust the known bounds to the target position.\n        bounds.left += (newX - this.x);\n        bounds.right += (newX - this.x);\n        bounds.top += (newY - this.y);\n        bounds.bottom += (newY - this.y);\n        // Find how far we need to move the target position.\n        let dx = 0;\n        let dy = 0;\n        if (bounds.left < fence.left) {\n            dx += fence.left - bounds.left;\n        }\n        if (bounds.right > fence.right) {\n            dx += fence.right - bounds.right;\n        }\n        if (bounds.top > fence.top) {\n            dy += fence.top - bounds.top;\n        }\n        if (bounds.bottom < fence.bottom) {\n            dy += fence.bottom - bounds.bottom;\n        }\n        return [newX + dx, newY + dy];\n    }\n\n    /**\n     * Make a clone, copying any run-time properties.\n     * If we've hit the global clone limit, returns null.\n     * @return {RenderedTarget} New clone.\n     */\n    makeClone () {\n        if (!this.runtime.clonesAvailable() || this.isStage) {\n            return null; // Hit max clone limit, or this is the stage.\n        }\n        this.runtime.changeCloneCounter(1);\n        const newClone = this.sprite.createClone();\n        // Copy all properties.\n        newClone.x = this.x;\n        newClone.y = this.y;\n        newClone.direction = this.direction;\n        newClone.draggable = this.draggable;\n        newClone.visible = this.visible;\n        newClone.size = this.size;\n        newClone.currentCostume = this.currentCostume;\n        newClone.rotationStyle = this.rotationStyle;\n        newClone.effects = Clone.simple(this.effects);\n        newClone.variables = this.duplicateVariables();\n        newClone._edgeActivatedHatValues = Clone.simple(this._edgeActivatedHatValues);\n        newClone.initDrawable(StageLayering.SPRITE_LAYER);\n        newClone.updateAllDrawableProperties();\n        return newClone;\n    }\n\n    /**\n     * Make a duplicate using a duplicate sprite.\n     * @return {RenderedTarget} New clone.\n     */\n    duplicate () {\n        return this.sprite.duplicate().then(newSprite => {\n            const newTarget = newSprite.createClone();\n            // Copy all properties.\n            // @todo refactor with clone methods\n            newTarget.x = (Math.random() - 0.5) * 400 / 2;\n            newTarget.y = (Math.random() - 0.5) * 300 / 2;\n            newTarget.direction = this.direction;\n            newTarget.draggable = this.draggable;\n            newTarget.visible = this.visible;\n            newTarget.size = this.size;\n            newTarget.currentCostume = this.currentCostume;\n            newTarget.rotationStyle = this.rotationStyle;\n            newTarget.effects = JSON.parse(JSON.stringify(this.effects));\n            newTarget.variables = this.duplicateVariables(newTarget.blocks);\n            newTarget.updateAllDrawableProperties();\n            return newTarget;\n        });\n    }\n\n    /**\n     * Called when the project receives a \"green flag.\"\n     * For a rendered target, this clears graphic effects.\n     */\n    onGreenFlag () {\n        this.clearEffects();\n    }\n\n    /**\n     * Called when the project receives a \"stop all\"\n     * Stop all sounds and clear graphic effects.\n     */\n    onStopAll () {\n        this.clearEffects();\n    }\n\n    /**\n     * Post/edit sprite info.\n     * @param {object} data An object with sprite info data to set.\n     */\n    postSpriteInfo (data) {\n        const force = Object.prototype.hasOwnProperty.call(data, 'force') ? data.force : null;\n        const isXChanged = Object.prototype.hasOwnProperty.call(data, 'x');\n        const isYChanged = Object.prototype.hasOwnProperty.call(data, 'y');\n        if (isXChanged || isYChanged) {\n            this.setXY(isXChanged ? data.x : this.x, isYChanged ? data.y : this.y, force);\n        }\n        if (Object.prototype.hasOwnProperty.call(data, 'direction')) {\n            this.setDirection(data.direction);\n        }\n        if (Object.prototype.hasOwnProperty.call(data, 'draggable')) {\n            this.setDraggable(data.draggable);\n        }\n        if (Object.prototype.hasOwnProperty.call(data, 'rotationStyle')) {\n            this.setRotationStyle(data.rotationStyle);\n        }\n        if (Object.prototype.hasOwnProperty.call(data, 'visible')) {\n            this.setVisible(data.visible);\n        }\n        if (Object.prototype.hasOwnProperty.call(data, 'size')) {\n            this.setSize(data.size);\n        }\n    }\n\n    /**\n     * Put the sprite into the drag state. While in effect, setXY must be forced\n     */\n    startDrag () {\n        this.dragging = true;\n    }\n\n    /**\n     * Remove the sprite from the drag state.\n     */\n    stopDrag () {\n        this.dragging = false;\n    }\n\n\n    /**\n     * Serialize sprite info, used when emitting events about the sprite\n     * @returns {object} Sprite data as a simple object\n     */\n    toJSON () {\n        const costumes = this.getCostumes();\n        return {\n            id: this.id,\n            name: this.getName(),\n            isStage: this.isStage,\n            x: this.x,\n            y: this.y,\n            size: this.size,\n            direction: this.direction,\n            draggable: this.draggable,\n            currentCostume: this.currentCostume,\n            costume: costumes[this.currentCostume],\n            costumeCount: costumes.length,\n            visible: this.visible,\n            rotationStyle: this.rotationStyle,\n            comments: this.comments,\n            blocks: this.blocks._blocks,\n            variables: this.variables,\n            costumes: costumes,\n            sounds: this.getSounds(),\n            textToSpeechLanguage: this.textToSpeechLanguage,\n            tempo: this.tempo,\n            volume: this.volume,\n            videoTransparency: this.videoTransparency,\n            videoState: this.videoState\n\n        };\n    }\n\n    /**\n     * Dispose, destroying any run-time properties.\n     */\n    dispose () {\n        this.runtime.changeCloneCounter(-1);\n        this.runtime.stopForTarget(this);\n        this.runtime.removeExecutable(this);\n        this.sprite.removeClone(this);\n        if (this.renderer && this.drawableID !== null) {\n            this.renderer.destroyDrawable(this.drawableID, this.isStage ?\n                StageLayering.BACKGROUND_LAYER :\n                StageLayering.SPRITE_LAYER);\n            if (this.visible) {\n                this.emit(RenderedTarget.EVENT_TARGET_VISUAL_CHANGE, this);\n                this.runtime.requestRedraw();\n            }\n        }\n    }\n}\n\nmodule.exports = RenderedTarget;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/sprites/rendered-target.js?");

/***/ }),

/***/ "../scratch-vm/src/util/base64-util.js":
/*!*********************************************!*\
  !*** ../scratch-vm/src/util/base64-util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const atob = __webpack_require__(/*! atob */ \"../scratch-vm/node_modules/atob/node-atob.js\");\nconst btoa = __webpack_require__(/*! btoa */ \"../scratch-vm/node_modules/btoa/index.js\");\n\nclass Base64Util {\n\n    /**\n     * Convert a base64 encoded string to a Uint8Array.\n     * @param {string} base64 - a base64 encoded string.\n     * @return {Uint8Array} - a decoded Uint8Array.\n     */\n    static base64ToUint8Array (base64) {\n        const binaryString = atob(base64);\n        const len = binaryString.length;\n        const array = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n            array[i] = binaryString.charCodeAt(i);\n        }\n        return array;\n    }\n\n    /**\n     * Convert a Uint8Array to a base64 encoded string.\n     * @param {Uint8Array} array - the array to convert.\n     * @return {string} - the base64 encoded string.\n     */\n    static uint8ArrayToBase64 (array) {\n        const base64 = btoa(String.fromCharCode.apply(null, array));\n        return base64;\n    }\n\n    /**\n    * Convert an array buffer to a base64 encoded string.\n    * @param {array} buffer - an array buffer to convert.\n    * @return {string} - the base64 encoded string.\n    */\n    static arrayBufferToBase64 (buffer) {\n        let binary = '';\n        const bytes = new Uint8Array(buffer);\n        const len = bytes.byteLength;\n        for (let i = 0; i < len; i++) {\n            binary += String.fromCharCode(bytes[ i ]);\n        }\n        return btoa(binary);\n    }\n\n}\n\nmodule.exports = Base64Util;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/base64-util.js?");

/***/ }),

/***/ "../scratch-vm/src/util/cast.js":
/*!**************************************!*\
  !*** ../scratch-vm/src/util/cast.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Color = __webpack_require__(/*! ../util/color */ \"../scratch-vm/src/util/color.js\");\n\n/**\n * @fileoverview\n * Utilities for casting and comparing Scratch data-types.\n * Scratch behaves slightly differently from JavaScript in many respects,\n * and these differences should be encapsulated below.\n * For example, in Scratch, add(1, join(\"hello\", world\")) -> 1.\n * This is because \"hello world\" is cast to 0.\n * In JavaScript, 1 + Number(\"hello\" + \"world\") would give you NaN.\n * Use when coercing a value before computation.\n */\n\nclass Cast {\n    /**\n     * Scratch cast to number.\n     * Treats NaN as 0.\n     * In Scratch 2.0, this is captured by `interp.numArg.`\n     * @param {*} value Value to cast to number.\n     * @return {number} The Scratch-casted number value.\n     */\n    static toNumber (value) {\n        // If value is already a number we don't need to coerce it with\n        // Number().\n        if (typeof value === 'number') {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            if (Number.isNaN(value)) {\n                return 0;\n            }\n            return value;\n        }\n        const n = Number(value);\n        if (Number.isNaN(n)) {\n            // Scratch treats NaN as 0, when needed as a number.\n            // E.g., 0 + NaN -> 0.\n            return 0;\n        }\n        return n;\n    }\n\n    /**\n     * Scratch cast to boolean.\n     * In Scratch 2.0, this is captured by `interp.boolArg.`\n     * Treats some string values differently from JavaScript.\n     * @param {*} value Value to cast to boolean.\n     * @return {boolean} The Scratch-casted boolean value.\n     */\n    static toBoolean (value) {\n        // Already a boolean?\n        if (typeof value === 'boolean') {\n            return value;\n        }\n        if (typeof value === 'string') {\n            // These specific strings are treated as false in Scratch.\n            if ((value === '') ||\n                (value === '0') ||\n                (value.toLowerCase() === 'false')) {\n                return false;\n            }\n            // All other strings treated as true.\n            return true;\n        }\n        // Coerce other values and numbers.\n        return Boolean(value);\n    }\n\n    /**\n     * Scratch cast to string.\n     * @param {*} value Value to cast to string.\n     * @return {string} The Scratch-casted string value.\n     */\n    static toString (value) {\n        return String(value);\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color array to be used for the renderer.\n     * @param {*} value Value to convert to RGB color array.\n     * @return {Array.<number>} [r,g,b], values between 0-255.\n     */\n    static toRgbColorList (value) {\n        const color = Cast.toRgbColorObject(value);\n        return [color.r, color.g, color.b];\n    }\n\n    /**\n     * Cast any Scratch argument to an RGB color object to be used for the renderer.\n     * @param {*} value Value to convert to RGB color object.\n     * @return {RGBOject} [r,g,b], values between 0-255.\n     */\n    static toRgbColorObject (value) {\n        let color;\n        if (typeof value === 'string' && value.substring(0, 1) === '#') {\n            color = Color.hexToRgb(value);\n\n            // If the color wasn't *actually* a hex color, cast to black\n            if (!color) color = {r: 0, g: 0, b: 0, a: 255};\n        } else {\n            color = Color.decimalToRgb(Cast.toNumber(value));\n        }\n        return color;\n    }\n\n    /**\n     * Determine if a Scratch argument is a white space string (or null / empty).\n     * @param {*} val value to check.\n     * @return {boolean} True if the argument is all white spaces or null / empty.\n     */\n    static isWhiteSpace (val) {\n        return val === null || (typeof val === 'string' && val.trim().length === 0);\n    }\n\n    /**\n     * Compare two values, using Scratch cast, case-insensitive string compare, etc.\n     * In Scratch 2.0, this is captured by `interp.compare.`\n     * @param {*} v1 First value to compare.\n     * @param {*} v2 Second value to compare.\n     * @returns {number} Negative number if v1 < v2; 0 if equal; positive otherwise.\n     */\n    static compare (v1, v2) {\n        let n1 = Number(v1);\n        let n2 = Number(v2);\n        if (n1 === 0 && Cast.isWhiteSpace(v1)) {\n            n1 = NaN;\n        } else if (n2 === 0 && Cast.isWhiteSpace(v2)) {\n            n2 = NaN;\n        }\n        if (isNaN(n1) || isNaN(n2)) {\n            // At least one argument can't be converted to a number.\n            // Scratch compares strings as case insensitive.\n            const s1 = String(v1).toLowerCase();\n            const s2 = String(v2).toLowerCase();\n            if (s1 < s2) {\n                return -1;\n            } else if (s1 > s2) {\n                return 1;\n            }\n            return 0;\n        }\n        // Handle the special case of Infinity\n        if (\n            (n1 === Infinity && n2 === Infinity) ||\n            (n1 === -Infinity && n2 === -Infinity)\n        ) {\n            return 0;\n        }\n        // Compare as numbers.\n        return n1 - n2;\n    }\n\n    /**\n     * Determine if a Scratch argument number represents a round integer.\n     * @param {*} val Value to check.\n     * @return {boolean} True if number looks like an integer.\n     */\n    static isInt (val) {\n        // Values that are already numbers.\n        if (typeof val === 'number') {\n            if (isNaN(val)) { // NaN is considered an integer.\n                return true;\n            }\n            // True if it's \"round\" (e.g., 2.0 and 2).\n            return val === parseInt(val, 10);\n        } else if (typeof val === 'boolean') {\n            // `True` and `false` always represent integer after Scratch cast.\n            return true;\n        } else if (typeof val === 'string') {\n            // If it contains a decimal point, don't consider it an int.\n            return val.indexOf('.') < 0;\n        }\n        return false;\n    }\n\n    static get LIST_INVALID () {\n        return 'INVALID';\n    }\n\n    static get LIST_ALL () {\n        return 'ALL';\n    }\n\n    /**\n     * Compute a 1-based index into a list, based on a Scratch argument.\n     * Two special cases may be returned:\n     * LIST_ALL: if the block is referring to all of the items in the list.\n     * LIST_INVALID: if the index was invalid in any way.\n     * @param {*} index Scratch arg, including 1-based numbers or special cases.\n     * @param {number} length Length of the list.\n     * @param {boolean} acceptAll Whether it should accept \"all\" or not.\n     * @return {(number|string)} 1-based index for list, LIST_ALL, or LIST_INVALID.\n     */\n    static toListIndex (index, length, acceptAll) {\n        if (typeof index !== 'number') {\n            if (index === 'all') {\n                return acceptAll ? Cast.LIST_ALL : Cast.LIST_INVALID;\n            }\n            if (index === 'last') {\n                if (length > 0) {\n                    return length;\n                }\n                return Cast.LIST_INVALID;\n            } else if (index === 'random' || index === 'any') {\n                if (length > 0) {\n                    return 1 + Math.floor(Math.random() * length);\n                }\n                return Cast.LIST_INVALID;\n            }\n        }\n        index = Math.floor(Cast.toNumber(index));\n        if (index < 1 || index > length) {\n            return Cast.LIST_INVALID;\n        }\n        return index;\n    }\n}\n\nmodule.exports = Cast;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/cast.js?");

/***/ }),

/***/ "../scratch-vm/src/util/clone.js":
/*!***************************************!*\
  !*** ../scratch-vm/src/util/clone.js ***!
  \***************************************/
/***/ ((module) => {

eval("/**\n * Methods for cloning JavaScript objects.\n * @type {object}\n */\nclass Clone {\n    /**\n     * Deep-clone a \"simple\" object: one which can be fully expressed with JSON.\n     * Non-JSON values, such as functions, will be stripped from the clone.\n     * @param {object} original - the object to be cloned.\n     * @returns {object} a deep clone of the original object.\n     */\n    static simple (original) {\n        return JSON.parse(JSON.stringify(original));\n    }\n}\n\nmodule.exports = Clone;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/clone.js?");

/***/ }),

/***/ "../scratch-vm/src/util/color.js":
/*!***************************************!*\
  !*** ../scratch-vm/src/util/color.js ***!
  \***************************************/
/***/ ((module) => {

eval("class Color {\n    /**\n     * @typedef {object} RGBObject - An object representing a color in RGB format.\n     * @property {number} r - the red component, in the range [0, 255].\n     * @property {number} g - the green component, in the range [0, 255].\n     * @property {number} b - the blue component, in the range [0, 255].\n     */\n\n    /**\n     * @typedef {object} HSVObject - An object representing a color in HSV format.\n     * @property {number} h - hue, in the range [0-359).\n     * @property {number} s - saturation, in the range [0,1].\n     * @property {number} v - value, in the range [0,1].\n     */\n\n    /** @type {RGBObject} */\n    static get RGB_BLACK () {\n        return {r: 0, g: 0, b: 0};\n    }\n\n    /** @type {RGBObject} */\n    static get RGB_WHITE () {\n        return {r: 255, g: 255, b: 255};\n    }\n\n    /**\n     * Convert a Scratch decimal color to a hex string, #RRGGBB.\n     * @param {number} decimal RGB color as a decimal.\n     * @return {string} RGB color as #RRGGBB hex string.\n     */\n    static decimalToHex (decimal) {\n        if (decimal < 0) {\n            decimal += 0xFFFFFF + 1;\n        }\n        let hex = Number(decimal).toString(16);\n        hex = `#${'000000'.substr(0, 6 - hex.length)}${hex}`;\n        return hex;\n    }\n\n    /**\n     * Convert a Scratch decimal color to an RGB color object.\n     * @param {number} decimal RGB color as decimal.\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static decimalToRgb (decimal) {\n        const a = (decimal >> 24) & 0xFF;\n        const r = (decimal >> 16) & 0xFF;\n        const g = (decimal >> 8) & 0xFF;\n        const b = decimal & 0xFF;\n        return {r: r, g: g, b: b, a: a > 0 ? a : 255};\n    }\n\n    /**\n     * Convert a hex color (e.g., F00, #03F, #0033FF) to an RGB color object.\n     * CC-BY-SA Tim Down:\n     * https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb\n     * @param {!string} hex Hex representation of the color.\n     * @return {RGBObject} null on failure, or rgb: {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hexToRgb (hex) {\n        const shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : null;\n    }\n\n    /**\n     * Convert an RGB color object to a hex color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!string} Hex representation of the color.\n     */\n    static rgbToHex (rgb) {\n        return Color.decimalToHex(Color.rgbToDecimal(rgb));\n    }\n\n    /**\n     * Convert an RGB color object to a Scratch decimal color.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {!number} Number representing the color.\n     */\n    static rgbToDecimal (rgb) {\n        return (rgb.r << 16) + (rgb.g << 8) + rgb.b;\n    }\n\n    /**\n    * Convert a hex color (e.g., F00, #03F, #0033FF) to a decimal color number.\n    * @param {!string} hex Hex representation of the color.\n    * @return {!number} Number representing the color.\n    */\n    static hexToDecimal (hex) {\n        return Color.rgbToDecimal(Color.hexToRgb(hex));\n    }\n\n    /**\n     * Convert an HSV color to RGB format.\n     * @param {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     * @return {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     */\n    static hsvToRgb (hsv) {\n        let h = hsv.h % 360;\n        if (h < 0) h += 360;\n        const s = Math.max(0, Math.min(hsv.s, 1));\n        const v = Math.max(0, Math.min(hsv.v, 1));\n\n        const i = Math.floor(h / 60);\n        const f = (h / 60) - i;\n        const p = v * (1 - s);\n        const q = v * (1 - (s * f));\n        const t = v * (1 - (s * (1 - f)));\n\n        let r;\n        let g;\n        let b;\n\n        switch (i) {\n        default:\n        case 0:\n            r = v;\n            g = t;\n            b = p;\n            break;\n        case 1:\n            r = q;\n            g = v;\n            b = p;\n            break;\n        case 2:\n            r = p;\n            g = v;\n            b = t;\n            break;\n        case 3:\n            r = p;\n            g = q;\n            b = v;\n            break;\n        case 4:\n            r = t;\n            g = p;\n            b = v;\n            break;\n        case 5:\n            r = v;\n            g = p;\n            b = q;\n            break;\n        }\n\n        return {\n            r: Math.floor(r * 255),\n            g: Math.floor(g * 255),\n            b: Math.floor(b * 255)\n        };\n    }\n\n    /**\n     * Convert an RGB color to HSV format.\n     * @param {RGBObject} rgb - {r: red [0,255], g: green [0,255], b: blue [0,255]}.\n     * @return {HSVObject} hsv - {h: hue [0,360), s: saturation [0,1], v: value [0,1]}\n     */\n    static rgbToHsv (rgb) {\n        const r = rgb.r / 255;\n        const g = rgb.g / 255;\n        const b = rgb.b / 255;\n        const x = Math.min(Math.min(r, g), b);\n        const v = Math.max(Math.max(r, g), b);\n\n        // For grays, hue will be arbitrarily reported as zero. Otherwise, calculate\n        let h = 0;\n        let s = 0;\n        if (x !== v) {\n            const f = (r === x) ? g - b : ((g === x) ? b - r : r - g);\n            const i = (r === x) ? 3 : ((g === x) ? 5 : 1);\n            h = ((i - (f / (v - x))) * 60) % 360;\n            s = (v - x) / v;\n        }\n\n        return {h: h, s: s, v: v};\n    }\n\n    /**\n     * Linear interpolation between rgb0 and rgb1.\n     * @param {RGBObject} rgb0 - the color corresponding to fraction1 <= 0.\n     * @param {RGBObject} rgb1 - the color corresponding to fraction1 >= 1.\n     * @param {number} fraction1 - the interpolation parameter. If this is 0.5, for example, mix the two colors equally.\n     * @return {RGBObject} the interpolated color.\n     */\n    static mixRgb (rgb0, rgb1, fraction1) {\n        if (fraction1 <= 0) return rgb0;\n        if (fraction1 >= 1) return rgb1;\n        const fraction0 = 1 - fraction1;\n        return {\n            r: (fraction0 * rgb0.r) + (fraction1 * rgb1.r),\n            g: (fraction0 * rgb0.g) + (fraction1 * rgb1.g),\n            b: (fraction0 * rgb0.b) + (fraction1 * rgb1.b)\n        };\n    }\n}\n\nmodule.exports = Color;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/color.js?");

/***/ }),

/***/ "../scratch-vm/src/util/fetch-with-timeout.js":
/*!****************************************************!*\
  !*** ../scratch-vm/src/util/fetch-with-timeout.js ***!
  \****************************************************/
/***/ ((module) => {

eval("/**\n * @callback FetchFunction\n * @param {RequestInfo|URL} input\n * @param {RequestInit|undefined} [init]\n * @returns {Promise<Response>}\n */\n\n/**\n * @type {FetchFunction}\n */\nlet myFetch = global.fetch;\n\n/**\n * Tell `fetchWithTimeout` to use a specific `fetch` function.\n * By default, `fetchWithTimeout` will use the global `fetch` function.\n * If there is no global `fetch`, then `fetchWithTimeout` will fail unless provided with an alternative.\n * @param {FetchFunction} newFetch The new `fetch` function to use within fetchWithTimeout.\n */\nconst setFetch = newFetch => {\n    myFetch = newFetch;\n};\n\n/**\n * Fetch a remote resource like `fetch` does, but with a time limit.\n * @param {Request|string} resource Remote resource to fetch.\n * @param {?object} init An options object containing any custom settings that you want to apply to the request.\n * @param {number} timeout The amount of time before the request is canceled, in milliseconds\n * @returns {Promise<Response>} The response from the server.\n */\nconst fetchWithTimeout = (resource, init, timeout) => {\n    let timeoutID = null;\n    // Not supported in Safari <11\n    const controller = window.AbortController ? new window.AbortController() : null;\n    const signal = controller ? controller.signal : null;\n    // The fetch call races a timer.\n    return Promise.race([\n        myFetch(resource, Object.assign({signal}, init)).then(response => {\n            clearTimeout(timeoutID);\n            return response;\n        }),\n        new Promise((resolve, reject) => {\n            timeoutID = setTimeout(() => {\n                if (controller) controller.abort();\n                reject(new Error(`Fetch timed out after ${timeout} ms`));\n            }, timeout);\n        })\n    ]);\n};\n\nmodule.exports = {\n    fetchWithTimeout,\n    setFetch\n};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/fetch-with-timeout.js?");

/***/ }),

/***/ "../scratch-vm/src/util/get-monitor-id.js":
/*!************************************************!*\
  !*** ../scratch-vm/src/util/get-monitor-id.js ***!
  \************************************************/
/***/ ((module) => {

eval("/**\n * Returns a string representing a unique id for a monitored block\n * where a single reporter block can have more than one monitor\n * (and therefore more than one monitor block) associated\n * with it (e.g. when reporter blocks have inputs).\n * @param {string} baseId The base id to use for the different monitor blocks\n * @param {object} fields The monitor block's fields object.\n */\n// TODO this function should eventually be the single place where all monitor\n// IDs are obtained given an opcode for the reporter block and the list of\n// selected parameters.\nconst getMonitorIdForBlockWithArgs = function (id, fields) {\n    let fieldString = '';\n    for (const fieldKey in fields) {\n        let fieldValue = fields[fieldKey].value;\n        if (fieldKey === 'CURRENTMENU') {\n            // The 'sensing_current' block has field values in all caps.\n            // However, when importing from scratch 2.0, these\n            // could have gotten imported as lower case field values.\n            // Normalize the field value here so that we don't ever\n            // end up with a different monitor ID representing the same\n            // block configuration\n            // Note: we are not doing this for every block field that comes into\n            // this function so as not to make the faulty assumption that block\n            // field values coming in would be unique after being made lower case\n            fieldValue = fieldValue.toLowerCase();\n        }\n        fieldString += `_${fieldValue}`;\n    }\n    return `${id}${fieldString}`;\n};\n\nmodule.exports = getMonitorIdForBlockWithArgs;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/get-monitor-id.js?");

/***/ }),

/***/ "../scratch-vm/src/util/jsonrpc.js":
/*!*****************************************!*\
  !*** ../scratch-vm/src/util/jsonrpc.js ***!
  \*****************************************/
/***/ ((module) => {

eval("class JSONRPC {\n    constructor () {\n        this._requestID = 0;\n        this._openRequests = {};\n    }\n\n    /**\n     * Make an RPC request and retrieve the result.\n     * @param {string} method - the remote method to call.\n     * @param {object} params - the parameters to pass to the remote method.\n     * @returns {Promise} - a promise for the result of the call.\n     */\n    sendRemoteRequest (method, params) {\n        const requestID = this._requestID++;\n\n        const promise = new Promise((resolve, reject) => {\n            this._openRequests[requestID] = {resolve, reject};\n        });\n\n        this._sendRequest(method, params, requestID);\n\n        return promise;\n    }\n\n    /**\n     * Make an RPC notification with no expectation of a result or callback.\n     * @param {string} method - the remote method to call.\n     * @param {object} params - the parameters to pass to the remote method.\n     */\n    sendRemoteNotification (method, params) {\n        this._sendRequest(method, params);\n    }\n\n    /**\n     * Handle an RPC request from remote, should return a result or Promise for result, if appropriate.\n     * @param {string} method - the method requested by the remote caller.\n     * @param {object} params - the parameters sent with the remote caller's request.\n     */\n    didReceiveCall (/* method , params */) {\n        throw new Error('Must override didReceiveCall');\n    }\n\n    _sendMessage (/* jsonMessageObject */) {\n        throw new Error('Must override _sendMessage');\n    }\n\n    _sendRequest (method, params, id) {\n        const request = {\n            jsonrpc: '2.0',\n            method,\n            params\n        };\n\n        if (id !== null) {\n            request.id = id;\n        }\n\n        this._sendMessage(request);\n    }\n\n    _handleMessage (json) {\n        if (json.jsonrpc !== '2.0') {\n            throw new Error(`Bad or missing JSON-RPC version in message: ${json}`);\n        }\n        if (Object.prototype.hasOwnProperty.call(json, 'method')) {\n            this._handleRequest(json);\n        } else {\n            this._handleResponse(json);\n        }\n    }\n\n    _sendResponse (id, result, error) {\n        const response = {\n            jsonrpc: '2.0',\n            id\n        };\n        if (error) {\n            response.error = error;\n        } else {\n            response.result = result || null;\n        }\n        this._sendMessage(response);\n    }\n\n    _handleResponse (json) {\n        const {result, error, id} = json;\n        const openRequest = this._openRequests[id];\n        delete this._openRequests[id];\n        if (openRequest) {\n            if (error) {\n                openRequest.reject(error);\n            } else {\n                openRequest.resolve(result);\n            }\n        }\n    }\n\n    _handleRequest (json) {\n        const {method, params, id} = json;\n        const rawResult = this.didReceiveCall(method, params);\n        if (id !== null && typeof id !== 'undefined') {\n            Promise.resolve(rawResult).then(\n                result => {\n                    this._sendResponse(id, result);\n                },\n                error => {\n                    this._sendResponse(id, null, error);\n                }\n            );\n        }\n    }\n}\n\nmodule.exports = JSONRPC;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/jsonrpc.js?");

/***/ }),

/***/ "../scratch-vm/src/util/log.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/util/log.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const minilog = __webpack_require__(/*! minilog */ \"../scratch-vm/node_modules/minilog/lib/index.js\");\nminilog.enable();\n\nmodule.exports = minilog('vm');\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/log.js?");

/***/ }),

/***/ "../scratch-vm/src/util/math-util.js":
/*!*******************************************!*\
  !*** ../scratch-vm/src/util/math-util.js ***!
  \*******************************************/
/***/ ((module) => {

eval("class MathUtil {\n    /**\n     * Convert a value from degrees to radians.\n     * @param {!number} deg Value in degrees.\n     * @return {!number} Equivalent value in radians.\n     */\n    static degToRad (deg) {\n        return deg * Math.PI / 180;\n    }\n\n    /**\n     * Convert a value from radians to degrees.\n     * @param {!number} rad Value in radians.\n     * @return {!number} Equivalent value in degrees.\n     */\n    static radToDeg (rad) {\n        return rad * 180 / Math.PI;\n    }\n\n    /**\n     * Clamp a number between two limits.\n     * If n < min, return min. If n > max, return max. Else, return n.\n     * @param {!number} n Number to clamp.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n clamped to min and max.\n     */\n    static clamp (n, min, max) {\n        return Math.min(Math.max(n, min), max);\n    }\n\n    /**\n     * Keep a number between two limits, wrapping \"extra\" into the range.\n     * e.g., wrapClamp(7, 1, 5) == 2\n     * wrapClamp(0, 1, 5) == 5\n     * wrapClamp(-11, -10, 6) == 6, etc.\n     * @param {!number} n Number to wrap.\n     * @param {!number} min Minimum limit.\n     * @param {!number} max Maximum limit.\n     * @return {!number} Value of n wrapped between min and max.\n     */\n    static wrapClamp (n, min, max) {\n        const range = (max - min) + 1;\n        return n - (Math.floor((n - min) / range) * range);\n    }\n\n\n    /**\n     * Convert a value from tan function in degrees.\n     * @param {!number} angle in degrees\n     * @return {!number} Correct tan value\n     */\n    static tan (angle) {\n        angle = angle % 360;\n        switch (angle) {\n        case -270:\n        case 90:\n            return Infinity;\n        case -90:\n        case 270:\n            return -Infinity;\n        default:\n            return parseFloat(Math.tan((Math.PI * angle) / 180).toFixed(10));\n        }\n    }\n\n    /**\n     * Given an array of unique numbers,\n     * returns a reduced array such that each element of the reduced array\n     * represents the position of that element in a sorted version of the\n     * original array.\n     * E.g. [5, 19. 13, 1] => [1, 3, 2, 0]\n     * @param {Array<number>} elts The elements to sort and reduce\n     * @return {Array<number>} The array of reduced orderings\n     */\n    static reducedSortOrdering (elts) {\n        const sorted = elts.slice(0).sort((a, b) => a - b);\n        return elts.map(e => sorted.indexOf(e));\n    }\n\n    /**\n     * Return a random number given an inclusive range and a number in that\n     * range that should be excluded.\n     *\n     * For instance, (1, 5, 3) will only pick 1, 2, 4, or 5 (with equal\n     * probability)\n     *\n     * @param {number} lower - The lower bound (inlcusive)\n     * @param {number} upper - The upper bound (inclusive), such that lower <= upper\n     * @param {number} excluded - The number to exclude (MUST be in the range)\n     * @return {number} A random integer in the range [lower, upper] that is not \"excluded\"\n     */\n    static inclusiveRandIntWithout (lower, upper, excluded) {\n        // Note that subtraction is the number of items in the\n        // inclusive range [lower, upper] minus 1 already\n        // (e.g. in the set {3, 4, 5}, 5 - 3 = 2).\n        const possibleOptions = upper - lower;\n\n        const randInt = lower + Math.floor(Math.random() * possibleOptions);\n        if (randInt >= excluded) {\n            return randInt + 1;\n        }\n\n        return randInt;\n    }\n \n    /**\n     * Scales a number from one range to another.\n     * @param {number} i number to be scaled\n     * @param {number} iMin input range minimum\n     * @param {number} iMax input range maximum\n     * @param {number} oMin output range minimum\n     * @param {number} oMax output range maximum\n     * @return {number} scaled number\n     */\n    static scale (i, iMin, iMax, oMin, oMax) {\n        const p = (i - iMin) / (iMax - iMin);\n        return (p * (oMax - oMin)) + oMin;\n    }\n}\n\nmodule.exports = MathUtil;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/math-util.js?");

/***/ }),

/***/ "../scratch-vm/src/util/maybe-format-message.js":
/*!******************************************************!*\
  !*** ../scratch-vm/src/util/maybe-format-message.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const formatMessage = __webpack_require__(/*! format-message */ \"../scratch-vm/node_modules/format-message/index.js\");\n\n/**\n * Check if `maybeMessage` looks like a message object, and if so pass it to `formatMessage`.\n * Otherwise, return `maybeMessage` as-is.\n * @param {*} maybeMessage - something that might be a message descriptor object.\n * @param {object} [args] - the arguments to pass to `formatMessage` if it gets called.\n * @param {string} [locale] - the locale to pass to `formatMessage` if it gets called.\n * @return {string|*} - the formatted message OR the original `maybeMessage` input.\n */\nconst maybeFormatMessage = function (maybeMessage, args, locale) {\n    if (maybeMessage && maybeMessage.id && maybeMessage.default) {\n        return formatMessage(maybeMessage, args, locale);\n    }\n    return maybeMessage;\n};\n\nmodule.exports = maybeFormatMessage;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/maybe-format-message.js?");

/***/ }),

/***/ "../scratch-vm/src/util/rateLimiter.js":
/*!*********************************************!*\
  !*** ../scratch-vm/src/util/rateLimiter.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Timer = __webpack_require__(/*! ../util/timer */ \"../scratch-vm/src/util/timer.js\");\n\nclass RateLimiter {\n    /**\n     * A utility for limiting the rate of repetitive send operations, such as\n     * bluetooth messages being sent to hardware devices. It uses the token bucket\n     * strategy: a counter accumulates tokens at a steady rate, and each send costs\n     * a token. If no tokens remain, it's not okay to send.\n     * @param {number} maxRate the maximum number of sends allowed per second\n     * @constructor\n     */\n    constructor (maxRate) {\n        /**\n         * The maximum number of tokens.\n         * @type {number}\n         */\n        this._maxTokens = maxRate;\n\n        /**\n         * The interval in milliseconds for refilling one token. It is calculated\n         * so that the tokens will be filled to maximum in one second.\n         * @type {number}\n         */\n        this._refillInterval = 1000 / maxRate;\n\n        /**\n         * The current number of tokens in the bucket.\n         * @type {number}\n         */\n        this._count = this._maxTokens;\n\n        this._timer = new Timer();\n        this._timer.start();\n\n        /**\n         * The last time in milliseconds when the token count was updated.\n         * @type {number}\n         */\n        this._lastUpdateTime = this._timer.timeElapsed();\n    }\n\n    /**\n     * Check if it is okay to send a message, by updating the token count,\n     * taking a token and then checking if we are still under the rate limit.\n     * @return {boolean} true if we are under the rate limit\n     */\n    okayToSend () {\n        // Calculate the number of tokens to refill the bucket with, based on the\n        // amount of time since the last refill.\n        const now = this._timer.timeElapsed();\n        const timeSinceRefill = now - this._lastUpdateTime;\n        const refillCount = Math.floor(timeSinceRefill / this._refillInterval);\n\n        // If we're adding at least one token, reset _lastUpdateTime to now.\n        // Otherwise, don't reset it so that we can continue measuring time until\n        // the next refill.\n        if (refillCount > 0) {\n            this._lastUpdateTime = now;\n        }\n\n        // Refill the tokens up to the maximum\n        this._count = Math.min(this._maxTokens, this._count + refillCount);\n\n        // If we have at least one token, use one, and it's okay to send.\n        if (this._count > 0) {\n            this._count--;\n            return true;\n        }\n        return false;\n    }\n}\n\nmodule.exports = RateLimiter;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/rateLimiter.js?");

/***/ }),

/***/ "../scratch-vm/src/util/scratch-link-websocket.js":
/*!********************************************************!*\
  !*** ../scratch-vm/src/util/scratch-link-websocket.js ***!
  \********************************************************/
/***/ ((module) => {

eval("/**\n * This class provides a ScratchLinkSocket implementation using WebSockets,\n * attempting to connect with the locally installed Scratch-Link.\n *\n * To connect with ScratchLink without WebSockets, you must implement all of the\n * public methods in this class.\n * - open()\n * - close()\n * - setOn[Open|Close|Error]\n * - setHandleMessage\n * - sendMessage(msgObj)\n * - isOpen()\n */\nclass ScratchLinkWebSocket {\n    constructor (type) {\n        this._type = type;\n        this._onOpen = null;\n        this._onClose = null;\n        this._onError = null;\n        this._handleMessage = null;\n\n        this._ws = null;\n    }\n\n    open () {\n        if (!(this._onOpen && this._onClose && this._onError && this._handleMessage)) {\n            throw new Error('Must set open, close, message and error handlers before calling open on the socket');\n        }\n\n        let pathname;\n        switch (this._type) {\n        case 'BLE':\n            pathname = 'scratch/ble';\n            break;\n        case 'BT':\n            pathname = 'scratch/bt';\n            break;\n        default:\n            throw new Error(`Unknown ScratchLink socket Type: ${this._type}`);\n        }\n\n        // Try ws:// (the new way) and wss:// (the old way) simultaneously. If either connects, close the other. If we\n        // were to try one and fall back to the other on failure, that could mean a delay of 30 seconds or more for\n        // those who need the fallback.\n        // If both connections fail we should report only one error.\n\n        const setSocket = (socketToUse, socketToClose) => {\n            socketToClose.onopen = socketToClose.onerror = null;\n            socketToClose.close();\n\n            this._ws = socketToUse;\n            this._ws.onopen = this._onOpen;\n            this._ws.onclose = this._onClose;\n            this._ws.onerror = this._onError;\n            this._ws.onmessage = this._onMessage.bind(this);\n        };\n\n        const ws = new WebSocket(`ws://127.0.0.1:20111/${pathname}`);\n        const wss = new WebSocket(`wss://device-manager.scratch.mit.edu:20110/${pathname}`);\n\n        const connectTimeout = setTimeout(() => {\n            // neither socket succeeded before the timeout\n            setSocket(ws, wss);\n            this._ws.onerror(new Event('timeout'));\n        }, 15 * 1000);\n        ws.onopen = openEvent => {\n            clearTimeout(connectTimeout);\n            setSocket(ws, wss);\n            this._ws.onopen(openEvent);\n        };\n        wss.onopen = openEvent => {\n            clearTimeout(connectTimeout);\n            setSocket(wss, ws);\n            this._ws.onopen(openEvent);\n        };\n\n        let wsError;\n        let wssError;\n        const errorHandler = () => {\n            // if only one has received an error, we haven't overall failed yet\n            if (wsError && wssError) {\n                clearTimeout(connectTimeout);\n                setSocket(ws, wss);\n                this._ws.onerror(wsError);\n            }\n        };\n        ws.onerror = errorEvent => {\n            wsError = errorEvent;\n            errorHandler();\n        };\n        wss.onerror = errorEvent => {\n            wssError = errorEvent;\n            errorHandler();\n        };\n    }\n\n    close () {\n        this._ws.close();\n        this._ws = null;\n    }\n\n    sendMessage (message) {\n        const messageText = JSON.stringify(message);\n        this._ws.send(messageText);\n    }\n\n    setOnOpen (fn) {\n        this._onOpen = fn;\n    }\n\n    setOnClose (fn) {\n        this._onClose = fn;\n    }\n\n    setOnError (fn) {\n        this._onError = fn;\n    }\n\n    setHandleMessage (fn) {\n        this._handleMessage = fn;\n    }\n\n    isOpen () {\n        return this._ws && this._ws.readyState === this._ws.OPEN;\n    }\n\n    _onMessage (e) {\n        const json = JSON.parse(e.data);\n        this._handleMessage(json);\n    }\n}\n\nmodule.exports = ScratchLinkWebSocket;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/scratch-link-websocket.js?");

/***/ }),

/***/ "../scratch-vm/src/util/string-util.js":
/*!*********************************************!*\
  !*** ../scratch-vm/src/util/string-util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const log = __webpack_require__(/*! ./log */ \"../scratch-vm/src/util/log.js\");\n\nclass StringUtil {\n    static withoutTrailingDigits (s) {\n        let i = s.length - 1;\n        while ((i >= 0) && ('0123456789'.indexOf(s.charAt(i)) > -1)) i--;\n        return s.slice(0, i + 1);\n    }\n\n    static unusedName (name, existingNames) {\n        if (existingNames.indexOf(name) < 0) return name;\n        name = StringUtil.withoutTrailingDigits(name);\n        let i = 2;\n        while (existingNames.indexOf(name + i) >= 0) i++;\n        return name + i;\n    }\n\n    /**\n     * Split a string on the first occurrence of a split character.\n     * @param {string} text - the string to split.\n     * @param {string} separator - split the text on this character.\n     * @returns {string[]} - the two parts of the split string, or [text, null] if no split character found.\n     * @example\n     * // returns ['foo', 'tar.gz']\n     * splitFirst('foo.tar.gz', '.');\n     * @example\n     * // returns ['foo', null]\n     * splitFirst('foo', '.');\n     * @example\n     * // returns ['foo', '']\n     * splitFirst('foo.', '.');\n     */\n    static splitFirst (text, separator) {\n        const index = text.indexOf(separator);\n        if (index >= 0) {\n            return [text.substring(0, index), text.substring(index + 1)];\n        }\n        return [text, null];\n\n    }\n\n    /**\n     * A customized version of JSON.stringify that sets Infinity/NaN to 0,\n     * instead of the default (null).\n     * Needed because null is not of type number, but Infinity/NaN are, which\n     * can lead to serialization producing JSON that isn't valid based on the parser schema.\n     * It is also consistent with the behavior of saving 2.0 projects.\n     * This is only needed when stringifying an object for saving.\n     *\n     * @param {!object} obj - The object to serialize\n     * @return {!string} The JSON.stringified string with Infinity/NaN replaced with 0\n     */\n    static stringify (obj) {\n        return JSON.stringify(obj, (_key, value) => {\n            if (typeof value === 'number' &&\n               (value === Infinity || value === -Infinity || isNaN(value))){\n                return 0;\n            }\n            return value;\n        });\n    }\n    /**\n     * A function to replace unsafe characters (not allowed in XML) with safe ones. This is used\n     * in cases where we're replacing non-user facing strings (e.g. variable IDs).\n     * When replacing user facing strings, the xmlEscape utility function should be used\n     * instead so that the user facing string does not change how it displays.\n     * @param {!string | !Array.<string>} unsafe Unsafe string possibly containing unicode control characters.\n     * In some cases this argument may be an array (e.g. hacked inputs from 2.0)\n     * @return {string} String with control characters replaced.\n     */\n    static replaceUnsafeChars (unsafe) {\n        if (typeof unsafe !== 'string') {\n            if (Array.isArray(unsafe)) {\n                // This happens when we have hacked blocks from 2.0\n                // See #1030\n                unsafe = String(unsafe);\n            } else {\n                log.error('Unexpected input recieved in replaceUnsafeChars');\n                return unsafe;\n            }\n        }\n        return unsafe.replace(/[<>&'\"]/g, c => {\n            switch (c) {\n            case '<': return 'lt';\n            case '>': return 'gt';\n            case '&': return 'amp';\n            case '\\'': return 'apos';\n            case '\"': return 'quot';\n            }\n        });\n    }\n}\n\nmodule.exports = StringUtil;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/string-util.js?");

/***/ }),

/***/ "../scratch-vm/src/util/timer.js":
/*!***************************************!*\
  !*** ../scratch-vm/src/util/timer.js ***!
  \***************************************/
/***/ ((module) => {

eval("/**\n * @fileoverview\n * A utility for accurately measuring time.\n * To use:\n * ---\n * var timer = new Timer();\n * timer.start();\n * ... pass some time ...\n * var timeDifference = timer.timeElapsed();\n * ---\n * Or, you can use the `time` function\n * to do some measurement yourself.\n */\n\nclass Timer {\n    constructor (nowObj = Timer.nowObj) {\n        /**\n         * Used to store the start time of a timer action.\n         * Updated when calling `timer.start`.\n         */\n        this.startTime = 0;\n\n        /**\n         * Used to pass custom logic for determining the value for \"now\",\n         * which is sometimes useful for compatibility with Scratch 2\n         */\n        this.nowObj = nowObj;\n    }\n\n    /**\n     * Disable use of self.performance for now as it results in lower performance\n     * However, instancing it like below (caching the self.performance to a local variable) negates most of the issues.\n     * @type {boolean}\n     */\n    static get USE_PERFORMANCE () {\n        return false;\n    }\n\n    /**\n     * Legacy object to allow for us to call now to get the old style date time (for backwards compatibility)\n     * @deprecated This is only called via the nowObj.now() if no other means is possible...\n     */\n    static get legacyDateCode () {\n        return {\n            now: function () {\n                return new Date().getTime();\n            }\n        };\n    }\n\n    /**\n     * Use this object to route all time functions through single access points.\n     */\n    static get nowObj () {\n        if (Timer.USE_PERFORMANCE && typeof self !== 'undefined' && self.performance && 'now' in self.performance) {\n            return self.performance;\n        } else if (Date.now) {\n            return Date;\n        }\n        return Timer.legacyDateCode;\n    }\n\n    /**\n     * Return the currently known absolute time, in ms precision.\n     * @returns {number} ms elapsed since 1 January 1970 00:00:00 UTC.\n     */\n    time () {\n        return this.nowObj.now();\n    }\n\n    /**\n     * Start a timer for measuring elapsed time,\n     * at the most accurate precision possible.\n     */\n    start () {\n        this.startTime = this.nowObj.now();\n    }\n\n    timeElapsed () {\n        return this.nowObj.now() - this.startTime;\n    }\n\n    /**\n     * Call a handler function after a specified amount of time has elapsed.\n     * @param {function} handler - function to call after the timeout\n     * @param {number} timeout - number of milliseconds to delay before calling the handler\n     * @returns {number} - the ID of the new timeout\n     */\n    setTimeout (handler, timeout) {\n        return global.setTimeout(handler, timeout);\n    }\n\n    /**\n     * Clear a timeout from the pending timeout pool.\n     * @param {number} timeoutId - the ID returned by `setTimeout()`\n     * @memberof Timer\n     */\n    clearTimeout (timeoutId) {\n        global.clearTimeout(timeoutId);\n    }\n}\n\nmodule.exports = Timer;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/timer.js?");

/***/ }),

/***/ "../scratch-vm/src/util/uid.js":
/*!*************************************!*\
  !*** ../scratch-vm/src/util/uid.js ***!
  \*************************************/
/***/ ((module) => {

eval("/**\n * @fileoverview UID generator, from Blockly.\n */\n\n/**\n * Legal characters for the unique ID.\n * Should be all on a US keyboard.  No XML special characters or control codes.\n * Removed $ due to issue 251.\n * @private\n */\nconst soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' +\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n\n/**\n * Generate a unique ID, from Blockly.  This should be globally unique.\n * 87 characters ^ 20 length > 128 bits (better than a UUID).\n * @return {string} A globally unique ID string.\n */\nconst uid = function () {\n    const length = 20;\n    const soupLength = soup_.length;\n    const id = [];\n    for (let i = 0; i < length; i++) {\n        id[i] = soup_.charAt(Math.random() * soupLength);\n    }\n    return id.join('');\n};\n\nmodule.exports = uid;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/uid.js?");

/***/ }),

/***/ "../scratch-vm/src/util/variable-util.js":
/*!***********************************************!*\
  !*** ../scratch-vm/src/util/variable-util.js ***!
  \***********************************************/
/***/ ((module) => {

eval("class VariableUtil {\n    static _mergeVarRefObjects (accum, obj2) {\n        for (const id in obj2) {\n            if (accum[id]) {\n                accum[id] = accum[id].concat(obj2[id]);\n            } else {\n                accum[id] = obj2[id];\n            }\n        }\n        return accum;\n    }\n\n    /**\n     * Get all variable/list references in the given list of targets\n     * in the project.\n     * @param {Array.<Target>} targets The list of targets to get the variable\n     * and list references from.\n     * @param {boolean} shouldIncludeBroadcast Whether to include broadcast message fields.\n     * @return {object} An object with variable ids as the keys and a list of block fields referencing\n     * the variable.\n     */\n    static getAllVarRefsForTargets (targets, shouldIncludeBroadcast) {\n        return targets\n            .map(t => t.blocks.getAllVariableAndListReferences(null, shouldIncludeBroadcast))\n            .reduce(VariableUtil._mergeVarRefObjects, {});\n    }\n\n    /**\n     * Give all variable references provided a new id and possibly new name.\n     * @param {Array<object>} referencesToUpdate Context of the change, the object containing variable\n     * references to update.\n     * @param {string} newId ID of the variable that the old references should be replaced with\n     * @param {?string} optNewName New variable name to merge with. The old\n     * variable name in the references being updated should be replaced with this new name.\n     * If this parameter is not provided or is '', no name change occurs.\n     */\n    static updateVariableIdentifiers (referencesToUpdate, newId, optNewName) {\n        referencesToUpdate.map(ref => {\n            ref.referencingField.id = newId;\n            if (optNewName) {\n                ref.referencingField.value = optNewName;\n            }\n            return ref;\n        });\n    }\n}\n\nmodule.exports = VariableUtil;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/variable-util.js?");

/***/ }),

/***/ "../scratch-vm/src/util/xml-escape.js":
/*!********************************************!*\
  !*** ../scratch-vm/src/util/xml-escape.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const log = __webpack_require__(/*! ./log */ \"../scratch-vm/src/util/log.js\");\n\n/**\n * Escape a string to be safe to use in XML content.\n * CC-BY-SA: hgoebl\n * https://stackoverflow.com/questions/7918868/\n * how-to-escape-xml-entities-in-javascript\n * @param {!string | !Array.<string>} unsafe Unsafe string.\n * @return {string} XML-escaped string, for use within an XML tag.\n */\nconst xmlEscape = function (unsafe) {\n    if (typeof unsafe !== 'string') {\n        if (Array.isArray(unsafe)) {\n            // This happens when we have hacked blocks from 2.0\n            // See #1030\n            unsafe = String(unsafe);\n        } else {\n            log.error('Unexpected input recieved in replaceUnsafeChars');\n            return unsafe;\n        }\n    }\n    return unsafe.replace(/[<>&'\"]/g, c => {\n        switch (c) {\n        case '<': return '&lt;';\n        case '>': return '&gt;';\n        case '&': return '&amp;';\n        case '\\'': return '&apos;';\n        case '\"': return '&quot;';\n        }\n    });\n};\n\nmodule.exports = xmlEscape;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/../scratch-vm/src/util/xml-escape.js?");

/***/ }),

/***/ "./extensions/device.js":
/*!******************************!*\
  !*** ./extensions/device.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BLE = __webpack_require__(/*! ../../scratch-vm/src/io/ble.js */ \"../scratch-vm/src/io/ble.js\");\n// eslint-disable-next-line no-unused-vars\nconst Runtime = __webpack_require__(/*! ../../scratch-vm/src/engine/runtime.js */ \"../scratch-vm/src/engine/runtime.js\");\nconst Base64Util = __webpack_require__(/*! ../../scratch-vm/src/util/base64-util.js */ \"../scratch-vm/src/util/base64-util.js\");\nconst RateLimiter = __webpack_require__(/*! ../../scratch-vm/src/util/rateLimiter.js */ \"../scratch-vm/src/util/rateLimiter.js\");\n\nconst SamLabsBLE = {\n    battServ: '0000180f-0000-1000-8000-00805f9b34fb',\n    batteryLevelCharacteristic: '00002a19-0000-1000-8000-00805f9b34fb',\n    SAMServ: '3b989460-975f-11e4-a9fb-0002a5d5c51b',\n    SensorCharacteristic: '4c592e60-980c-11e4-959a-0002a5d5c51b',\n    ActorCharacteristic: '84fc1520-980c-11e4-8bed-0002a5d5c51b',\n    StatusLedCharacteristic: '5baab0a0-980c-11e4-b5e9-0002a5d5c51b',\n    SAMBotCommandCharacteristic: 'abcd1234-1234-1234-1234-0002a5d5c51b',\n    sendInterval: 50,\n    sendRateMax: 20\n};\n\nconst BabyBotIndex = 1;\n\nconst DeviceTypes = [\n    {name: 'undefined', advName: ''},\n    {name: 'Baby SAM Bot', advName: 'SAM BabyBot'},\n    {name: 'slider', advName: 'SAM Potentiometer'},\n    {name: 'light sensor', advName: 'SAM LDR'},\n    {name: 'button', advName: 'SAM Button'},\n    {name: 'proximity', advName: 'SAM IR Sensor'},\n    {name: 'heat', advName: 'SAM Temperature'},\n    {name: 'tilt', advName: 'SAM Tilt'},\n    {name: 'pressure', advName: 'SAM Pressure'},\n    {name: 'RGB led', advName: 'SAM RGB LED'},\n    {name: 'DC motor', advName: 'SAM DC Motor'},\n    {name: 'servo', advName: 'SAM Servo Motor'}\n];\n\nclass SAMDevice {\n    id = '';\n    /**\n     * @type {BluetoothDevice | Object}\n     */\n    device;\n    typeId = 0;\n    deviceType = DeviceTypes[0];\n    displayName = `${DeviceTypes[0].name} 1`;\n    sameDevices = 1;\n    SensorAvailable = false;\n    ActorAvailable = false;\n    SAMBotAvailable = false;\n    /**\n     * @type {BluetoothRemoteGATTCharacteristic}\n     */\n    batteryLevelCharacteristic;\n    /**\n     * @type {BluetoothRemoteGATTCharacteristic}\n     */\n    SAMSensorCharacteristic;\n    /**\n     * @type {BluetoothRemoteGATTCharacteristic}\n     */\n    SAMActorCharacteristic;\n    /**\n     * @type {BluetoothRemoteGATTCharacteristic}\n     */\n    SAMBotCharacteristic;\n    /**\n     * @type {BluetoothRemoteGATTCharacteristic}\n     */\n    SAMStatusLEDCharacteristic;\n    value = 0;\n    battery = 0;\n\n    /**\n     * @type {BLE}\n     */\n    _ble = null;\n\n    /**\n     * @type {Runtime}\n     */\n    _runtime = null;\n\n    /**\n     * constructor\n     * @param {Runtime} runtime Scratch runtime object\n     * @param {string} id extension id\n     */\n    constructor (runtime, id) {\n        this._rateLimiter = new RateLimiter(SamLabsBLE.sendRateMax);\n        this._runtime = runtime;\n        this.extID = id;\n        if (navigator.bluetooth) {\n            this.webBLE = true;\n        }\n        this._runtime.on(this._runtime.constructor.PERIPHERAL_SCAN_TIMEOUT, this.discoverTimeout.bind(this));\n    }\n\n    async connectToDevice (deviceMap, options) {\n        this.deviceMap = deviceMap;\n        try {\n            if (this.webBLE) {\n                if (!await this.connectWebBLE(options)) {\n                    return false;\n                }\n            } else if (!await this.connectScratchLink(options)) {\n                return false;\n            }\n            this.writeStatusLed(new Uint8Array([255, 255, 255]));\n            return true;\n        } catch (error) {\n            console.log(error);\n            return false;\n        }\n    }\n\n    async connectWebBLE (options) {\n        // Request a Bluetooth device with the specified filter\n        const device = await navigator.bluetooth.requestDevice(options);\n\n        this.device = device;\n\n        console.log('Device found:', this.device);\n\n        this.device.addEventListener('gattserverdisconnected', () => this.onDisconnected());\n\n        // Connect to the GATT server\n        const server = await this.device.gatt.connect();\n        console.log('Connected to GATT Server:', server);\n        // Get the Battery Service\n        const battServ = await server.getPrimaryService(SamLabsBLE.battServ);\n\n        // Get the Battery Level Characteristic\n        this.batteryLevelCharacteristic = await battServ.getCharacteristic(SamLabsBLE.batteryLevelCharacteristic);\n        console.log('Found battery characteristic');\n        const SAMServ = await server.getPrimaryService(SamLabsBLE.SAMServ);\n\n        this.SAMSensorCharacteristic = null;\n        this.SensorAvailable = true;\n\n        try {\n            this.SAMSensorCharacteristic = await SAMServ.getCharacteristic(SamLabsBLE.SensorCharacteristic);\n            console.log('Found sensor characteristic');\n        } catch (error) {\n            console.log('Sensor characteristic not found');\n            this.SensorAvailable = false;\n        }\n        this.SAMActorCharacteristic = null;\n        this.ActorAvailable = true;\n\n        try {\n            this.SAMActorCharacteristic = await SAMServ.getCharacteristic(SamLabsBLE.ActorCharacteristic);\n            console.log('Found actor characteristic');\n        } catch (error) {\n            console.log('Actor characteristic not found');\n            this.ActorAvailable = false;\n        }\n        this.SAMBotCharacteristic = null;\n        this.SAMBotAvailable = (device.name === 'SAM BabyBot');\n\n        if (this.SAMBotAvailable) {\n            try {\n                this.SAMBotCharacteristic = await SAMServ.getCharacteristic(SamLabsBLE.SAMBotCommandCharacteristic);\n                console.log('Found samBot characteristic');\n            } catch (error) {\n                console.log('samBot characteristic not found');\n            }\n        }\n\n        this.SAMStatusLEDCharacteristic = await SAMServ.getCharacteristic(SamLabsBLE.StatusLedCharacteristic);\n        console.log('Found statusled characteristic');\n\n        let sameDevices = 1;\n        this.deviceMap.forEach(value => {\n            if (value.device.name === device.name) {\n                sameDevices++;\n            }\n        });\n        this.typeId = 0;\n        for (this.typeId = 0; this.typeId < DeviceTypes.length; this.typeId++) {\n            if (DeviceTypes[this.typeId].advName === device.name) {\n                break;\n            }\n        }\n        if (this.typeId === DeviceTypes.length) {\n            this.typeId = 0;\n        }\n        this.displayName = `${DeviceTypes[this.typeId].name} ${sameDevices}`;\n        this.id = device.id;\n        this.deviceType = DeviceTypes[this.typeId];\n        this.sameDevices = sameDevices;\n        this.device = device;\n\n        if (this.SensorAvailable && !this.SAMBotAvailable) {\n            try {\n                await this.SAMSensorCharacteristic.startNotifications();\n                this.SAMSensorCharacteristic.addEventListener('characteristicvaluechanged',\n                    this.handleSensorNotifications.bind(this));\n                console.log('subscribed to sensor events');\n            } catch (error) {\n                console.log('Failed to subscribe to sensor events:', error);\n            }\n        }\n\n        try {\n            await this.batteryLevelCharacteristic.startNotifications();\n            this.batteryLevelCharacteristic.addEventListener('characteristicvaluechanged',\n                this.handleBattChange.bind(this));\n            console.log('subscribed to battery events');\n        } catch (error) {\n            console.log('Failed to subscribe to battery events:', error);\n        }\n\n        console.log(`Connected to ${device.name || 'Unknown Device'}, id ${device.id}, sambot ${this.SAMBotAvailable}`);\n        return true;\n    }\n\n    addStyles () {\n        const style = document.createElement('style');\n        style.innerHTML = `\n            #device-list-container {\n                position: fixed;\n                top: 20%;\n                left: 50%;\n                transform: translate(-50%, -20%);\n                background: white;\n                padding: 15px;\n                border-radius: 10px;\n                box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.3);\n                width: 300px;\n                max-height: 400px;\n                overflow-y: auto;\n                z-index: 9999; /* Ensure it appears above Scratch */\n                font-family: Arial, sans-serif;\n            }\n    \n            #device-list-container h3 {\n                margin: 0;\n                padding-bottom: 10px;\n                text-align: center;\n                border-bottom: 1px solid #ccc;\n            }\n    \n            #device-list {\n                list-style: none;\n                padding: 0;\n                margin: 10px 0;\n            }\n    \n            #device-list li {\n                padding: 10px;\n                cursor: pointer;\n                background: #f9f9f9;\n                margin-bottom: 5px;\n                border-radius: 5px;\n                text-align: center;\n                transition: background 0.2s;\n            }\n    \n            #device-list li:hover {\n                background: #ddd;\n            }\n    \n            #close-device-list {\n                display: block;\n                width: 100%;\n                padding: 8px;\n                margin-top: 10px;\n                background: #ff4d4d;\n                color: white;\n                border: none;\n                border-radius: 5px;\n                cursor: pointer;\n                text-align: center;\n            }\n    \n            #close-device-list:hover {\n                background: #cc0000;\n            }\n        `;\n        document.head.appendChild(style);\n    }\n\n    async connectScratchLink (options) {\n        try {\n            if (this._ble) {\n                this._ble.disconnect();\n            }\n            this.discoverCancelled = false;\n            this._ble = new BLE(this._runtime, this.extID, options, this._onConnect.bind(this), this.reset);\n            this.discovering = true;\n\n            // Ensure styles are applied\n            this.addStyles();\n    \n            // Create floating UI container\n            let container = document.getElementById('device-list-container');\n            if (!container) {\n                container = document.createElement('div');\n                container.id = 'device-list-container';\n                container.innerHTML = `\n                    <h3>Select a Device</h3>\n                    <ul id=\"device-list\"></ul>\n                    <button id=\"close-device-list\">Close</button>\n                `;\n                document.body.appendChild(container);\n    \n                document.getElementById('close-device-list').onclick = () => {\n                    document.body.removeChild(container);\n                    this.discovering = false; // Stop discovery when closed\n                    this.discoverCancelled = true;\n                };\n            }\n    \n            await this.scanForDevices();\n\n            if (this.discoverCancelled) {\n                this._ble.disconnect();\n                return false;\n            }\n\n            const device = this.device;\n            console.log(device);\n            \n            let sameDevices = 1;\n            this.deviceMap.forEach(value => {\n                if (value.device.name === device.name) {\n                    sameDevices++;\n                }\n            });\n            this.typeId = 0;\n            for (this.typeId = 0; this.typeId < DeviceTypes.length; this.typeId++) {\n                if (DeviceTypes[this.typeId].advName === device.name) {\n                    break;\n                }\n            }\n            if (this.typeId === DeviceTypes.length) {\n                this.typeId = 0;\n            }\n            this.displayName = `${DeviceTypes[this.typeId].name} ${sameDevices}`;\n            this.id = String(device.peripheralId);\n            this.deviceType = DeviceTypes[this.typeId];\n            this.sameDevices = sameDevices;\n            this.device = device;\n            this.SAMBotAvailable = (this.device.name === 'SAM BabyBot');\n            this.ActorAvailable = true;\n            this.SensorAvailable = true;\n            while (!this._ble.isConnected()) {\n                await new Promise(resolve => setTimeout(resolve, 500)); // Non-blocking delay\n            }\n        } catch (e) {\n            console.log(e);\n        }\n        return true;\n    }\n\n    _onConnect () {\n        console.log('connected to device');\n        this._ble.startNotifications(\n            SamLabsBLE.battServ,\n            SamLabsBLE.batteryLevelCharacteristic,\n            this.handleBattChange.bind(this)\n        );\n        this._ble.startNotifications(\n            SamLabsBLE.SAMServ,\n            SamLabsBLE.SensorCharacteristic,\n            this.handleSensorNotifications.bind(this)\n        );\n    }\n\n    async scanForDevices () {\n        this._runtime.on(this._runtime.constructor.PERIPHERAL_LIST_UPDATE, this.updateDeviceList.bind(this));\n        while (this.discovering && !this._ble.isConnected()) {\n            await new Promise(resolve => setTimeout(resolve, 100)); // Non-blocking delay\n        }\n    }\n    \n    updateDeviceList () {\n        const deviceList = document.getElementById('device-list');\n        if (!deviceList) return;\n    \n        deviceList.innerHTML = ''; // Clear existing list\n    \n        for (const [id, device] of Object.entries(this._ble._availablePeripherals)) {\n            const item = document.createElement('li');\n            item.textContent = device.name || `Unknown Device (${id})`;\n            item.dataset.deviceId = id;\n            item.onclick = () => this.handleDeviceSelection(id);\n            deviceList.appendChild(item);\n        }\n    }\n    \n    handleDeviceSelection (deviceId) {\n        console.log(`Selected device: ${deviceId}`);\n        this.deviceId = deviceId;\n        this.device = this._ble._availablePeripherals[deviceId];\n        console.log('connecting');\n        this._ble.connectPeripheral(deviceId);\n        this.discovering = false;\n        \n        // Close UI after selection\n        const container = document.getElementById('device-list-container');\n        if (container) {\n            document.body.removeChild(container);\n        }\n        console.log(this._ble.isConnected());\n    }\n\n    discoverTimeout () {\n        this.discovering = false;\n        this.discoverCancelled = true;\n        \n        const container = document.getElementById('device-list-container');\n        if (container) {\n            document.body.removeChild(container);\n        }\n    }\n\n    /**\n     * Write a message to the device with Csratch Link\n     * @param {string} uuid - the UUID of the characteristic to write to\n     * @param {Uint8Array} message - the message to write\n     */\n    async sendScratchLink (uuid, message) {\n        if (!this._ble.isConnected()) return;\n\n        await this._ble.write(\n            SamLabsBLE.SAMServ,\n            uuid,\n            Base64Util.uint8ArrayToBase64(message),\n            'base64'\n        );\n    }\n\n    handleSensorNotifications (event) {\n        let value;\n        if (this.webBLE) {\n            value = event.target.value.getUint8(0);\n        } else {\n            const data = Base64Util.base64ToUint8Array(event);\n            value = data[0];\n        }\n        if (DeviceTypes[this.typeId].invertValues) {\n            this.value = 100 - (value / 2.55);\n        } else {\n            this.value = value / 2.55;\n        }\n    }\n\n    handleBattChange (event) {\n        let value;\n        if (this.webBLE) {\n            value = event.target.value.getUint8(0);\n        } else {\n            const data = Base64Util.base64ToUint8Array(event);\n            value = data[0];\n        }\n        this.battery = value;\n    }\n\n    onDisconnected () {\n    }\n\n    /**\n     * send a message to the stus led characteristic\n     * @param {Uint8Array} msg the message\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     */\n    async writeStatusLed (msg, useLimiter = true) {\n        if (useLimiter) {\n            if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n        }\n        if (this.webBLE) {\n            await this.SAMStatusLEDCharacteristic.writeValue(msg);\n        } else {\n            await this.sendScratchLink(SamLabsBLE.StatusLedCharacteristic, msg);\n        }\n        return new Promise(resolve => {\n            window.setTimeout(() => {\n                resolve();\n            }, SamLabsBLE.sendInterval);\n        });\n    }\n\n    /**\n     * send a message to the actor characteristic\n     * @param {Uint8Array} msg the mesage\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     */\n    async writeActor (msg, useLimiter = true) {\n        if (useLimiter) {\n            if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n        }\n        if (this.webBLE) {\n            await this.SAMActorCharacteristic.writeValue(msg);\n        } else {\n            await this.sendScratchLink(SamLabsBLE.ActorCharacteristic, msg);\n        }\n        return new Promise(resolve => {\n            window.setTimeout(() => {\n                resolve();\n            }, SamLabsBLE.sendInterval);\n        });\n    }\n\n    /**\n     * send a message to the SamBot characteristic\n     * @param {Uint8Array} msg the mesage\n     * @param {boolean} [useLimiter=true] - if true, use the rate limiter\n     */\n    async writeBot (msg, useLimiter = true) {\n        if (useLimiter) {\n            if (!this._rateLimiter.okayToSend()) return Promise.resolve();\n        }\n        if (this.webBLE) {\n            await this.SAMBotCharacteristic.writeValue(msg);\n        } else {\n            await this.sendScratchLink(SamLabsBLE.SAMBotCommandCharacteristic, msg);\n        }\n        return new Promise(resolve => {\n            window.setTimeout(() => {\n                resolve();\n            }, SamLabsBLE.sendInterval);\n        });\n    }\n}\n\nmodule.exports = {SamLabsBLE, DeviceTypes, BabyBotIndex, SAMDevice};\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/./extensions/device.js?");

/***/ }),

/***/ "./extensions/samlabs.js":
/*!*******************************!*\
  !*** ./extensions/samlabs.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BlockType = __webpack_require__(/*! ../../scratch-vm/src/extension-support/block-type */ \"../scratch-vm/src/extension-support/block-type.js\");\nconst ArgumentType = __webpack_require__(/*! ../../scratch-vm/src/extension-support/argument-type */ \"../scratch-vm/src/extension-support/argument-type.js\");\n// const Target = require('../../engine/target');\nconst {SamLabsBLE, SAMDevice} = __webpack_require__(/*! ./device */ \"./extensions/device.js\");\n\n// eslint-disable-next-line no-unused-vars\nclass LEDArg {\n    num = '';\n    red = 0;\n    green = 0;\n    blue = 0;\n}\n\nclass Scratch3SamLabs {\n    constructor (runtime) {\n        this.runtime = runtime;\n        this.deviceMap = new Map(); // Store multiple devices\n        this.numberOfConnectedDevices = 0;\n        this.extensionId = 'samlabs';\n        this._stopAll = this.stopAll.bind(this);\n        this.runtime.on('PROJECT_STOP_ALL', this._stopAll);\n        this.runtime.on('PROJECT_RUN_STOP', this._stopAll);\n        this.deviceMenu = [];\n        this.BabyBotdeviceMenu = [];\n        this.blocks = [\n            {\n                opcode: 'connectToDevice',\n                blockType: BlockType.COMMAND,\n                text: 'Connect a device'\n            },\n            {\n                opcode: 'setLEDColor',\n                blockType: BlockType.COMMAND,\n                text: 'Set Block [num] Status Led Color: R[red], G[green], B[blue]',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER},\n                    red: {defaultValue: 0, type: ArgumentType.NUMBER},\n                    green: {defaultValue: 0, type: ArgumentType.NUMBER},\n                    blue: {defaultValue: 0, type: ArgumentType.NUMBER}\n                }\n            },\n            {\n                opcode: 'setLEDRGBColor',\n                blockType: BlockType.COMMAND,\n                text: 'Set Block [num] RGB Led Color: R[red], G[green], B[blue]',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER},\n                    red: {defaultValue: 0, type: ArgumentType.NUMBER},\n                    green: {defaultValue: 0, type: ArgumentType.NUMBER},\n                    blue: {defaultValue: 0, type: ArgumentType.NUMBER}\n                }\n            },\n            {\n                opcode: 'setBlockMotorSpeed',\n                blockType: BlockType.COMMAND,\n                text: 'Set Block [num] motor speed [val]',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER},\n                    val: {defaultValue: 0, type: ArgumentType.NUMBER}\n                }\n            },\n            {\n                opcode: 'setBlockServo',\n                blockType: BlockType.COMMAND,\n                text: 'Set Block [num] Servo angle [val]°',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER},\n                    val: {defaultValue: 0, type: ArgumentType.NUMBER}\n                }\n            },\n            {\n                opcode: 'getSensorValue',\n                blockType: BlockType.REPORTER,\n                text: 'Sensor value, Block [num]',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER}\n                }\n            },\n            {\n                opcode: 'getBattery',\n                blockType: BlockType.REPORTER,\n                text: 'Battery percentage, Block [num]',\n                terminal: false,\n                arguments: {\n                    num: {menu: 'deviceMenu', type: ArgumentType.NUMBER}\n                }\n            }\n        ];\n\n        // this.colors = [\n        //     '#FF00FF', '#00FFFF', '#FFFF00', '#808000',\n        //     '#FF0000', '#00FF00', '#0000FF'\n        // ];\n        // this.deviceAssetAvailable = false;\n        // this.runtime.on('PROJECT_LOADED', this.onProjectLoad.bind(this));\n        this.DeviceMapping = new Map();\n        // this.createDeviceListAsset();\n    }\n\n    // static get DeviceListAssetId () {\n    //     return '_SAMLabs_devicelist';\n    // }\n\n    // storeDeviceListToAsset () {\n    //     this.createDeviceListAsset();\n    // }\n\n    // loadDeviceListFromAsset () {\n    //     const asset = this.runtime.storage.get('_SAMLabs_devicelist', this.runtime.storage.DataFormat.JSON);\n    //     if (!asset) {\n    //         this.deviceAssetAvailable = false;\n    //         return;\n    //     }\n    //     this.deviceAssetAvailable = true;\n    //     const string = new TextDecoder().decode(asset.data);\n    //     const devices = JSON.parse(string);\n    //     this.deviceList = new Map(Object.entries(devices.deviceList));\n    //     this.DeviceMapping = new Map(Object.entries(devices.mapping));\n    // }\n\n    // createDeviceListAsset () {\n    //     const encoder = new TextEncoder();\n    //     const encodedData = encoder.encode(JSON.stringify({\n    //         deviceList: Object.fromEntries(this.deviceList),\n    //         mapping: Object.fromEntries(this.DeviceMapping)\n    //     }));\n    //     console.log('storing data:', encodedData);\n    //     this.runtime.storage.builtinHelper._store(\n    //         this.runtime.storage.AssetType.Sprite,\n    //         this.runtime.storage.DataFormat.JSON,\n    //         encodedData, '_SAMLabs_devicelist');\n    //     this.loadDeviceListFromAsset();\n    //     if (this.deviceAssetAvailable) {\n    //         return;\n    //     }\n    //     const asset = new this.runtime.storage.Asset(\n    //         this.runtime.storage.AssetType.Sprite,\n    //         '_SAMLabs_devicelist',\n    //         this.runtime.storage.DataFormat.JSON,\n    //         encodedData,\n    //         false\n    //     );\n    //     // Create a new sprite (target)\n    //     const newTarget = new Target(this.runtime);\n\n    //     // Replace the entire sprite data with JSON\n    //     newTarget.sprite = {\n    //         costumes: [\n    //             {\n    //                 asset: asset\n    //             }\n    //         ],\n    //         sounds: []\n    //     };\n\n    //     // Add the target to the runtime (makes it a real sprite)\n    //     this.runtime.targets.push(newTarget);\n        \n    //     console.log('Added new sprite:', newTarget);\n    //     this.deviceAssetAvailable = true;\n    // }\n\n    // onProjectLoad () {\n    //     this.loadDeviceListFromAsset();\n    //     if (!this.deviceAssetAvailable) {\n    //        this.createDeviceListAsset();\n    //     }\n    // }\n\n    // hexToRgb (hex) {\n    //     hex = hex.replace(/^#/, ''); // Remove \"#\" if present\n    //     if (hex.length === 3) {\n    //         // Convert short hex (e.g. #F00) to full hex (#FF0000)\n    //         hex = hex.split('').map(c => c + c)\n    //             .join('');\n    //     }\n    //     const r = parseInt(hex.substring(0, 2), 16);\n    //     const g = parseInt(hex.substring(2, 4), 16);\n    //     const b = parseInt(hex.substring(4, 6), 16);\n    //     return {r, g, b};\n    // }\n\n\n    getInfo () {\n        return {\n            id: this.extensionId,\n            name: 'SAM Labs',\n            showStatusButton: false,\n            color1: '#0FBD8C',\n            color2: '#0DA57A',\n            blocks: this.blocks,\n            menus: {\n                deviceMenu: 'getDeviceMenu',\n                babyBotCommand: 'getBabyBotCommandMenu'\n            }\n        };\n    }\n\n    updateDeviceMenu () {\n        this.deviceMenu = [];\n        this.BabyBotdeviceMenu = [];\n        this.deviceMap.forEach(device => {\n            this.deviceMenu.push({text: device.displayName, value: device.id});\n        });\n        // this.runtime.requestBlocksUpdate(); - messes up the create variable button\n    }\n\n    getDeviceMenu () {\n        return this.deviceMenu.length ? this.deviceMenu : [{text: '-', value: '-'}];\n    }\n\n    /**\n     * get the device with the given id\n     * @param {string} id the device id\n     * @returns {SAMDevice} the device\n     */\n    getDeviceFromId (id) {\n        if (this.DeviceMapping.get(id)) {\n            return this.deviceMap.get(this.DeviceMapping.get(id));\n        }\n        return this.deviceMap.get(id);\n    }\n\n    addBlock (newBlock) {\n        this.blocks.push(newBlock);\n        this.runtime._refreshExtensions(); // Force a refresh of the extension\n    }\n\n    stopAll () {\n        this.deviceMap.forEach(this.stopDevice.bind(this));\n    }\n\n    stopDevice (device) {\n        device.writeActor(new Uint8Array([0, 0, 0]), false);\n    }\n\n    async connectToDevice () {\n        const device = new SAMDevice(this.runtime, this.extensionId);\n        const connected = await device.connectToDevice(this.deviceMap, {\n            filters: [{\n                namePrefix: 'SAM'\n            }],\n            optionalServices: [SamLabsBLE.battServ, SamLabsBLE.SAMServ]\n        });\n        if (connected) {\n            this.deviceMap.set(device.id, device);\n            this.updateDeviceMenu();\n        }\n    }\n\n    /**\n     * set the status led color\n     * @param {LEDArg} args color\n     * @returns {void}\n     */\n    async setLEDColor (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block) {\n            return;\n        }\n        await this.setBlockLedColor(block, {r: args.red, g: args.green, b: args.blue});\n    }\n\n    /**\n     * set a blocks status led color\n     * @param {SAMDevice} block the device\n     * @param {Uint8Array} color color in RGB format\n     */\n    async setBlockLedColor (block, color) {\n        const message = new Uint8Array([\n            color.r,\n            color.g,\n            color.b\n        ]);\n        await block.writeStatusLed(message);\n    }\n\n    /**\n     * set the RGB (actor) led color\n     * @param {LEDArg} args color\n     * @returns {void}\n     */\n    async setLEDRGBColor (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block || !block.ActorAvailable) {\n            return;\n        }\n\n        const message = new Uint8Array([\n            args.red,\n            args.green,\n            args.blue\n        ]);\n        await block.writeActor(message);\n    }\n\n    async setBlockMotorSpeed (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block || !block.ActorAvailable) {\n            return;\n        }\n        let speed = Number(args.val);\n        if (speed < 0) {\n            if (speed < -100) {\n                speed = -100;\n            }\n            speed = (Math.abs(speed) * 1.27) + 128;\n        } else {\n            if (speed > 100) {\n                speed = 100;\n            }\n            speed = speed * 1.27;\n        }\n        const message = new Uint8Array([speed, 0, 0]);\n        await block.writeActor(message);\n    }\n\n    async setBlockServo (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block || !block.ActorAvailable) {\n            return;\n        }\n        const angle = Number(args.val);\n        const message = new Uint8Array([angle, 0, 0]);\n        await block.writeActor(message);\n    }\n\n    getSensorValue (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block) {\n            return 0;\n        }\n        return block.value;\n    }\n\n    getBattery (args) {\n        const block = this.getDeviceFromId(args.num);\n        if (!block) {\n            return 0;\n        }\n        return block.battery;\n    }\n}\n\nmodule.exports = Scratch3SamLabs;\n\n\n//# sourceURL=webpack://samlabs-scratch-extensions/./extensions/samlabs.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./extensions/samlabs.js");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;